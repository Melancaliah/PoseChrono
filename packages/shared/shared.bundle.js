/* Auto-generated by scripts/build-shared-bundle.js */
/* Sources: 49 files */

/* ===== packages/shared/frame-mode-detection.js ===== */
// Detect frame mode early to show custom title bar when needed.
(async function detectFrameMode() {
  try {
    const response = await fetch("manifest.json");
    const manifest = await response.json();
    if (manifest.main && manifest.main.frame === false) {
      document.body.classList.add("frameless");
    }
  } catch (_) {
    // Keep current fallback behavior: assume frameless if detection fails.
    document.body.classList.add("frameless");
  }
})();

/* ===== packages/shared/preferences-core.js ===== */
(function initPoseChronoSharedPreferencesCore(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const SESSION_MODES = ["classique", "custom", "relax", "memory"];
  const SESSION_MODE_SET = new Set(SESSION_MODES);

  function normalizeSessionModeValue(mode, fallback = "classique") {
    const normalized = String(mode ?? "")
      .trim()
      .toLowerCase();
    const fallbackNormalized = String(fallback ?? "classique")
      .trim()
      .toLowerCase();
    if (SESSION_MODE_SET.has(normalized)) return normalized;
    return SESSION_MODE_SET.has(fallbackNormalized)
      ? fallbackNormalized
      : "classique";
  }

  function normalizeStringArray(input) {
    if (!Array.isArray(input)) return [];
    const seen = new Set();
    const out = [];
    input.forEach((entry) => {
      if (typeof entry !== "string") return;
      const key = entry.trim();
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(key);
    });
    return out;
  }

  function createDefaultSessionModeUtils(options = {}) {
    const normalize =
      typeof options.normalizeSessionModeValue === "function"
        ? options.normalizeSessionModeValue
        : normalizeSessionModeValue;
    const getValue =
      typeof options.getValue === "function" ? options.getValue : () => undefined;
    const setValue =
      typeof options.setValue === "function" ? options.setValue : null;

    function load(fallback = "classique") {
      const safeFallback = normalize(fallback);
      try {
        const value = getValue();
        if (value === undefined || value === null || value === "") {
          return safeFallback;
        }
        return normalize(value, safeFallback);
      } catch (_) {
        return safeFallback;
      }
    }

    function save(mode, persist = true) {
      const next = normalize(mode);
      if (!persist || typeof setValue !== "function") return next;
      try {
        setValue(next);
      } catch (_) {}
      return next;
    }

    return {
      load,
      save,
    };
  }

  sharedRoot.prefs = {
    SESSION_MODES: SESSION_MODES.slice(),
    normalizeSessionModeValue,
    normalizeStringArray,
    createDefaultSessionModeUtils,
  };

  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/ui-preferences.js ===== */
(function initPoseChronoSharedUIPreferences(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createUIPreferences(options = {}) {
    const storage =
      options.storage ||
      (typeof localStorage !== "undefined" ? localStorage : null);

    const storageKey = String(options.storageKey || "posechrono-ui-prefs");
    const schemaVersion = Number(options.schemaVersion || 1);

    const legacyKeys = options.legacyKeys || {};
    const legacyDefaultSessionModeStorageKey = String(
      options.legacyDefaultSessionModeStorageKey || "posechrono-default-session-mode",
    );

    const normalizeSessionModeValue =
      typeof options.normalizeSessionModeValue === "function"
        ? options.normalizeSessionModeValue
        : (value, fallback = "classique") => {
            const modes = new Set(["classique", "custom", "relax", "memory"]);
            const normalized = String(value ?? "")
              .trim()
              .toLowerCase();
            const fallbackNormalized = String(fallback ?? "classique")
              .trim()
              .toLowerCase();
            return modes.has(normalized)
              ? normalized
              : modes.has(fallbackNormalized)
                ? fallbackNormalized
                : "classique";
          };

    const normalizeStringArray =
      typeof options.normalizeStringArray === "function"
        ? options.normalizeStringArray
        : (input) => {
            if (!Array.isArray(input)) return [];
            const seen = new Set();
            const out = [];
            input.forEach((entry) => {
              if (typeof entry !== "string") return;
              const key = entry.trim();
              if (!key || seen.has(key)) return;
              seen.add(key);
              out.push(key);
            });
            return out;
          };

    const defaultsInput = options.defaults || {};
    const BASE_DEFAULT_GRID_ENABLED = !!defaultsInput.backgroundGridEnabled;
    const BASE_DEFAULT_TITLEBAR_ALWAYS_VISIBLE =
      !!defaultsInput.titlebarAlwaysVisible;
    const BASE_DEFAULT_SESSION_MODE = normalizeSessionModeValue(
      defaultsInput.defaultSessionMode,
      "classique",
    );
    const BASE_DEFAULT_REVIEW_DURATIONS_VISIBLE =
      defaultsInput.reviewDurationsVisible !== false;
    const BASE_DEFAULT_SYNC_GUEST_ACTION_NOTIFICATIONS_ENABLED =
      defaultsInput.syncGuestActionNotificationsEnabled !== false;
    const BASE_DEFAULT_HOTKEYS_COLLAPSED = normalizeStringArray(
      defaultsInput.hotkeysCollapsedCategories,
    );
    const BASE_DEFAULT_GLOBAL_SETTINGS_COLLAPSED = normalizeStringArray(
      defaultsInput.globalSettingsCollapsedCategories?.length
        ? defaultsInput.globalSettingsCollapsedCategories
        : ["maintenance"],
    );
    const BASE_DEFAULT_PREFERRED_LANGUAGE =
      typeof defaultsInput.preferredLanguage === "string" &&
      defaultsInput.preferredLanguage.trim()
        ? defaultsInput.preferredLanguage.trim().toLowerCase()
        : "";

    const getDefaultPrefs = () => ({
      schemaVersion,
      backgroundGridEnabled: BASE_DEFAULT_GRID_ENABLED,
      titlebarAlwaysVisible: BASE_DEFAULT_TITLEBAR_ALWAYS_VISIBLE,
      defaultSessionMode: BASE_DEFAULT_SESSION_MODE,
      reviewDurationsVisible: BASE_DEFAULT_REVIEW_DURATIONS_VISIBLE,
      syncGuestActionNotificationsEnabled:
        BASE_DEFAULT_SYNC_GUEST_ACTION_NOTIFICATIONS_ENABLED,
      hotkeysCollapsedCategories: BASE_DEFAULT_HOTKEYS_COLLAPSED,
      globalSettingsCollapsedCategories: BASE_DEFAULT_GLOBAL_SETTINGS_COLLAPSED,
      preferredLanguage: BASE_DEFAULT_PREFERRED_LANGUAGE,
    });

    let cache = null;

    const persist = () => {
      if (!cache || !storage) return;
      try {
        storage.setItem(storageKey, JSON.stringify(cache));
      } catch (_) {}
    };

    const load = () => {
      if (cache) return cache;

      const defaults = getDefaultPrefs();
      let parsed = {};
      let changed = false;

      if (storage) {
        try {
          const raw = storage.getItem(storageKey);
          if (raw) {
            const obj = JSON.parse(raw);
            if (obj && typeof obj === "object") {
              parsed = obj;
            }
          }
        } catch (_) {
          changed = true;
        }
      }

      cache = {
        ...defaults,
        ...parsed,
        schemaVersion,
      };

      cache.backgroundGridEnabled = !!cache.backgroundGridEnabled;
      cache.titlebarAlwaysVisible = !!cache.titlebarAlwaysVisible;
      cache.reviewDurationsVisible = cache.reviewDurationsVisible !== false;
      cache.syncGuestActionNotificationsEnabled =
        cache.syncGuestActionNotificationsEnabled !== false;
      cache.defaultSessionMode = normalizeSessionModeValue(
        cache.defaultSessionMode,
        defaults.defaultSessionMode,
      );
      cache.hotkeysCollapsedCategories = normalizeStringArray(
        cache.hotkeysCollapsedCategories,
      );
      cache.globalSettingsCollapsedCategories = normalizeStringArray(
        cache.globalSettingsCollapsedCategories,
      );
      cache.preferredLanguage =
        typeof cache.preferredLanguage === "string"
          ? cache.preferredLanguage.trim().toLowerCase()
          : "";

      if (
        !Object.prototype.hasOwnProperty.call(parsed, "reviewDurationsVisible")
      ) {
        try {
          if (storage && legacyKeys.REVIEW_DURATIONS_VISIBLE) {
            const raw = storage.getItem(legacyKeys.REVIEW_DURATIONS_VISIBLE);
            if (raw !== null) {
              cache.reviewDurationsVisible = raw !== "0";
              changed = true;
              storage.removeItem(legacyKeys.REVIEW_DURATIONS_VISIBLE);
            }
          }
        } catch (_) {}
      }

      if (
        !Object.prototype.hasOwnProperty.call(
          parsed,
          "globalSettingsCollapsedCategories",
        )
      ) {
        try {
          if (storage && legacyKeys.GLOBAL_SETTINGS_COLLAPSED) {
            const raw = storage.getItem(legacyKeys.GLOBAL_SETTINGS_COLLAPSED);
            if (raw) {
              cache.globalSettingsCollapsedCategories = normalizeStringArray(
                JSON.parse(raw),
              );
              changed = true;
              storage.removeItem(legacyKeys.GLOBAL_SETTINGS_COLLAPSED);
            }
          }
        } catch (_) {}
      }

      if (!Object.prototype.hasOwnProperty.call(parsed, "defaultSessionMode")) {
        try {
          if (storage) {
            const raw = storage.getItem(legacyDefaultSessionModeStorageKey);
            if (raw) {
              cache.defaultSessionMode = normalizeSessionModeValue(
                raw,
                defaults.defaultSessionMode,
              );
              changed = true;
              storage.removeItem(legacyDefaultSessionModeStorageKey);
            }
          }
        } catch (_) {}
      }

      if (changed) persist();
      return cache;
    };

    const sanitizeByKey = (key, value) => {
      switch (key) {
        case "backgroundGridEnabled":
        case "titlebarAlwaysVisible":
        case "reviewDurationsVisible":
        case "syncGuestActionNotificationsEnabled":
          return !!value;
        case "defaultSessionMode":
          return normalizeSessionModeValue(value, BASE_DEFAULT_SESSION_MODE);
        case "hotkeysCollapsedCategories":
        case "globalSettingsCollapsedCategories":
          return normalizeStringArray(value);
        case "preferredLanguage":
          return typeof value === "string" ? value.trim().toLowerCase() : "";
        default:
          return value;
      }
    };

    return {
      init() {
        return load();
      },
      get(key, fallback = undefined) {
        const prefs = load();
        return Object.prototype.hasOwnProperty.call(prefs, key)
          ? prefs[key]
          : fallback;
      },
      set(key, value, optionsArg = {}) {
        const { persist: shouldPersist = true } = optionsArg || {};
        const prefs = load();
        prefs[key] = sanitizeByKey(key, value);
        if (shouldPersist) persist();
        return prefs[key];
      },
      getStringArray(key) {
        return normalizeStringArray(this.get(key, []));
      },
      setStringArray(key, value, optionsArg = {}) {
        return this.set(key, normalizeStringArray(value), optionsArg);
      },
      exportData() {
        const prefs = load();
        return {
          schemaVersion,
          backgroundGridEnabled: !!prefs.backgroundGridEnabled,
          titlebarAlwaysVisible: !!prefs.titlebarAlwaysVisible,
          defaultSessionMode: normalizeSessionModeValue(
            prefs.defaultSessionMode,
            BASE_DEFAULT_SESSION_MODE,
          ),
          reviewDurationsVisible: !!prefs.reviewDurationsVisible,
          syncGuestActionNotificationsEnabled:
            prefs.syncGuestActionNotificationsEnabled !== false,
          hotkeysCollapsedCategories: normalizeStringArray(
            prefs.hotkeysCollapsedCategories,
          ),
          globalSettingsCollapsedCategories: normalizeStringArray(
            prefs.globalSettingsCollapsedCategories,
          ),
          preferredLanguage:
            typeof prefs.preferredLanguage === "string"
              ? prefs.preferredLanguage.trim().toLowerCase()
              : "",
        };
      },
      importData(data, optionsArg = {}) {
        if (!data || typeof data !== "object") return false;
        const { persist: shouldPersist = true } = optionsArg || {};
        const prefs = load();
        const knownKeys = [
          "backgroundGridEnabled",
          "titlebarAlwaysVisible",
          "defaultSessionMode",
          "reviewDurationsVisible",
          "syncGuestActionNotificationsEnabled",
          "hotkeysCollapsedCategories",
          "globalSettingsCollapsedCategories",
          "preferredLanguage",
        ];
        let changed = false;
        knownKeys.forEach((key) => {
          if (!Object.prototype.hasOwnProperty.call(data, key)) return;
          prefs[key] = sanitizeByKey(key, data[key]);
          changed = true;
        });
        if (changed && shouldPersist) persist();
        return changed;
      },
      resetVisualPrefs() {
        cache = getDefaultPrefs();
        persist();
        return this.exportData();
      },
    };
  }

  sharedRoot.createUIPreferences = createUIPreferences;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/i18n-utils.js ===== */
(function initPoseChronoSharedI18nUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function getLocale(i18nInstance, fallback = "en-US") {
    try {
      const i18n = i18nInstance || (typeof i18next !== "undefined" ? i18next : null);
      if (i18n && typeof i18n.t === "function") {
        const locale = i18n.t("_locale");
        if (locale && locale !== "_locale") return locale;
      }
    } catch (_) {}
    return fallback;
  }

  function t(i18nInstance, key, options = {}, fallback = "") {
    try {
      const i18n = i18nInstance || (typeof i18next !== "undefined" ? i18next : null);
      if (i18n && typeof i18n.t === "function") {
        const result = i18n.t(key, options || {});
        return result !== key ? result : fallback;
      }
    } catch (_) {}
    return fallback;
  }

  function tCountLabel(
    i18nInstance,
    key,
    count,
    fallbackSingular = "",
    fallbackPlural = "",
  ) {
    const safeCount = Number.isFinite(Number(count)) ? Number(count) : 0;
    const fallback = safeCount === 1 ? fallbackSingular : fallbackPlural;
    return t(i18nInstance, key, { count: safeCount, defaultValue: fallback }, fallback);
  }

  sharedRoot.i18n = {
    getLocale,
    t,
    tCountLabel,
  };

  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/i18n-loader-utils.js ===== */
(function initPoseChronoSharedI18nLoaderUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function normalizeLocaleToken(token) {
    if (!token) return "";
    return String(token).trim().replace(/_/g, "-").toLowerCase();
  }

  function resolveLocaleLang(token, localeAliases, localeFileByLang) {
    const normalized = normalizeLocaleToken(token);
    if (!normalized) return null;

    if (localeAliases && localeAliases[normalized]) {
      return localeAliases[normalized];
    }

    const primary = normalized.split("-")[0];
    if (localeFileByLang && localeFileByLang[primary]) {
      return primary;
    }
    return null;
  }

  function createI18nLoaderUtils(options = {}) {
    const i18nextInstance = options.i18nextInstance || null;
    const fetchImpl =
      typeof options.fetchImpl === "function" ? options.fetchImpl : null;
    const windowObj = options.windowObj || null;
    const documentObj = options.documentObj || null;
    const navigatorObj = options.navigatorObj || null;
    const localesPath = String(options.localesPath || "./_locales/");
    const baseLang = String(options.baseLang || "en");
    const localeFileByLang = options.localeFileByLang || {};
    const localeAliases = options.localeAliases || {};
    const localeGetter =
      typeof options.localeGetter === "function" ? options.localeGetter : null;
    const cacheStorage =
      options.cacheStorage ||
      (windowObj && windowObj.localStorage ? windowObj.localStorage : null);
    const cacheEnabled = options.cacheEnabled !== false && !!cacheStorage;
    const cachePrefix = String(options.cachePrefix || "posechrono-i18n-cache");
    const cacheTtlMsRaw = Number(options.cacheTtlMs);
    const cacheTtlMs =
      Number.isFinite(cacheTtlMsRaw) && cacheTtlMsRaw > 0
        ? cacheTtlMsRaw
        : 7 * 24 * 60 * 60 * 1000;
    let cacheVersion =
      options.cacheVersion === null || options.cacheVersion === undefined
        ? ""
        : String(options.cacheVersion);
    const pendingRefreshByLang = new Map();

    function normalizeLanguageToken(token) {
      const lang = resolveLocaleLang(token, localeAliases, localeFileByLang);
      if (!lang) return null;
      if (!Object.prototype.hasOwnProperty.call(localeFileByLang, lang)) return null;
      return lang;
    }

    function buildCacheKey(lang) {
      const versionToken = String(cacheVersion || "").trim();
      if (!versionToken) return `${cachePrefix}:${lang}`;
      return `${cachePrefix}:${versionToken}:${lang}`;
    }

    function readCachedLocale(lang) {
      if (!cacheEnabled || !cacheStorage) return null;
      try {
        const raw = cacheStorage.getItem(buildCacheKey(lang));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const translation = parsed.translation;
        if (!translation || typeof translation !== "object") return null;
        const savedAt = Number(parsed.savedAt) || 0;
        const expired = !savedAt || Date.now() - savedAt > cacheTtlMs;
        return {
          translation,
          expired,
          savedAt,
        };
      } catch (_) {
        return null;
      }
    }

    function writeCachedLocale(lang, translation) {
      if (!cacheEnabled || !cacheStorage) return;
      if (!translation || typeof translation !== "object") return;
      try {
        cacheStorage.setItem(
          buildCacheKey(lang),
          JSON.stringify({
            lang,
            version: String(cacheVersion || ""),
            savedAt: Date.now(),
            translation,
          }),
        );
      } catch (_) {}
    }

    function setCacheVersion(nextVersion) {
      cacheVersion =
        nextVersion === null || nextVersion === undefined
          ? ""
          : String(nextVersion);
      return cacheVersion;
    }

    function getPreferredLocaleLang() {
      const candidates = [];

      if (typeof localeGetter === "function") {
        candidates.push(localeGetter());
      }

      if (i18nextInstance && typeof i18nextInstance.language === "string") {
        candidates.push(i18nextInstance.language);
      }

      if (
        documentObj &&
        documentObj.documentElement &&
        typeof documentObj.documentElement.lang === "string"
      ) {
        candidates.push(documentObj.documentElement.lang);
      }

      if (navigatorObj) {
        if (Array.isArray(navigatorObj.languages)) {
          candidates.push(...navigatorObj.languages);
        }
        if (typeof navigatorObj.language === "string") {
          candidates.push(navigatorObj.language);
        }
      }

      if (windowObj && typeof windowObj.getLocale === "function") {
        candidates.push(windowObj.getLocale());
      }

      for (const candidate of candidates) {
        const lang = resolveLocaleLang(candidate, localeAliases, localeFileByLang);
        if (lang) return lang;
      }

      return baseLang;
    }

    async function fetchLocaleTranslations(fileName) {
      if (!fetchImpl || !fileName) return null;
      try {
        const response = await fetchImpl(`${localesPath}${fileName}`);
        if (!response || !response.ok) return null;
        return await response.json();
      } catch (_) {
        return null;
      }
    }

    async function fetchAndCacheLocale(language) {
      const normalizedLanguage = normalizeLanguageToken(language);
      if (!normalizedLanguage) return null;

      if (pendingRefreshByLang.has(normalizedLanguage)) {
        return pendingRefreshByLang.get(normalizedLanguage);
      }

      const run = (async () => {
        const fileName = localeFileByLang[normalizedLanguage];
        if (!fileName) return null;
        const payload = await fetchLocaleTranslations(fileName);
        if (payload && typeof payload === "object") {
          writeCachedLocale(normalizedLanguage, payload);
          return payload;
        }
        return null;
      })();

      pendingRefreshByLang.set(normalizedLanguage, run);
      try {
        return await run;
      } finally {
        pendingRefreshByLang.delete(normalizedLanguage);
      }
    }

    async function loadTranslationsForLanguage(language) {
      const normalizedLanguage = normalizeLanguageToken(language);
      if (!normalizedLanguage) return null;

      const cached = readCachedLocale(normalizedLanguage);
      if (cached && cached.translation) {
        if (cached.expired) {
          void fetchAndCacheLocale(normalizedLanguage);
        }
        return cached.translation;
      }

      return await fetchAndCacheLocale(normalizedLanguage);
    }

    async function loadTranslations() {
      if (!i18nextInstance) return false;

      const preferredLang = getPreferredLocaleLang();
      const baseFileName = localeFileByLang[baseLang];
      if (!baseFileName) return false;

      const baseTranslations = await loadTranslationsForLanguage(baseLang);
      if (!baseTranslations) return false;

      const resources = {
        [baseLang]: {
          translation: baseTranslations,
        },
      };

      if (
        preferredLang !== baseLang &&
        Object.prototype.hasOwnProperty.call(localeFileByLang, preferredLang)
      ) {
        const preferredTranslations =
          await loadTranslationsForLanguage(preferredLang);
        if (preferredTranslations) {
          resources[preferredLang] = {
            translation: preferredTranslations,
          };
        }
      }

      const activeLang = resources[preferredLang] ? preferredLang : baseLang;
      const canInit = typeof i18nextInstance.init === "function";
      const isInitialized = !!i18nextInstance.isInitialized;

      if (!isInitialized && canInit) {
        await i18nextInstance.init({
          lng: activeLang,
          fallbackLng: baseLang,
          resources,
        });
        return true;
      }

      if (typeof i18nextInstance.addResourceBundle === "function") {
        Object.entries(resources).forEach(([lang, payload]) => {
          i18nextInstance.addResourceBundle(
            lang,
            "translation",
            payload.translation,
            true,
            true,
          );
        });
      }

      if (typeof i18nextInstance.changeLanguage === "function") {
        await i18nextInstance.changeLanguage(activeLang);
        return true;
      }

      if (canInit) {
        await i18nextInstance.init({
          lng: activeLang,
          fallbackLng: baseLang,
          resources,
        });
        return true;
      }

      return false;
    }

    return {
      loadTranslations,
      getPreferredLocaleLang,
      loadTranslationsForLanguage,
      setCacheVersion,
    };
  }

  sharedRoot.createI18nLoaderUtils = createI18nLoaderUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/dom-safety-utils.js ===== */
(function initPoseChronoSharedDomSafetyUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function escapeHtml(input) {
    const str = String(input ?? "");
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function encodeDataToken(input) {
    return encodeURIComponent(String(input ?? ""));
  }

  function decodeDataToken(input) {
    try {
      return decodeURIComponent(String(input ?? ""));
    } catch (_) {
      return String(input ?? "");
    }
  }

  function createDomSafetyUtils() {
    return {
      escapeHtml,
      encodeDataToken,
      decodeDataToken,
    };
  }

  sharedRoot.createDomSafetyUtils = createDomSafetyUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/storage-adapter.js ===== */
(function initPoseChronoSharedStorageAdapter(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createStorageAdapter(options = {}) {
    const DB_NAME = "posechrono-storage";
    const DB_VERSION = 1;
    const STORE_NAME = "kv";
    const FALLBACK_PREFIX = "posechrono-db:";
    const OPEN_TIMEOUT_MS = Math.max(
      200,
      Number(options.openTimeoutMs) || 1200,
    );
    const DISABLED_COOLDOWN_MS = Math.max(
      1000,
      Number(options.disabledCooldownMs) || 12 * 60 * 60 * 1000,
    );
    const DISABLED_UNTIL_KEY = `${FALLBACK_PREFIX}__indexeddb_disabled_until__`;
    const forceFallbackMode =
      options.forceFallbackMode === true ||
      (globalObj.poseChronoDesktop &&
        globalObj.poseChronoDesktop.platform === "desktop");
    let openPromise = null;
    let indexedDbAvailable = !forceFallbackMode;
    let fallbackNotified = false;
    let notify = typeof options.notify === "function" ? options.notify : null;

    function configure(nextOptions = {}) {
      if (typeof nextOptions.notify === "function") {
        notify = nextOptions.notify;
      }
    }

    const i18nText = (key, fallback) => {
      try {
        if (
          typeof i18next !== "undefined" &&
          typeof i18next.t === "function"
        ) {
          return i18next.t(key, { defaultValue: fallback });
        }
      } catch (_) {}
      return fallback;
    };

    const getDesktopStorageApi = () => {
      try {
        const api = globalObj.poseChronoDesktop?.storage;
        if (!api || typeof api !== "object") return null;
        if (
          typeof api.getJson !== "function" ||
          typeof api.setJson !== "function" ||
          typeof api.remove !== "function"
        ) {
          return null;
        }
        return api;
      } catch (_) {
        return null;
      }
    };

    const notifyFallbackMode = () => {
      if (fallbackNotified) return;
      fallbackNotified = true;
      const message = i18nText(
        "storage.fallbackActive",
        "Storage fallback enabled: IndexedDB unavailable, using local storage.",
      );

      if (
        typeof globalObj.showPoseChronoToast === "function"
      ) {
        globalObj.showPoseChronoToast({
          type: "error",
          message,
          duration: 5000,
        });
        return;
      }

      if (typeof notify === "function") {
        notify({
          title: message,
          body: "",
          mute: false,
          duration: 5000,
        });
      }
    };

    const cloneValue = (value) => {
      try {
        if (typeof structuredClone === "function") {
          return structuredClone(value);
        }
      } catch (_) {}
      return JSON.parse(JSON.stringify(value));
    };

    const readDisabledUntil = () => {
      try {
        const raw = localStorage.getItem(DISABLED_UNTIL_KEY);
        const until = Number(raw);
        if (!Number.isFinite(until) || until <= 0) return 0;
        if (until <= Date.now()) {
          localStorage.removeItem(DISABLED_UNTIL_KEY);
          return 0;
        }
        return until;
      } catch (_) {
        return 0;
      }
    };

    const writeDisabledUntil = (durationMs = DISABLED_COOLDOWN_MS) => {
      try {
        const until = Date.now() + Math.max(1000, Number(durationMs) || 0);
        localStorage.setItem(DISABLED_UNTIL_KEY, String(until));
      } catch (_) {}
    };

    const openDb = () => {
      if (!indexedDbAvailable) return Promise.resolve(null);
      if (openPromise) return openPromise;
      const disabledUntil = readDisabledUntil();
      if (disabledUntil > Date.now()) {
        indexedDbAvailable = false;
        notifyFallbackMode();
        return Promise.resolve(null);
      }

      openPromise = new Promise((resolve, reject) => {
        if (typeof indexedDB === "undefined") {
          reject(new Error("IndexedDB unavailable"));
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        let settled = false;
        const settle = (fn, value) => {
          if (settled) return;
          settled = true;
          clearTimeout(timeoutId);
          fn(value);
        };
        const timeoutId = setTimeout(() => {
          settle(
            reject,
            new Error(`IndexedDB open timeout (${OPEN_TIMEOUT_MS}ms)`),
          );
        }, OPEN_TIMEOUT_MS);

        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: "key" });
          }
        };
        request.onsuccess = () => settle(resolve, request.result);
        request.onerror = () =>
          settle(reject, request.error || new Error("open db failed"));
        request.onblocked = () =>
          settle(reject, new Error("IndexedDB open blocked"));
      }).catch((error) => {
        console.warn("[Storage] IndexedDB disabled, fallback localStorage:", error);
        indexedDbAvailable = false;
        writeDisabledUntil(DISABLED_COOLDOWN_MS);
        notifyFallbackMode();
        return null;
      });
      return openPromise;
    };

    const getFallbackKey = (key) => `${FALLBACK_PREFIX}${key}`;

    const withStore = async (mode, fn) => {
      const db = await openDb();
      if (!db) return null;
      return new Promise((resolve, reject) => {
        try {
          const tx = db.transaction(STORE_NAME, mode);
          const store = tx.objectStore(STORE_NAME);
          const req = fn(store);
          tx.oncomplete = () => resolve(req ? req.result : null);
          tx.onabort = () => reject(tx.error || new Error("transaction aborted"));
          tx.onerror = () => reject(tx.error || new Error("transaction error"));
        } catch (e) {
          reject(e);
        }
      });
    };

    const getJson = async (key, fallback = null) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            const response = await desktopStorageApi.getJson(key);
            if (response && response.found === true) {
              return cloneValue(response.value);
            }
            try {
              const legacyRaw = localStorage.getItem(getFallbackKey(key));
              if (legacyRaw === null) return fallback;
              const legacyParsed = JSON.parse(legacyRaw);
              await desktopStorageApi.setJson(key, cloneValue(legacyParsed));
              return legacyParsed;
            } catch (_) {
              return fallback;
            }
          }
          try {
            const raw = localStorage.getItem(getFallbackKey(key));
            if (raw === null) return fallback;
            return JSON.parse(raw);
          } catch (_) {
            return fallback;
          }
        }
        const row = await withStore("readonly", (store) => store.get(key));
        if (!row || row.value === undefined || row.value === null) return fallback;
        return cloneValue(row.value);
      } catch (e) {
        console.warn("[Storage] getJson failed:", key, e);
        return fallback;
      }
    };

    const setJson = async (key, value) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            return !!(await desktopStorageApi.setJson(key, cloneValue(value)));
          }
          localStorage.setItem(
            getFallbackKey(key),
            JSON.stringify(cloneValue(value)),
          );
          return true;
        }
        const payload = {
          key,
          value: cloneValue(value),
          updatedAt: Date.now(),
        };
        await withStore("readwrite", (store) => store.put(payload));
        return true;
      } catch (e) {
        console.warn("[Storage] setJson failed:", key, e);
        return false;
      }
    };

    const remove = async (key) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            return !!(await desktopStorageApi.remove(key));
          }
          localStorage.removeItem(getFallbackKey(key));
          return true;
        }
        await withStore("readwrite", (store) => store.delete(key));
        return true;
      } catch (e) {
        console.warn("[Storage] remove failed:", key, e);
        return false;
      }
    };

    const migrateFromLocalStorage = async (
      localStorageKey,
      dbKey,
      fallback = null,
    ) => {
      const existing = await getJson(dbKey, undefined);
      if (existing !== undefined) return existing;

      let parsed = fallback;
      try {
        const raw = localStorage.getItem(localStorageKey);
        if (raw) parsed = JSON.parse(raw);
      } catch (e) {
        console.warn("[Storage] migration parse failed:", localStorageKey, e);
      }

      if (parsed !== undefined) {
        const written = await setJson(dbKey, parsed);
        if (written) {
          try {
            localStorage.removeItem(localStorageKey);
          } catch (_) {}
        }
      }
      return parsed;
    };

    return {
      getJson,
      setJson,
      remove,
      migrateFromLocalStorage,
      configure,
      status() {
        return {
          indexedDbAvailable,
          fallbackMode: !indexedDbAvailable,
        };
      },
    };
  }

  sharedRoot.createStorageAdapter = createStorageAdapter;
  globalObj.PoseChronoShared = sharedRoot;

  if (!globalObj.PoseChronoStorage) {
    globalObj.PoseChronoStorage = createStorageAdapter({
      forceFallbackMode:
        !!globalObj.poseChronoDesktop &&
        globalObj.poseChronoDesktop.platform === "desktop",
    });
  }
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/runtime-mode-utils.js ===== */
(function initPoseChronoSharedRuntimeModeUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createRuntimeModeUtils(options = {}) {
    const desktopPlatformValue = String(options.desktopPlatformValue || "desktop");

    function isDesktopStandaloneRuntime() {
      try {
        return (
          typeof window !== "undefined" &&
          !!window.poseChronoDesktop &&
          window.poseChronoDesktop.platform === desktopPlatformValue
        );
      } catch (_) {
        return false;
      }
    }

    function getRevealActionI18nKey() {
      return isDesktopStandaloneRuntime()
        ? "drawing.revealInExplorer"
        : "drawing.openInEagle";
    }

    function getAppSubtitleI18nKey() {
      return isDesktopStandaloneRuntime() ? "app.subtitleDesktop" : "app.subtitle";
    }

    function getMediaSourceAnalyzedI18nKey(useFallbackSource = false) {
      if (isDesktopStandaloneRuntime()) {
        return "settings.mediaFoldersAnalyzed";
      }
      return useFallbackSource
        ? "settings.allLibraryAnalyzed"
        : "settings.imagesAnalyzed";
    }

    function isCapabilityEnabled(platform, capabilityKey, fallback = false) {
      const key = String(capabilityKey || "").trim();
      if (!key) return !!fallback;
      const capabilities = platform?.capabilities;
      if (
        capabilities &&
        Object.prototype.hasOwnProperty.call(capabilities, key)
      ) {
        return !!capabilities[key];
      }
      return !!fallback;
    }

    function isTagsFeatureAvailable(platform) {
      return isCapabilityEnabled(
        platform,
        "tags",
        !isDesktopStandaloneRuntime(),
      );
    }

    return {
      isDesktopStandaloneRuntime,
      getRevealActionI18nKey,
      getAppSubtitleI18nKey,
      getMediaSourceAnalyzedI18nKey,
      isCapabilityEnabled,
      isTagsFeatureAvailable,
    };
  }

  sharedRoot.createRuntimeModeUtils = createRuntimeModeUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sync-transport-mock.js ===== */
(function initPoseChronoSharedSyncTransportMock(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSyncTransportMock(options = {}) {
    const busKey = String(
      options.busKey || "__POSECHRONO_SYNC_MOCK_TRANSPORT_BUS__",
    );
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();
    const maxParticipants = Math.max(
      2,
      Number(options.maxParticipants || 32) || 32,
    );
    const maxSessionNameLength = Math.max(
      16,
      Number(options.maxSessionNameLength || 80) || 80,
    );
    const maxPasswordLength = Math.max(
      8,
      Number(options.maxPasswordLength || 128) || 128,
    );
    const maxClientIdLength = Math.max(
      8,
      Number(options.maxClientIdLength || 64) || 64,
    );
    const maxStateReasonLength = Math.max(
      16,
      Number(options.maxStateReasonLength || 96) || 96,
    );
    const maxStateBytes = Math.max(
      4096,
      Number(options.maxStateBytes || 900000) || 900000,
    );
    const maxCustomQueueSteps = Math.max(
      1,
      Number(options.maxCustomQueueSteps || 600) || 600,
    );
    const maxMediaOrderKeys = Math.max(
      1,
      Number(options.maxMediaOrderKeys || 12000) || 12000,
    );
    const maxSessionPackBytes = Math.max(
      4096,
      Number(options.maxSessionPackBytes || 2 * 1024 * 1024) || 2 * 1024 * 1024,
    );
    const maxSessionMediaFiles = Math.max(
      1,
      Number(options.maxSessionMediaFiles || 300) || 300,
    );
    const maxSessionMediaFileBytes = Math.max(
      1024,
      Number(options.maxSessionMediaFileBytes || 2 * 1024 * 1024) || 2 * 1024 * 1024,
    );
    const maxSessionMediaTotalBytes = Math.max(
      maxSessionMediaFileBytes,
      Number(options.maxSessionMediaTotalBytes || 48 * 1024 * 1024) || 48 * 1024 * 1024,
    );
    const maxSessionSeconds = Math.max(
      60,
      Number(options.maxSessionSeconds || 31_536_000) || 31_536_000,
    );
    const maxTimestampMs = Math.max(
      0,
      Number(options.maxTimestampMs || 4_102_444_800_000) || 4_102_444_800_000,
    );
    const maxIndexValue = Math.max(
      1,
      Number(options.maxIndexValue || 200000) || 200000,
    );
    const sessionModeValues = new Set([
      "classique",
      "classic",
      "custom",
      "relax",
      "memory",
    ]);
    const memoryTypeValues = new Set(["flash", "progressive"]);
    const sessionPackSchema = "posechrono-session-pack";
    const sessionPackVersion = 1;
    const sessionMediaAllowedExtensions = new Set([
      "jpg",
      "jpeg",
      "png",
      "webp",
      "mp4",
      "webm",
    ]);
    const sessionMediaMimeByExt = {
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      png: "image/png",
      webp: "image/webp",
      mp4: "video/mp4",
      webm: "video/webm",
    };

    function getGlobalCarrier() {
      if (typeof globalThis !== "undefined") return globalThis;
      if (typeof window !== "undefined") return window;
      return globalObj;
    }

    function ensureBus() {
      const carrier = getGlobalCarrier();
      const existing = carrier[busKey];
      if (
        existing &&
        existing.rooms instanceof Map &&
        existing.subscriptions instanceof Map
      ) {
        return existing;
      }
      const created = {
        rooms: new Map(),
        subscriptions: new Map(),
      };
      carrier[busKey] = created;
      return created;
    }

    function normalizeSessionCode(input) {
      const normalized = String(input || "")
        .trim()
        .toUpperCase();
      if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(normalized)) {
        return "";
      }
      return normalized;
    }

    function normalizeControlMode(input) {
      return String(input || "").trim() === "shared-pause"
        ? "shared-pause"
        : "host-only";
    }

    function isPlainObject(value) {
      return !!value && typeof value === "object" && !Array.isArray(value);
    }

    function sanitizeText(value, maxLength, fallback = "") {
      const text = String(value || "")
        .replace(/[\u0000-\u001f\u007f]/g, "")
        .trim();
      if (!text) return String(fallback || "").trim();
      return text.slice(0, Math.max(1, Number(maxLength) || 1));
    }

    function normalizeClientId(input, errorCode) {
      const id = String(input || "").trim();
      const safeMax = Math.max(8, Number(maxClientIdLength) || 64);
      const re = new RegExp(`^[A-Za-z0-9_-]{1,${safeMax}}$`);
      if (!re.test(id)) {
        throw new Error(String(errorCode || "invalid-client-id"));
      }
      return id;
    }

    function normalizeSessionName(input) {
      return sanitizeText(input, maxSessionNameLength, "PoseChrono Session");
    }

    function normalizePassword(input) {
      const value = String(input || "").trim();
      if (value.length > maxPasswordLength) {
        throw new Error("invalid-password");
      }
      return value;
    }

    function toBoundedInt(value, min, max, errorCode) {
      const raw = Number(value);
      if (!Number.isFinite(raw)) {
        throw new Error(String(errorCode || "invalid-session-state"));
      }
      const next = Math.floor(raw);
      if (next < min || next > max) {
        throw new Error(String(errorCode || "invalid-session-state"));
      }
      return next;
    }

    function normalizeParticipantName(input, fallback = "") {
      const value = sanitizeText(input, 32, "");
      return value || String(fallback || "").trim();
    }

    function normalizeParticipantSyncState(input) {
      const value = String(input || "").trim().toLowerCase();
      if (
        value === "ready" ||
        value === "missing" ||
        value === "connecting" ||
        value === "downloading"
      ) {
        return value;
      }
      return "missing";
    }

    function computePackHash(text) {
      const value = String(text || "");
      let h1 = 2166136261;
      let h2 = 5381;
      for (let i = 0; i < value.length; i += 1) {
        const code = value.charCodeAt(i);
        h1 ^= code;
        h1 = Math.imul(h1, 16777619);
        h2 = ((h2 << 5) + h2 + code) >>> 0;
      }
      const a = (h1 >>> 0).toString(16).padStart(8, "0");
      const b = (h2 >>> 0).toString(16).padStart(8, "0");
      return `${a}${b}`;
    }

    function normalizeSessionMediaIdentity(input) {
      const value = String(input || "").trim();
      if (!value || value.length > 128 || !/^[A-Za-z0-9:_-]+$/.test(value)) {
        throw new Error("invalid-session-media");
      }
      return value;
    }

    function normalizeSessionMediaExtension(input) {
      const ext = String(input || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "")
        .slice(0, 12);
      if (!sessionMediaAllowedExtensions.has(ext)) {
        throw new Error("session-media-unsupported-type");
      }
      return ext;
    }

    function normalizeSessionMediaMime(ext, inputMime) {
      const mime = String(inputMime || "")
        .trim()
        .toLowerCase()
        .slice(0, 80);
      const expectedMime = sessionMediaMimeByExt[ext] || "";
      if (!mime) return expectedMime;
      if (
        mime !== expectedMime &&
        !(
          (ext === "jpg" || ext === "jpeg") &&
          (mime === "image/jpg" || mime === "image/jpeg")
        )
      ) {
        throw new Error("session-media-unsupported-type");
      }
      return expectedMime || mime;
    }

    function normalizeSessionMediaName(input) {
      return sanitizeText(input, 160, "unknown");
    }

    function normalizeSessionMediaFilePayload(input) {
      if (!isPlainObject(input)) {
        throw new Error("invalid-session-media");
      }

      const identity = normalizeSessionMediaIdentity(input.identity);
      const ext = normalizeSessionMediaExtension(input.ext);
      const mime = normalizeSessionMediaMime(ext, input.mime);
      const name = normalizeSessionMediaName(input.name);
      const size = toBoundedInt(
        input.size,
        1,
        maxSessionMediaTotalBytes,
        "invalid-session-media",
      );
      if (size > maxSessionMediaFileBytes) {
        throw new Error("session-media-too-large");
      }
      const dataBase64 = String(input.dataBase64 || "")
        .replace(/\s+/g, "")
        .trim();
      if (!dataBase64 || !/^[A-Za-z0-9+/=]+$/.test(dataBase64)) {
        throw new Error("invalid-session-media");
      }
      let decodedLength = 0;
      if (typeof atob === "function") {
        const decoded = atob(dataBase64);
        decodedLength = decoded ? decoded.length : 0;
      } else if (
        typeof globalObj.Buffer === "function" &&
        typeof globalObj.Buffer.from === "function"
      ) {
        const decodedBuffer = globalObj.Buffer.from(dataBase64, "base64");
        decodedLength = decodedBuffer ? decodedBuffer.length : 0;
      } else {
        const normalizedLength = dataBase64.replace(/=+$/g, "").length;
        decodedLength = Math.floor((normalizedLength * 3) / 4);
      }
      if (decodedLength !== size) {
        throw new Error("invalid-session-media");
      }
      const computedSha256 = computePackHash(dataBase64);
      const declaredSha256 = String(input.sha256 || "")
        .trim()
        .toLowerCase();
      if (
        declaredSha256 &&
        (!/^[a-f0-9]{8,64}$/.test(declaredSha256) ||
          (declaredSha256.length <= 16 && declaredSha256 !== computedSha256))
      ) {
        throw new Error("invalid-session-media");
      }

      return {
        identity,
        name,
        ext,
        mime,
        size,
        sha256: declaredSha256 || computedSha256,
        dataBase64,
      };
    }

    function makeSnapshot(room) {
      if (!room) return null;
      const participantIds = Array.from(room.participantIds);
      const participantProfiles = {};
      const participantSyncStates = {};
      if (room.participantProfiles && typeof room.participantProfiles.forEach === "function") {
        room.participantProfiles.forEach((name, clientId) => {
          const normalizedClientId = String(clientId || "").trim();
          if (!normalizedClientId) return;
          participantProfiles[normalizedClientId] = normalizeParticipantName(name);
        });
      }
      if (
        room.participantSyncStates &&
        typeof room.participantSyncStates.forEach === "function"
      ) {
        room.participantSyncStates.forEach((syncState, clientId) => {
          const normalizedClientId = String(clientId || "").trim();
          if (!normalizedClientId) return;
          participantSyncStates[normalizedClientId] =
            normalizeParticipantSyncState(syncState);
        });
      }
      return {
        sessionCode: room.sessionCode,
        sessionName: room.sessionName,
        controlMode: room.controlMode,
        hostClientId: room.hostClientId,
        participantIds: participantIds.slice(),
        participantProfiles,
        participantSyncStates,
        participantsCount: participantIds.length,
        sessionState:
          room.sessionState && typeof room.sessionState === "object"
            ? { ...room.sessionState }
            : null,
        sessionStateRevision: Math.max(
          0,
          Number(room.sessionStateRevision || 0) || 0,
        ),
        sessionStateUpdatedAt: Math.max(
          0,
          Number(room.sessionStateUpdatedAt || 0) || 0,
        ),
        sessionPackMeta:
          room.sessionPack && typeof room.sessionPack === "object"
            ? {
                hash: String(room.sessionPackHash || "").trim(),
                size: Math.max(0, Number(room.sessionPackSize || 0) || 0),
                updatedAt: Math.max(0, Number(room.sessionPackUpdatedAt || 0) || 0),
                uploadedBy: String(room.sessionPackUploadedBy || "").trim(),
                imagesCount: Math.max(
                  0,
                  Number(room.sessionPack?.session?.imagesCount || 0) || 0,
                ),
                mediaRefsCount: Array.isArray(room.sessionPack?.mediaRefs)
                  ? room.sessionPack.mediaRefs.length
                  : 0,
              }
            : null,
        sessionMediaMeta:
          room.sessionMediaFiles instanceof Map
            ? {
                filesCount: room.sessionMediaFiles.size,
                totalBytes: Math.max(0, Number(room.sessionMediaTotalBytes || 0) || 0),
                updatedAt: Math.max(0, Number(room.sessionMediaUpdatedAt || 0) || 0),
                uploadedBy: String(room.sessionMediaUploadedBy || "").trim(),
              }
            : null,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt,
      };
    }

    function normalizeSessionStatePayload(input) {
      if (!isPlainObject(input)) {
        if (input === null || input === undefined) return {};
        throw new Error("invalid-session-state");
      }

      const serializedLength = JSON.stringify(input).length;
      if (serializedLength > maxStateBytes) {
        throw new Error("session-state-too-large");
      }

      const out = {};
      const keys = Object.keys(input);
      if (keys.length > 64) {
        throw new Error("invalid-session-state");
      }

      function expectBoolean(value) {
        if (typeof value !== "boolean") throw new Error("invalid-session-state");
        return value;
      }

      function normalizeMode(value) {
        const mode = String(value || "")
          .trim()
          .toLowerCase();
        if (!sessionModeValues.has(mode)) throw new Error("invalid-session-state");
        return mode === "classic" ? "classique" : mode;
      }

      function normalizeMemoryType(value) {
        const memoryType = String(value || "")
          .trim()
          .toLowerCase();
        if (!memoryTypeValues.has(memoryType)) {
          throw new Error("invalid-session-state");
        }
        return memoryType;
      }

      function normalizeMediaOrderKeys(value) {
        if (!Array.isArray(value)) throw new Error("invalid-session-state");
        if (value.length > maxMediaOrderKeys) {
          throw new Error("invalid-session-state");
        }
        return value.map((entry) => {
          const key = String(entry || "").trim();
          if (!key || key.length > 128 || !/^[A-Za-z0-9:_-]+$/.test(key)) {
            throw new Error("invalid-session-state");
          }
          return key;
        });
      }

      function normalizeCustomQueueStep(step, index) {
        if (!isPlainObject(step)) throw new Error("invalid-session-state");
        const type = String(step.type || "").trim().toLowerCase();
        if (type !== "pause" && type !== "pose") {
          throw new Error("invalid-session-state");
        }
        const duration = toBoundedInt(
          step.duration,
          1,
          86400,
          "invalid-session-state",
        );
        const count =
          type === "pause"
            ? 1
            : toBoundedInt(step.count, 1, 10000, "invalid-session-state");
        const normalizedStep = {
          type,
          duration,
          count,
        };
        if (step.id !== undefined) {
          normalizedStep.id = toBoundedInt(
            step.id,
            0,
            Number.MAX_SAFE_INTEGER,
            "invalid-session-state",
          );
        } else {
          normalizedStep.id = now() + index;
        }
        return normalizedStep;
      }

      function normalizeCustomQueue(value) {
        if (!Array.isArray(value)) throw new Error("invalid-session-state");
        if (value.length > maxCustomQueueSteps) {
          throw new Error("invalid-session-state");
        }
        return value.map((step, index) => normalizeCustomQueueStep(step, index));
      }

      keys.forEach((key) => {
        if (!key) return;
        const value = input[key];
        if (value === undefined || typeof value === "function") return;

        switch (key) {
          case "reason":
            out.reason = sanitizeText(value, maxStateReasonLength, "");
            return;
          case "mode":
            out.mode = normalizeMode(value);
            return;
          case "memoryType":
            out.memoryType = normalizeMemoryType(value);
            return;
          case "requestType": {
            const requestType = String(value || "").trim().toLowerCase();
            if (requestType !== "pause" && requestType !== "play") {
              throw new Error("invalid-session-state");
            }
            out.requestType = requestType;
            return;
          }
          case "sessionActive":
          case "reviewActive":
          case "isPlaying":
          case "memoryNoPressure":
          case "memoryHidden":
          case "mediaOrderTruncated":
          case "mediaOrderSkipped":
            out[key] = expectBoolean(value);
            return;
          case "selectedDuration":
            out.selectedDuration = toBoundedInt(
              value,
              1,
              maxSessionSeconds,
              "invalid-session-state",
            );
            return;
          case "timeRemaining":
            out.timeRemaining = toBoundedInt(
              value,
              0,
              maxSessionSeconds,
              "invalid-session-state",
            );
            return;
          case "memoryDuration":
          case "memoryDrawingTime":
          case "totalSessionTime":
            out[key] = toBoundedInt(
              value,
              0,
              maxSessionSeconds,
              "invalid-session-state",
            );
            return;
          case "currentIndex":
          case "currentStepIndex":
            out[key] = toBoundedInt(
              value,
              0,
              maxIndexValue,
              "invalid-session-state",
            );
            return;
          case "currentPoseInStep":
          case "memoryPosesCount":
            out[key] = toBoundedInt(value, 1, 10000, "invalid-session-state");
            return;
          case "imagesCount":
          case "customQueueLength":
          case "mediaOrderCount":
            out[key] = toBoundedInt(
              value,
              0,
              maxMediaOrderKeys,
              "invalid-session-state",
            );
            return;
          case "ts":
          case "updatedAt":
            out[key] = toBoundedInt(value, 0, maxTimestampMs, "invalid-session-state");
            return;
          case "revision":
            out.revision = toBoundedInt(
              value,
              0,
              maxIndexValue,
              "invalid-session-state",
            );
            return;
          case "customQueue":
            out.customQueue = normalizeCustomQueue(value);
            out.customQueueLength = out.customQueue.length;
            return;
          case "mediaOrderKeys":
            out.mediaOrderKeys = normalizeMediaOrderKeys(value);
            out.mediaOrderCount = out.mediaOrderKeys.length;
            return;
          default:
            return;
        }
      });

      return out;
    }

    function normalizeSessionPackPayload(input) {
      if (!isPlainObject(input)) {
        throw new Error("invalid-session-pack");
      }

      const serializedLength = JSON.stringify(input).length;
      if (serializedLength > maxSessionPackBytes) {
        throw new Error("session-pack-too-large");
      }

      const schema = String(input.schema || "").trim();
      const version = Math.floor(Number(input.version || 0));
      if (schema !== sessionPackSchema || version !== sessionPackVersion) {
        throw new Error("invalid-session-pack");
      }

      const session = isPlainObject(input.session) ? input.session : null;
      if (!session) throw new Error("invalid-session-pack");
      const mode = String(session.mode || "")
        .trim()
        .toLowerCase();
      if (!sessionModeValues.has(mode)) throw new Error("invalid-session-pack");

      const out = {
        schema: sessionPackSchema,
        version: sessionPackVersion,
        createdAt: sanitizeText(input.createdAt, 48, ""),
        source: {
          runtime: sanitizeText(input?.source?.runtime, 24, ""),
          language: sanitizeText(input?.source?.language, 24, ""),
        },
        session: {
          mode: mode === "classic" ? "classique" : mode,
          selectedDuration: toBoundedInt(
            session.selectedDuration,
            1,
            maxSessionSeconds,
            "invalid-session-pack",
          ),
          timeRemaining: toBoundedInt(
            session.timeRemaining,
            0,
            maxSessionSeconds,
            "invalid-session-pack",
          ),
          memoryType: (() => {
            const value = String(session.memoryType || "")
              .trim()
              .toLowerCase();
            if (!memoryTypeValues.has(value)) throw new Error("invalid-session-pack");
            return value;
          })(),
          memoryDuration: toBoundedInt(
            session.memoryDuration,
            0,
            maxSessionSeconds,
            "invalid-session-pack",
          ),
          memoryPosesCount: toBoundedInt(
            session.memoryPosesCount,
            1,
            10000,
            "invalid-session-pack",
          ),
          memoryDrawingTime: toBoundedInt(
            session.memoryDrawingTime,
            0,
            maxSessionSeconds,
            "invalid-session-pack",
          ),
          memoryNoPressure: !!session.memoryNoPressure,
          customQueue: [],
          mediaOrderKeys: [],
          imagesCount: toBoundedInt(
            session.imagesCount,
            0,
            maxMediaOrderKeys,
            "invalid-session-pack",
          ),
        },
        mediaRefs: [],
      };

      const customQueue = Array.isArray(session.customQueue) ? session.customQueue : [];
      if (customQueue.length > maxCustomQueueSteps) {
        throw new Error("invalid-session-pack");
      }
      out.session.customQueue = customQueue.map((step, index) => {
        if (!isPlainObject(step)) throw new Error("invalid-session-pack");
        const type = String(step.type || "").trim().toLowerCase();
        if (type !== "pause" && type !== "pose") throw new Error("invalid-session-pack");
        const duration = toBoundedInt(
          step.duration,
          1,
          86400,
          "invalid-session-pack",
        );
        const count =
          type === "pause"
            ? 1
            : toBoundedInt(step.count, 1, 10000, "invalid-session-pack");
        const id =
          step.id !== undefined
            ? toBoundedInt(step.id, 0, Number.MAX_SAFE_INTEGER, "invalid-session-pack")
            : now() + index;
        return {
          type,
          duration,
          count,
          id,
        };
      });

      const mediaOrderKeys = Array.isArray(session.mediaOrderKeys)
        ? session.mediaOrderKeys
        : [];
      if (mediaOrderKeys.length > maxMediaOrderKeys) {
        throw new Error("invalid-session-pack");
      }
      out.session.mediaOrderKeys = mediaOrderKeys.map((entry) => {
        const key = String(entry || "").trim();
        if (!key || key.length > 128 || !/^[A-Za-z0-9:_-]+$/.test(key)) {
          throw new Error("invalid-session-pack");
        }
        return key;
      });

      const mediaRefs = Array.isArray(input.mediaRefs) ? input.mediaRefs : [];
      if (mediaRefs.length > maxMediaOrderKeys) {
        throw new Error("invalid-session-pack");
      }
      out.mediaRefs = mediaRefs.map((item) => {
        if (!isPlainObject(item)) throw new Error("invalid-session-pack");
        const identity = String(item.identity || "").trim();
        if (!identity || identity.length > 128 || !/^[A-Za-z0-9:_-]+$/.test(identity)) {
          throw new Error("invalid-session-pack");
        }
        const name = sanitizeText(item.name, 160, "unknown");
        const ext = String(item.ext || "")
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "")
          .slice(0, 12);
        const index = toBoundedInt(
          item.index,
          0,
          maxMediaOrderKeys,
          "invalid-session-pack",
        );
        return {
          identity,
          index,
          name,
          ext,
        };
      });

      return out;
    }

  function withPreservedMediaOrder(previousState, nextState) {
    const previous =
      previousState && typeof previousState === "object" ? previousState : null;
    const next = nextState && typeof nextState === "object" ? nextState : {};
    if (Object.prototype.hasOwnProperty.call(next, "mediaOrderKeys")) {
      return next;
    }

    if (Array.isArray(previous?.mediaOrderKeys) && previous.mediaOrderKeys.length > 0) {
      next.mediaOrderKeys = previous.mediaOrderKeys.slice();
    }
    return next;
  }

    function normalizeSharedPlaybackRequestPayload(input) {
      const requestType =
        String(input?.requestType || "").trim() === "play" ? "play" : "pause";
      return {
        requestType,
        isPlaying: requestType === "play",
        reason: String(
          input?.reason ||
            (requestType === "play"
              ? "shared-play-request"
              : "shared-pause-request"),
        ),
        ts: Math.max(0, Number(input?.ts || now()) || now()),
      };
    }

    function emitToSession(sessionCode, payload) {
      const bus = ensureBus();
      const code = normalizeSessionCode(sessionCode);
      if (!code) return;
      const subscriptions = bus.subscriptions.get(code);
      if (!subscriptions || subscriptions.size === 0) return;
      subscriptions.forEach((handler) => {
        try {
          handler(payload);
        } catch (_) {}
      });
    }

    function assertRoomAccess(room, password) {
      if (!room) {
        throw new Error("session-not-found");
      }
      const normalizedPassword = normalizePassword(password);
      if (room.password && room.password !== normalizedPassword) {
        throw new Error("invalid-password");
      }
    }

    function createRoom(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      if (!sessionCode) {
        throw new Error("invalid-session-code");
      }
      if (bus.rooms.has(sessionCode)) {
        throw new Error("session-already-exists");
      }

      const hostClientId = normalizeClientId(
        input.hostClientId,
        "invalid-host-client-id",
      );

      const sessionName = normalizeSessionName(input.sessionName);
      const controlMode = normalizeControlMode(input.controlMode);
      const room = {
        sessionCode,
        sessionName,
        controlMode,
        hostClientId,
        password: normalizePassword(input.password),
        participantIds: new Set([hostClientId]),
        participantProfiles: new Map([
          [hostClientId, normalizeParticipantName(input.hostDisplayName, "Hte")],
        ]),
        participantSyncStates: new Map([[hostClientId, "ready"]]),
        sessionState: null,
        sessionStateRevision: 0,
        sessionStateUpdatedAt: 0,
        sessionPack: null,
        sessionPackHash: "",
        sessionPackSize: 0,
        sessionPackUpdatedAt: 0,
        sessionPackUploadedBy: "",
        sessionMediaFiles: new Map(),
        sessionMediaUpdatedAt: 0,
        sessionMediaUploadedBy: "",
        sessionMediaTotalBytes: 0,
        createdAt: now(),
        updatedAt: now(),
      };

      bus.rooms.set(sessionCode, room);
      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "host-created",
        snapshot,
      });
      return snapshot;
    }

    function joinRoom(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      assertRoomAccess(room, input.password);

      const clientId = normalizeClientId(input.clientId, "invalid-client-id");
      if (clientId === room.hostClientId) {
        throw new Error("forbidden-host-impersonation");
      }
      if (room.participantIds.has(clientId)) {
        throw new Error("duplicate-client-id");
      }
      if (room.participantIds.size >= maxParticipants) {
        throw new Error("room-full");
      }

      room.participantIds.add(clientId);
      room.participantProfiles.set(
        clientId,
        normalizeParticipantName(input.participantName, "Invit"),
      );
      if (!(room.participantSyncStates instanceof Map)) {
        room.participantSyncStates = new Map();
      }
      room.participantSyncStates.set(clientId, "connecting");
      room.updatedAt = now();
      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "participant-joined",
        snapshot,
      });
      return snapshot;
    }

    function leaveRoom(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) return { closed: false, snapshot: null };

      const clientId = String(input.clientId || "").trim();
      room.participantIds.delete(clientId);
      room.participantProfiles.delete(clientId);
      if (room.participantSyncStates instanceof Map) {
        room.participantSyncStates.delete(clientId);
      }
      room.updatedAt = now();

      const shouldCloseRoom =
        clientId === room.hostClientId || room.participantIds.size <= 0;
      if (shouldCloseRoom) {
        const snapshot = makeSnapshot(room);
        bus.rooms.delete(sessionCode);
        emitToSession(sessionCode, {
          type: "room-closed",
          source: "host-left",
          snapshot,
        });
        bus.subscriptions.delete(sessionCode);
        return { closed: true, snapshot };
      }

      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "participant-left",
        snapshot,
      });
      return { closed: false, snapshot };
    }

    function updateRoom(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = String(input.sourceClientId || "").trim();
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (sourceClientId !== room.hostClientId) {
        throw new Error("forbidden-not-host");
      }

      const patch = input.patch && typeof input.patch === "object" ? input.patch : {};

      if (typeof patch.sessionName === "string") {
        const nextName = patch.sessionName.trim();
        if (nextName) room.sessionName = nextName;
      }
      if (typeof patch.controlMode === "string") {
        room.controlMode = normalizeControlMode(patch.controlMode);
      }

      room.updatedAt = now();
      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "room-updated",
        snapshot,
      });
      return snapshot;
    }

    function updateParticipantState(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      const syncState = normalizeParticipantSyncState(input.syncState);
      if (!(room.participantSyncStates instanceof Map)) {
        room.participantSyncStates = new Map();
      }
      room.participantSyncStates.set(sourceClientId, syncState);
      room.updatedAt = now();

      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "participant-state-updated",
        snapshot,
      });
      return snapshot;
    }

    function updateSessionState(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = String(input.sourceClientId || "").trim();
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      let payload = normalizeSessionStatePayload(input.payload || {});
      const isHostSource = sourceClientId === room.hostClientId;
      const requestType = String(payload.requestType || "").trim();
      const canSharedPlayback =
        room.controlMode === "shared-pause" &&
        !isHostSource &&
        payload &&
        (requestType === "pause" || requestType === "play") &&
        payload.isPlaying === (requestType === "play");

      if (!isHostSource && !canSharedPlayback) {
        throw new Error("forbidden-not-host");
      }

      if (canSharedPlayback) {
        payload = normalizeSharedPlaybackRequestPayload(payload);
      }

      room.sessionState = withPreservedMediaOrder(room.sessionState, {
        ...payload,
      });
      room.sessionStateRevision = (Number(room.sessionStateRevision) || 0) + 1;
      room.sessionStateUpdatedAt = now();
      room.updatedAt = room.sessionStateUpdatedAt;

      const eventState = {
        ...room.sessionState,
        revision: room.sessionStateRevision,
        updatedAt: room.sessionStateUpdatedAt,
        sourceClientId,
      };

      emitToSession(sessionCode, {
        type: "session-state-updated",
        source: "host-state-update",
        sessionCode,
        state: eventState,
      });

      return eventState;
    }

    function uploadSessionPack(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (sourceClientId !== room.hostClientId) {
        throw new Error("forbidden-not-host");
      }

      const pack = normalizeSessionPackPayload(input.pack || null);
      const serializedPack = JSON.stringify(pack);
      const packHash = computePackHash(serializedPack);
      const updatedAt = now();

      room.sessionPack = pack;
      room.sessionPackHash = packHash;
      room.sessionPackSize = serializedPack.length;
      room.sessionPackUpdatedAt = updatedAt;
      room.sessionPackUploadedBy = sourceClientId;
      room.updatedAt = updatedAt;

      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "session-pack-updated",
        sessionCode,
        snapshot,
      });
      return snapshot;
    }

    function getSessionPack(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (!room.sessionPack || typeof room.sessionPack !== "object") {
        throw new Error("session-pack-not-found");
      }

      return {
        pack: room.sessionPack,
        hash: String(room.sessionPackHash || "").trim(),
        updatedAt: Math.max(0, Number(room.sessionPackUpdatedAt || 0) || 0),
        size: Math.max(0, Number(room.sessionPackSize || 0) || 0),
      };
    }

    function resetSessionMediaPack(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (sourceClientId !== room.hostClientId) {
        throw new Error("forbidden-not-host");
      }

      room.sessionMediaFiles = new Map();
      room.sessionMediaTotalBytes = 0;
      room.sessionMediaUpdatedAt = now();
      room.sessionMediaUploadedBy = sourceClientId;
      room.updatedAt = room.sessionMediaUpdatedAt;

      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "session-media-reset",
        sessionCode,
        snapshot,
      });
      return snapshot;
    }

    function uploadSessionMediaFile(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (sourceClientId !== room.hostClientId) {
        throw new Error("forbidden-not-host");
      }

      const file = normalizeSessionMediaFilePayload(input.file || null);
      if (!(room.sessionMediaFiles instanceof Map)) {
        room.sessionMediaFiles = new Map();
      }
      const previous = room.sessionMediaFiles.get(file.identity);
      const previousSize = previous ? Math.max(0, Number(previous.size || 0) || 0) : 0;
      const nextTotal =
        Math.max(0, Number(room.sessionMediaTotalBytes || 0) || 0) - previousSize + file.size;
      if (nextTotal > maxSessionMediaTotalBytes) {
        throw new Error("session-media-too-large");
      }
      if (!previous && room.sessionMediaFiles.size >= maxSessionMediaFiles) {
        throw new Error("session-media-too-large");
      }

      const storedFile = {
        identity: file.identity,
        name: file.name,
        ext: file.ext,
        mime: file.mime,
        size: file.size,
        sha256: file.sha256,
        dataBase64: file.dataBase64,
        updatedAt: now(),
      };
      room.sessionMediaFiles.set(file.identity, storedFile);
      room.sessionMediaTotalBytes = nextTotal;
      room.sessionMediaUpdatedAt = storedFile.updatedAt;
      room.sessionMediaUploadedBy = sourceClientId;
      room.updatedAt = storedFile.updatedAt;

      const snapshot = makeSnapshot(room);
      emitToSession(sessionCode, {
        type: "room-updated",
        source: "session-media-updated",
        sessionCode,
        snapshot,
      });
      return snapshot;
    }

    function getSessionMediaManifest(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (!(room.sessionMediaFiles instanceof Map) || room.sessionMediaFiles.size <= 0) {
        throw new Error("session-media-not-found");
      }

      const files = Array.from(room.sessionMediaFiles.values()).map((entry) => ({
        identity: String(entry.identity || "").trim(),
        name: sanitizeText(entry.name, 160, "unknown"),
        ext: String(entry.ext || "").trim().toLowerCase(),
        mime: String(entry.mime || "").trim().toLowerCase(),
        size: Math.max(0, Number(entry.size || 0) || 0),
        sha256: String(entry.sha256 || "").trim().toLowerCase(),
        updatedAt: Math.max(0, Number(entry.updatedAt || 0) || 0),
      }));

      return {
        files,
        filesCount: files.length,
        totalBytes: Math.max(0, Number(room.sessionMediaTotalBytes || 0) || 0),
        updatedAt: Math.max(0, Number(room.sessionMediaUpdatedAt || 0) || 0),
        uploadedBy: String(room.sessionMediaUploadedBy || "").trim(),
      };
    }

    function getSessionMediaFile(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }
      if (!(room.sessionMediaFiles instanceof Map) || room.sessionMediaFiles.size <= 0) {
        throw new Error("session-media-not-found");
      }

      const identity = normalizeSessionMediaIdentity(input.identity);
      const entry = room.sessionMediaFiles.get(identity);
      if (!entry) {
        throw new Error("session-media-file-not-found");
      }

      return {
        file: {
          identity: String(entry.identity || "").trim(),
          name: sanitizeText(entry.name, 160, "unknown"),
          ext: String(entry.ext || "").trim().toLowerCase(),
          mime: String(entry.mime || "").trim().toLowerCase(),
          size: Math.max(0, Number(entry.size || 0) || 0),
          sha256: String(entry.sha256 || "").trim().toLowerCase(),
          dataBase64: String(entry.dataBase64 || "").trim(),
          updatedAt: Math.max(0, Number(entry.updatedAt || 0) || 0),
        },
      };
    }

    function sendRtcSignal(input = {}) {
      const bus = ensureBus();
      const sessionCode = normalizeSessionCode(input.sessionCode);
      const room = bus.rooms.get(sessionCode);
      if (!room) {
        throw new Error("session-not-found");
      }

      const sourceClientId = normalizeClientId(
        input.sourceClientId,
        "invalid-client-id",
      );
      if (!room.participantIds.has(sourceClientId)) {
        throw new Error("not-joined");
      }

      const targetClientIdRaw = String(input.targetClientId || "").trim();
      const targetClientId = targetClientIdRaw
        ? normalizeClientId(targetClientIdRaw, "invalid-client-id")
        : "";
      if (targetClientId && !room.participantIds.has(targetClientId)) {
        throw new Error("not-joined");
      }

      const signalType = String(input.signalType || "")
        .trim()
        .toLowerCase();
      if (
        signalType !== "offer" &&
        signalType !== "answer" &&
        signalType !== "ice-candidate" &&
        signalType !== "peer-reset"
      ) {
        throw new Error("invalid-rtc-signal");
      }

      const signalPayload =
        input.signalPayload === undefined ? null : input.signalPayload;
      let serialized = "";
      try {
        serialized = JSON.stringify(signalPayload);
      } catch (_) {
        throw new Error("invalid-rtc-signal");
      }
      if (serialized.length > 240000) {
        throw new Error("invalid-rtc-signal");
      }

      emitToSession(sessionCode, {
        type: "rtc-signal",
        sessionCode,
        sourceClientId,
        targetClientId,
        signalType,
        signalPayload,
        ts: now(),
      });

      return { ok: true };
    }

    function getRoomSnapshot(sessionCode) {
      const bus = ensureBus();
      const code = normalizeSessionCode(sessionCode);
      return makeSnapshot(bus.rooms.get(code));
    }

    function subscribe(sessionCode, handler) {
      if (typeof handler !== "function") {
        return () => {};
      }

      const bus = ensureBus();
      const code = normalizeSessionCode(sessionCode);
      if (!code) return () => {};

      if (!bus.subscriptions.has(code)) {
        bus.subscriptions.set(code, new Set());
      }
      const set = bus.subscriptions.get(code);
      set.add(handler);

      return () => {
        const active = bus.subscriptions.get(code);
        if (!active) return;
        active.delete(handler);
        if (active.size <= 0) {
          bus.subscriptions.delete(code);
        }
      };
    }

    return {
      createRoom,
      joinRoom,
      leaveRoom,
      updateRoom,
      updateSessionState,
      updateParticipantState,
      uploadSessionPack,
      getSessionPack,
      resetSessionMediaPack,
      uploadSessionMediaFile,
      getSessionMediaManifest,
      getSessionMediaFile,
      sendRtcSignal,
      getRoomSnapshot,
      subscribe,
    };
  }

  sharedRoot.createSyncTransportMock = createSyncTransportMock;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sync-transport-websocket.js ===== */
(function initPoseChronoSharedSyncTransportWebSocket(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSyncTransportWebSocket(options = {}) {
    const WebSocketCtor =
      options.WebSocketCtor ||
      (typeof WebSocket !== "undefined" ? WebSocket : null);
    const targetUrl = String(options.url || "").trim();
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();
    const logger =
      typeof options.logger === "function" ? options.logger : () => {};
    const setTimeoutFn =
      typeof options.setTimeout === "function"
        ? options.setTimeout
        : setTimeout;
    const clearTimeoutFn =
      typeof options.clearTimeout === "function"
        ? options.clearTimeout
        : clearTimeout;
    const requestTimeoutMs = Math.max(
      1000,
      Number(options.requestTimeoutMs || 8000) || 8000,
    );
    const mediaTransferEnabled = options.allowMediaTransfer !== false;

    // Reconnection config
    const maxReconnectAttempts = Math.max(
      0,
      Number(options.maxReconnectAttempts ?? 10) || 0,
    );
    const reconnectBaseDelayMs = Math.max(
      500,
      Number(options.reconnectBaseDelayMs || 1000) || 1000,
    );
    const reconnectMaxDelayMs = Math.max(
      reconnectBaseDelayMs,
      Number(options.reconnectMaxDelayMs || 30000) || 30000,
    );

    if (!WebSocketCtor) {
      throw new Error("websocket-unavailable");
    }
    if (!targetUrl) {
      throw new Error("websocket-url-missing");
    }

    const requireTls = options.requireTls === true;
    const urlProtocol = (targetUrl.split("://")[0] || "").toLowerCase();
    if (requireTls && urlProtocol !== "wss") {
      logger("[SyncWS] TLS required but URL uses " + urlProtocol + "://");
      throw new Error("websocket-tls-required");
    }
    if (!requireTls && urlProtocol === "ws") {
      logger("[SyncWS] Warning: using unencrypted ws://  consider wss:// for production");
    }

    let socket = null;
    let connectPromise = null;
    let nextRequestId = 1;
    const pending = new Map();
    const sessionSubscriptions = new Map();

    // Reconnection state
    let reconnectAttempt = 0;
    let reconnectTimerId = null;
    let connectionState = "disconnected";
    const connectionStateListeners = new Set();
    let explicitDisconnect = false;

    function emitConnectionState(newState) {
      if (connectionState === newState) return;
      connectionState = newState;
      connectionStateListeners.forEach((listener) => {
        try {
          listener(newState);
        } catch (_) {}
      });
    }

    function onConnectionStateChange(listener) {
      if (typeof listener !== "function") return () => {};
      connectionStateListeners.add(listener);
      return () => {
        connectionStateListeners.delete(listener);
      };
    }

    function cancelReconnect() {
      if (reconnectTimerId) {
        clearTimeoutFn(reconnectTimerId);
        reconnectTimerId = null;
      }
      reconnectAttempt = 0;
    }

    function scheduleReconnect() {
      if (reconnectTimerId) return;
      if (explicitDisconnect) return;
      if (maxReconnectAttempts <= 0) {
        emitConnectionState("disconnected");
        return;
      }
      if (reconnectAttempt >= maxReconnectAttempts) {
        logger(
          "[SyncWS] max reconnect attempts reached (" +
            maxReconnectAttempts +
            ")",
        );
        emitConnectionState("disconnected");
        return;
      }
      reconnectAttempt += 1;
      const delay = Math.min(
        reconnectBaseDelayMs * Math.pow(2, reconnectAttempt - 1),
        reconnectMaxDelayMs,
      );
      logger(
        "[SyncWS] reconnecting in " +
          delay +
          "ms (attempt " +
          reconnectAttempt +
          "/" +
          maxReconnectAttempts +
          ")",
      );
      reconnectTimerId = setTimeoutFn(() => {
        reconnectTimerId = null;
        ensureConnected().catch((error) => {
          logger("[SyncWS] reconnect attempt failed", error);
        });
      }, delay);
    }

    function normalizeSessionCode(input) {
      const normalized = String(input || "")
        .trim()
        .toUpperCase();
      if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(normalized)) {
        return "";
      }
      return normalized;
    }

    function clearPendingRequest(requestId) {
      const entry = pending.get(requestId);
      if (!entry) return null;
      pending.delete(requestId);
      if (entry.timerId) {
        clearTimeoutFn(entry.timerId);
      }
      return entry;
    }

    function rejectAllPending(errorCode) {
      const reason = String(errorCode || "websocket-disconnected");
      pending.forEach((_, requestId) => {
        const entry = clearPendingRequest(requestId);
        if (!entry) return;
        entry.reject(new Error(reason));
      });
    }

    function parseMessage(raw) {
      try {
        if (typeof raw === "string") return JSON.parse(raw);
        if (raw && typeof raw === "object" && "toString" in raw) {
          return JSON.parse(String(raw));
        }
      } catch (_) {}
      return null;
    }

    function emitSessionEvent(eventPayload) {
      if (!eventPayload || typeof eventPayload !== "object") return;
      const eventCode = normalizeSessionCode(
        eventPayload.sessionCode || eventPayload.snapshot?.sessionCode,
      );
      if (!eventCode) return;
      const listeners = sessionSubscriptions.get(eventCode);
      if (!listeners || listeners.size <= 0) return;
      listeners.forEach((listener) => {
        try {
          listener(eventPayload);
        } catch (_) {}
      });
    }

    function sendRaw(message) {
      if (!socket || socket.readyState !== 1) {
        throw new Error("websocket-not-open");
      }
      socket.send(JSON.stringify(message));
    }

    async function ensureConnected() {
      if (socket && socket.readyState === 1) {
        return socket;
      }
      if (connectPromise) {
        return connectPromise;
      }

      emitConnectionState(
        reconnectAttempt > 0 ? "reconnecting" : "connecting",
      );

      connectPromise = new Promise((resolve, reject) => {
        const ws = new WebSocketCtor(targetUrl);
        let settled = false;

        ws.onopen = () => {
          socket = ws;
          settled = true;
          connectPromise = null;
          reconnectAttempt = 0;
          cancelReconnect();
          emitConnectionState("connected");

          sessionSubscriptions.forEach((_, sessionCode) => {
            try {
              sendRaw({
                type: "notify",
                action: "subscribe",
                payload: { sessionCode },
              });
            } catch (_) {}
          });

          resolve(ws);
        };

        ws.onmessage = (event) => {
          const payload = parseMessage(event && event.data);
          if (!payload || typeof payload !== "object") return;

          if (payload.type === "response") {
            const requestId = String(payload.id || "");
            const entry = clearPendingRequest(requestId);
            if (!entry) return;

            if (payload.ok === false) {
              const errorCode = String(payload.error || "request-failed");
              if (errorCode === "unknown-action") {
                const actionName = String(entry.action || "").trim() || "unknown";
                entry.reject(new Error(`unknown-action:${actionName}`));
              } else {
                entry.reject(new Error(errorCode));
              }
              return;
            }

            entry.resolve(payload.result);
            return;
          }

          if (payload.type === "event") {
            emitSessionEvent(payload.event || payload.payload || null);
          }
        };

        ws.onerror = (event) => {
          logger("[SyncWS] socket error", event);
          if (!settled) {
            connectPromise = null;
            reject(new Error("websocket-connect-failed"));
          }
        };

        ws.onclose = () => {
          if (socket === ws) {
            socket = null;
          }
          if (!settled) {
            connectPromise = null;
            reject(new Error("websocket-connect-closed"));
            if (!explicitDisconnect) {
              emitConnectionState("reconnecting");
              scheduleReconnect();
            }
            return;
          }
          rejectAllPending("websocket-disconnected");
          if (!explicitDisconnect) {
            emitConnectionState("reconnecting");
            scheduleReconnect();
          }
        };
      });

      return connectPromise;
    }

    async function request(action, payload = {}) {
      await ensureConnected();
      const requestId = String(nextRequestId++);
      const sentAt = now();

      return new Promise((resolve, reject) => {
        const timerId = setTimeoutFn(() => {
          const entry = clearPendingRequest(requestId);
          if (!entry) return;
          entry.reject(new Error("websocket-request-timeout"));
        }, requestTimeoutMs);

        pending.set(requestId, {
          resolve,
          reject,
          timerId,
          action: String(action || ""),
          sentAt,
        });

        try {
          sendRaw({
            type: "request",
            id: requestId,
            action,
            payload,
          });
        } catch (error) {
          clearPendingRequest(requestId);
          reject(error);
        }
      });
    }

    async function notify(action, payload = {}) {
      await ensureConnected();
      sendRaw({
        type: "notify",
        action,
        payload,
      });
      return true;
    }

    function subscribe(sessionCode, handler) {
      if (typeof handler !== "function") {
        return () => {};
      }
      const normalizedCode = normalizeSessionCode(sessionCode);
      if (!normalizedCode) {
        return () => {};
      }

      if (!sessionSubscriptions.has(normalizedCode)) {
        sessionSubscriptions.set(normalizedCode, new Set());
      }
      const listeners = sessionSubscriptions.get(normalizedCode);
      const wasEmpty = listeners.size <= 0;
      listeners.add(handler);

      if (wasEmpty) {
        void notify("subscribe", { sessionCode: normalizedCode }).catch((error) => {
          logger("[SyncWS] subscribe notify failed", error);
        });
      }

      return () => {
        const active = sessionSubscriptions.get(normalizedCode);
        if (!active) return;
        active.delete(handler);
        if (active.size <= 0) {
          sessionSubscriptions.delete(normalizedCode);
          void notify("unsubscribe", { sessionCode: normalizedCode }).catch((error) => {
            logger("[SyncWS] unsubscribe notify failed", error);
          });
        }
      };
    }

    function disconnect() {
      explicitDisconnect = true;
      cancelReconnect();
      if (socket) {
        try {
          socket.close();
        } catch (_) {}
        socket = null;
      }
      connectPromise = null;
      rejectAllPending("websocket-disconnected");
      emitConnectionState("disconnected");
    }

    return {
      createRoom(payload) {
        return request("createRoom", payload || {});
      },
      joinRoom(payload) {
        return request("joinRoom", payload || {});
      },
      leaveRoom(payload) {
        return request("leaveRoom", payload || {});
      },
      updateRoom(payload) {
        return request("updateRoom", payload || {});
      },
      updateSessionState(payload) {
        return request("updateSessionState", payload || {});
      },
      updateParticipantState(payload) {
        return request("updateParticipantState", payload || {});
      },
      uploadSessionPack(payload) {
        return request("uploadSessionPack", payload || {});
      },
      getSessionPack(payload) {
        return request("getSessionPack", payload || {});
      },
      resetSessionMediaPack(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        return request("resetSessionMediaPack", payload || {});
      },
      uploadSessionMediaFile(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        return request("uploadSessionMediaFile", payload || {});
      },
      getSessionMediaManifest(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        return request("getSessionMediaManifest", payload || {});
      },
      getSessionMediaFile(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        return request("getSessionMediaFile", payload || {});
      },
      sendRtcSignal(payload) {
        return request("sendRtcSignal", payload || {});
      },
      getRoomSnapshot(sessionCode) {
        return request("getRoomSnapshot", {
          sessionCode: normalizeSessionCode(sessionCode),
        });
      },
      subscribe,
      disconnect,
      onConnectionStateChange,
      getConnectionState() {
        return connectionState;
      },
    };
  }

  sharedRoot.createSyncTransportWebSocket = createSyncTransportWebSocket;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sync-transport-webrtc.js ===== */
(function initPoseChronoSharedSyncTransportWebRTC(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSyncTransportWebRTC(options = {}) {
    const logger =
      typeof options.logger === "function" ? options.logger : () => {};
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();
    const setTimeoutFn =
      typeof options.setTimeout === "function"
        ? options.setTimeout
        : setTimeout;
    const clearTimeoutFn =
      typeof options.clearTimeout === "function"
        ? options.clearTimeout
        : clearTimeout;

    const RTCPeerConnectionCtor =
      options.RTCPeerConnectionCtor ||
      (typeof RTCPeerConnection !== "undefined" ? RTCPeerConnection : null);
    const RTCSessionDescriptionCtor =
      options.RTCSessionDescriptionCtor ||
      (typeof RTCSessionDescription !== "undefined" ? RTCSessionDescription : null);
    const RTCIceCandidateCtor =
      options.RTCIceCandidateCtor ||
      (typeof RTCIceCandidate !== "undefined" ? RTCIceCandidate : null);

    if (!RTCPeerConnectionCtor) {
      throw new Error("webrtc-unavailable");
    }

    const signalingFactory =
      typeof options.createSignalingTransport === "function"
        ? options.createSignalingTransport
        : typeof sharedRoot.createSyncTransportWebSocket === "function"
          ? sharedRoot.createSyncTransportWebSocket
          : null;

    if (typeof signalingFactory !== "function") {
      throw new Error("webrtc-signaling-unavailable");
    }

    const signalingUrl = String(
      options.signalingUrl || options.url || "",
    ).trim();
    if (!signalingUrl) {
      throw new Error("webrtc-signaling-url-missing");
    }

    const rtcConfiguration =
      options.rtcConfiguration ||
      options.rtcConfig || {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun.cloudflare.com:3478" },
        ],
      };
    const maxMeshPeers = Math.max(
      1,
      Number(options.maxMeshPeers || 4) || 4,
    );
    const p2pRequestTimeoutMs = Math.max(
      1000,
      Number(options.p2pRequestTimeoutMs || 12000) || 12000,
    );
    const mediaChunkBase64Size = Math.max(
      2048,
      Number(options.mediaChunkBase64Size || 12000) || 12000,
    );
    const maxBufferedAmountBeforeYield = Math.max(
      mediaChunkBase64Size * 2,
      Number(options.maxBufferedAmountBeforeYield || 512 * 1024) || 512 * 1024,
    );
    const sendYieldDelayMs = Math.max(
      1,
      Number(options.sendYieldDelayMs || 12) || 12,
    );
    const mirrorMediaToRelay = options.mirrorMediaToRelay !== false;
    const enableLatencyLogs = options.enableLatencyLogs === true;
    const latencyLogEvery = Math.max(
      5,
      Number(options.latencyLogEvery || 20) || 20,
    );
    const latencyWindowSize = Math.max(
      10,
      Number(options.latencyWindowSize || 120) || 120,
    );
    const mediaTransferEnabled = options.allowMediaTransfer !== false;

    const signalingTransport = signalingFactory({
      url: signalingUrl,
      requireTls: options.requireTls === true,
      maxReconnectAttempts: options.maxReconnectAttempts,
      reconnectBaseDelayMs: options.reconnectBaseDelayMs,
      reconnectMaxDelayMs: options.reconnectMaxDelayMs,
      logger,
    });

    const roomBindings = new Map(); // sessionCode -> { handlers:Set<fn>, unsubscribe:fn }
    const peerLinks = new Map(); // peerClientId -> { pc, channel, open, initiator }
    const pendingP2PRequests = new Map(); // requestId -> { type, resolve, reject, timerId, ... }
    const connectionStateListeners = new Set();
    const localMediaFilesByIdentity = new Map();

    let connectionState = "disconnected";
    let roomCode = "";
    let role = "none";
    let clientId = "";
    let hostClientId = "";
    let explicitDisconnect = false;
    let requestSequence = 1;
    let lastRoomSnapshot = null;
    let lastMeshFallbackCount = 0;
    let localMediaUpdatedAt = 0;
    let localMediaUploadedBy = "";
    let localMediaTotalBytes = 0;
    const latencySamples = [];

    function normalizeSessionCode(input) {
      const normalized = String(input || "")
        .trim()
        .toUpperCase();
      if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(normalized)) {
        return "";
      }
      return normalized;
    }

    function normalizeClientId(input) {
      const value = String(input || "").trim();
      return value || "";
    }

    function normalizeRequestId(input) {
      const value = String(input || "").trim();
      if (!value || value.length > 96) return "";
      if (!/^[A-Za-z0-9:_-]+$/.test(value)) return "";
      return value;
    }

    function toPositiveInt(value, fallback = 0) {
      const parsed = Number(value);
      if (!Number.isFinite(parsed) || parsed < 0) {
        return Math.max(0, Number(fallback) || 0);
      }
      return Math.floor(parsed);
    }

    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeoutFn(resolve, Math.max(0, Number(ms) || 0));
      });
    }

    function emitConnectionState(nextState) {
      if (connectionState === nextState) return;
      connectionState = nextState;
      connectionStateListeners.forEach((listener) => {
        try {
          listener(nextState);
        } catch (_) {}
      });
    }

    function getRoomHandlers(code) {
      const normalizedCode = normalizeSessionCode(code);
      if (!normalizedCode) return null;
      const entry = roomBindings.get(normalizedCode);
      return entry && entry.handlers instanceof Set ? entry.handlers : null;
    }

    function dispatchRoomEvent(sessionCode, eventPayload) {
      const handlers = getRoomHandlers(sessionCode);
      if (!handlers || handlers.size <= 0) return;
      handlers.forEach((handler) => {
        try {
          handler(eventPayload);
        } catch (_) {}
      });
    }

    function clearLatencySamples() {
      latencySamples.length = 0;
    }

    function computePercentile(values, percentile) {
      if (!Array.isArray(values) || values.length <= 0) return 0;
      const sorted = values.slice().sort((a, b) => a - b);
      const p = Math.max(0, Math.min(100, Number(percentile) || 0));
      const index = Math.max(
        0,
        Math.min(sorted.length - 1, Math.ceil((p / 100) * sorted.length) - 1),
      );
      return sorted[index] || 0;
    }

    function recordLatencySample(ms) {
      const value = Number(ms);
      if (!Number.isFinite(value) || value < 0) return;
      latencySamples.push(value);
      if (latencySamples.length > latencyWindowSize) {
        latencySamples.splice(0, latencySamples.length - latencyWindowSize);
      }
      if (!enableLatencyLogs) return;
      if (latencySamples.length % latencyLogEvery !== 0) return;
      const p50 = computePercentile(latencySamples, 50);
      const p95 = computePercentile(latencySamples, 95);
      logger(
        `[SyncWebRTC] control latency p50=${p50.toFixed(1)}ms p95=${p95.toFixed(1)}ms (n=${latencySamples.length})`,
      );
    }

    function emitPeerStateEvent(statePayload, sourceClient = "") {
      const code = normalizeSessionCode(roomCode);
      if (!code || !statePayload || typeof statePayload !== "object") return;
      dispatchRoomEvent(code, {
        type: "session-state-updated",
        sessionCode: code,
        state: statePayload,
        source: "webrtc",
        sourceClientId: normalizeClientId(sourceClient) || normalizeClientId(hostClientId),
      });
    }

    function emitTransportDiagnostic(kind, payload = {}) {
      const code = normalizeSessionCode(roomCode);
      if (!code) return;
      dispatchRoomEvent(code, {
        type: "transport-diagnostic",
        sessionCode: code,
        diagnostic: {
          kind: String(kind || "").trim().toLowerCase(),
          ...payload,
          ts: now(),
        },
        source: "webrtc",
      });
    }

    function hasOpenPeerChannel() {
      for (const entry of peerLinks.values()) {
        if (!entry || !entry.channel) continue;
        if (entry.channel.readyState === "open") return true;
      }
      return false;
    }

    function getOpenPeerChannel(peerId) {
      const entry = peerLinks.get(normalizeClientId(peerId));
      if (!entry || !entry.channel) return null;
      if (entry.channel.readyState !== "open") return null;
      return entry.channel;
    }

    function getOpenHostChannel() {
      if (role !== "participant") return null;
      const hostId = normalizeClientId(hostClientId);
      if (!hostId) return null;
      return getOpenPeerChannel(hostId);
    }

    function nextP2PRequestId() {
      requestSequence += 1;
      if (requestSequence > 1e9) requestSequence = 1;
      return `rtc-${now().toString(36)}-${requestSequence.toString(36)}`;
    }

    function clearPendingP2PRequests(reason = "webrtc-not-ready") {
      pendingP2PRequests.forEach((entry, requestId) => {
        pendingP2PRequests.delete(requestId);
        if (entry && entry.timerId) clearTimeoutFn(entry.timerId);
        if (entry && typeof entry.reject === "function") {
          entry.reject(new Error(reason));
        }
      });
    }

    function registerPendingRequest(type, timeoutMs) {
      const requestId = nextP2PRequestId();
      return {
        requestId,
        promise: new Promise((resolve, reject) => {
          const timerId = setTimeoutFn(() => {
            const active = pendingP2PRequests.get(requestId);
            if (!active) return;
            pendingP2PRequests.delete(requestId);
            reject(new Error("webrtc-request-timeout"));
          }, Math.max(1000, Number(timeoutMs || p2pRequestTimeoutMs) || p2pRequestTimeoutMs));

          pendingP2PRequests.set(requestId, {
            type,
            resolve,
            reject,
            timerId,
            startedAt: now(),
            meta: null,
            chunks: null,
            totalChunks: 0,
            receivedChunks: 0,
          });
        }),
      };
    }

    function resolvePendingRequest(requestId, value) {
      const id = String(requestId || "").trim();
      if (!id) return false;
      const entry = pendingP2PRequests.get(id);
      if (!entry) return false;
      pendingP2PRequests.delete(id);
      if (entry.timerId) clearTimeoutFn(entry.timerId);
      if (entry.startedAt) {
        recordLatencySample(Math.max(0, now() - toPositiveInt(entry.startedAt, now())));
      }
      if (typeof entry.resolve === "function") entry.resolve(value);
      return true;
    }

    function rejectPendingRequest(requestId, errorCode) {
      const id = String(requestId || "").trim();
      if (!id) return false;
      const entry = pendingP2PRequests.get(id);
      if (!entry) return false;
      pendingP2PRequests.delete(id);
      if (entry.timerId) clearTimeoutFn(entry.timerId);
      if (typeof entry.reject === "function") {
        entry.reject(new Error(String(errorCode || "webrtc-request-failed")));
      }
      return true;
    }

    function normalizeMediaFilePayload(input) {
      if (!input || typeof input !== "object") {
        throw new Error("invalid-session-media");
      }
      const identity = String(input.identity || "").trim();
      if (!identity || identity.length > 128 || !/^[A-Za-z0-9:_-]+$/.test(identity)) {
        throw new Error("invalid-session-media");
      }

      const ext = String(input.ext || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "")
        .slice(0, 12);
      if (!ext) throw new Error("invalid-session-media");

      const mime = String(input.mime || "").trim().toLowerCase().slice(0, 80);
      const name = String(input.name || "unknown")
        .replace(/[\u0000-\u001f\u007f]/g, "")
        .trim()
        .slice(0, 160) || "unknown";
      const size = toPositiveInt(input.size, 0);
      const sha256 = String(input.sha256 || "").trim().toLowerCase();
      const dataBase64 = String(input.dataBase64 || "")
        .replace(/\s+/g, "")
        .trim();
      if (!dataBase64 || !/^[A-Za-z0-9+/=]+$/.test(dataBase64)) {
        throw new Error("invalid-session-media");
      }
      if (size <= 0) throw new Error("invalid-session-media");

      return { identity, name, ext, mime, size, sha256, dataBase64 };
    }

    function buildLocalMediaManifest() {
      const files = Array.from(localMediaFilesByIdentity.values()).map((entry) => ({
        identity: String(entry.identity || "").trim(),
        name: String(entry.name || "unknown").trim() || "unknown",
        ext: String(entry.ext || "").trim().toLowerCase(),
        mime: String(entry.mime || "").trim().toLowerCase(),
        size: toPositiveInt(entry.size, 0),
        sha256: String(entry.sha256 || "").trim().toLowerCase(),
        updatedAt: toPositiveInt(entry.updatedAt, 0),
      }));

      return {
        files,
        filesCount: files.length,
        totalBytes: toPositiveInt(localMediaTotalBytes, 0),
        updatedAt: toPositiveInt(localMediaUpdatedAt, 0),
        uploadedBy: String(localMediaUploadedBy || "").trim(),
      };
    }

    function storeLocalMediaFile(filePayload) {
      const safe = normalizeMediaFilePayload(filePayload);
      const previous = localMediaFilesByIdentity.get(safe.identity);
      const previousSize = previous ? toPositiveInt(previous.size, 0) : 0;
      localMediaFilesByIdentity.set(safe.identity, {
        ...safe,
        updatedAt: now(),
      });
      localMediaTotalBytes =
        Math.max(0, toPositiveInt(localMediaTotalBytes, 0) - previousSize) + safe.size;
      localMediaUpdatedAt = now();
      localMediaUploadedBy = String(clientId || localMediaUploadedBy || "").trim();
      return safe;
    }

    function clearLocalMediaFiles() {
      localMediaFilesByIdentity.clear();
      localMediaTotalBytes = 0;
      localMediaUpdatedAt = now();
      localMediaUploadedBy = String(clientId || "").trim();
    }

    function sanitizePeerManifest(input) {
      if (!input || typeof input !== "object") {
        return {
          files: [],
          filesCount: 0,
          totalBytes: 0,
          updatedAt: 0,
          uploadedBy: "",
        };
      }

      const files = Array.isArray(input.files)
        ? input.files
            .map((entry) => {
              if (!entry || typeof entry !== "object") return null;
              const identity = String(entry.identity || "").trim();
              if (!identity || identity.length > 128) return null;
              return {
                identity,
                name:
                  String(entry.name || "unknown")
                    .replace(/[\u0000-\u001f\u007f]/g, "")
                    .trim()
                    .slice(0, 160) || "unknown",
                ext: String(entry.ext || "").trim().toLowerCase().slice(0, 12),
                mime: String(entry.mime || "").trim().toLowerCase().slice(0, 80),
                size: toPositiveInt(entry.size, 0),
                sha256: String(entry.sha256 || "").trim().toLowerCase().slice(0, 128),
                updatedAt: toPositiveInt(entry.updatedAt, 0),
              };
            })
            .filter((entry) => !!entry)
        : [];

      const filesCount = toPositiveInt(input.filesCount, files.length);
      const totalBytes = toPositiveInt(
        input.totalBytes,
        files.reduce((sum, entry) => sum + toPositiveInt(entry.size, 0), 0),
      );
      return {
        files,
        filesCount,
        totalBytes,
        updatedAt: toPositiveInt(input.updatedAt, 0),
        uploadedBy: String(input.uploadedBy || "").trim().slice(0, 64),
      };
    }

    function sanitizePeerFileMeta(input, fallbackIdentity = "") {
      const meta = input && typeof input === "object" ? input : {};
      const identity = String(meta.identity || fallbackIdentity || "").trim();
      if (!identity || identity.length > 128) {
        throw new Error("invalid-session-media");
      }
      return {
        identity,
        name:
          String(meta.name || "unknown")
            .replace(/[\u0000-\u001f\u007f]/g, "")
            .trim()
            .slice(0, 160) || "unknown",
        ext: String(meta.ext || "").trim().toLowerCase().slice(0, 12),
        mime: String(meta.mime || "").trim().toLowerCase().slice(0, 80),
        size: toPositiveInt(meta.size, 0),
        sha256: String(meta.sha256 || "").trim().toLowerCase().slice(0, 128),
      };
    }

    function sendDataMessage(channel, payload) {
      if (!channel || channel.readyState !== "open") {
        throw new Error("webrtc-not-ready");
      }
      channel.send(JSON.stringify(payload));
    }

    async function requestMediaManifestFromHost() {
      const hostChannel = getOpenHostChannel();
      if (!hostChannel) {
        throw new Error("webrtc-not-ready");
      }
      const pending = registerPendingRequest("p2p-media-manifest");
      sendDataMessage(hostChannel, {
        kind: "p2p-media-manifest-request",
        requestId: pending.requestId,
        sessionCode: roomCode,
        sourceClientId: clientId,
        ts: now(),
      });
      return pending.promise;
    }

    async function requestMediaFileFromHost(identity) {
      const hostChannel = getOpenHostChannel();
      if (!hostChannel) {
        throw new Error("webrtc-not-ready");
      }
      const normalizedIdentity = String(identity || "").trim();
      if (!normalizedIdentity) {
        throw new Error("invalid-session-media");
      }
      const pending = registerPendingRequest("p2p-media-file");
      sendDataMessage(hostChannel, {
        kind: "p2p-media-file-request",
        requestId: pending.requestId,
        sessionCode: roomCode,
        sourceClientId: clientId,
        identity: normalizedIdentity,
        ts: now(),
      });
      return pending.promise;
    }

    async function sendMediaFileResponseToPeer(channel, requestId, filePayload) {
      const safe = normalizeMediaFilePayload(filePayload);
      const dataBase64 = String(safe.dataBase64 || "").trim();
      const totalChunks = Math.max(
        1,
        Math.ceil(dataBase64.length / mediaChunkBase64Size),
      );

      sendDataMessage(channel, {
        kind: "p2p-media-file-begin",
        requestId,
        file: {
          identity: safe.identity,
          name: safe.name,
          ext: safe.ext,
          mime: safe.mime,
          size: safe.size,
          sha256: safe.sha256,
          totalChunks,
        },
      });

      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex += 1) {
        if (!channel || channel.readyState !== "open") {
          throw new Error("webrtc-not-ready");
        }
        const offset = chunkIndex * mediaChunkBase64Size;
        const chunk = dataBase64.slice(offset, offset + mediaChunkBase64Size);
        sendDataMessage(channel, {
          kind: "p2p-media-file-chunk",
          requestId,
          chunkIndex,
          totalChunks,
          dataBase64: chunk,
        });

        if (
          typeof channel.bufferedAmount === "number" &&
          channel.bufferedAmount > maxBufferedAmountBeforeYield
        ) {
          await sleep(sendYieldDelayMs);
        }
      }

      sendDataMessage(channel, {
        kind: "p2p-media-file-end",
        requestId,
      });
    }

    async function handleHostPeerDataMessage(peerId, payload) {
      if (!payload || typeof payload !== "object") return;
      const kind = String(payload.kind || "").trim().toLowerCase();
      const requestId = normalizeRequestId(payload.requestId);
      if (!requestId) return;
      const channel = getOpenPeerChannel(peerId);
      if (!channel) return;

      if (kind === "p2p-media-manifest-request") {
        const manifest = buildLocalMediaManifest();
        if (!manifest.filesCount) {
          sendDataMessage(channel, {
            kind: "p2p-media-manifest-response",
            requestId,
            ok: false,
            errorCode: "webrtc-media-unavailable",
          });
          return;
        }
        sendDataMessage(channel, {
          kind: "p2p-media-manifest-response",
          requestId,
          ok: true,
          manifest,
        });
        return;
      }

      if (kind === "p2p-media-file-request") {
        const identity = String(payload.identity || "").trim();
        if (!identity) {
          sendDataMessage(channel, {
            kind: "p2p-media-file-error",
            requestId,
            errorCode: "invalid-session-media",
          });
          return;
        }
        const fileEntry = localMediaFilesByIdentity.get(identity);
        if (!fileEntry) {
          sendDataMessage(channel, {
            kind: "p2p-media-file-error",
            requestId,
            errorCode: "session-media-not-found",
          });
          return;
        }
        try {
          await sendMediaFileResponseToPeer(channel, requestId, fileEntry);
        } catch (error) {
          sendDataMessage(channel, {
            kind: "p2p-media-file-error",
            requestId,
            errorCode: error?.message || "webrtc-file-transfer-failed",
          });
        }
      }
    }

    function handleParticipantPeerDataMessage(payload) {
      if (!payload || typeof payload !== "object") return;
      const kind = String(payload.kind || "").trim().toLowerCase();
      const requestId = normalizeRequestId(payload.requestId);
      if (!requestId) return;

      if (kind === "p2p-media-manifest-response") {
        if (payload.ok === true) {
          resolvePendingRequest(requestId, sanitizePeerManifest(payload.manifest));
        } else {
          rejectPendingRequest(
            requestId,
            payload.errorCode || "webrtc-media-unavailable",
          );
        }
        return;
      }

      if (kind === "p2p-media-file-error") {
        rejectPendingRequest(
          requestId,
          payload.errorCode || "webrtc-file-transfer-failed",
        );
        return;
      }

      const pending = pendingP2PRequests.get(requestId);
      if (!pending || pending.type !== "p2p-media-file") return;

      if (kind === "p2p-media-file-begin") {
        try {
          const meta = sanitizePeerFileMeta(
            payload.file,
            String(payload?.file?.identity || ""),
          );
          const totalChunks = Math.max(
            1,
            toPositiveInt(payload?.file?.totalChunks, 1),
          );
          pending.meta = { ...meta };
          pending.totalChunks = totalChunks;
          pending.chunks = new Array(totalChunks);
          pending.receivedChunks = 0;
        } catch (_) {
          rejectPendingRequest(requestId, "invalid-session-media");
        }
        return;
      }

      if (kind === "p2p-media-file-chunk") {
        if (!Array.isArray(pending.chunks) || !pending.meta) return;
        const rawChunkIndex = Number(payload.chunkIndex);
        const chunkIndex = Number.isFinite(rawChunkIndex)
          ? Math.floor(rawChunkIndex)
          : -1;
        if (chunkIndex < 0 || chunkIndex >= pending.totalChunks) return;
        const dataBase64 = String(payload.dataBase64 || "")
          .replace(/\s+/g, "")
          .trim();
        if (!dataBase64 || !/^[A-Za-z0-9+/=]+$/.test(dataBase64)) return;
        if (pending.chunks[chunkIndex]) return;
        pending.chunks[chunkIndex] = dataBase64;
        pending.receivedChunks += 1;
        return;
      }

      if (kind === "p2p-media-file-end") {
        if (!Array.isArray(pending.chunks) || !pending.meta) {
          rejectPendingRequest(requestId, "webrtc-file-transfer-failed");
          return;
        }
        if (pending.receivedChunks !== pending.totalChunks) {
          rejectPendingRequest(requestId, "webrtc-file-transfer-incomplete");
          return;
        }
        resolvePendingRequest(requestId, {
          file: {
            ...pending.meta,
            dataBase64: pending.chunks.join(""),
            updatedAt: now(),
          },
        });
      }
    }

    function handlePeerDataMessage(peerId, payload) {
      if (!payload || typeof payload !== "object") return;
      const kind = String(payload.kind || "").trim().toLowerCase();
      if (kind === "session-state-updated") {
        if (role !== "participant") return;
        const sourceClient = normalizeClientId(payload.sourceClientId || peerId);
        if (hostClientId && sourceClient && sourceClient !== hostClientId) {
          return;
        }
        const ts = toPositiveInt(payload.ts, 0);
        if (ts > 0) {
          recordLatencySample(Math.max(0, now() - ts));
        }
        emitPeerStateEvent(
          payload.state || null,
          sourceClient,
        );
        return;
      }

      if (role === "host") {
        void handleHostPeerDataMessage(peerId, payload).catch((error) => {
          logger("[SyncWebRTC] host data channel handling failed", error);
        });
        return;
      }

      if (role === "participant") {
        handleParticipantPeerDataMessage(payload);
      }
    }

    function closePeer(peerClientId) {
      const peerId = normalizeClientId(peerClientId);
      if (!peerId) return;
      const entry = peerLinks.get(peerId);
      if (!entry) return;
      peerLinks.delete(peerId);
      try {
        if (entry.channel) {
          entry.channel.onopen = null;
          entry.channel.onclose = null;
          entry.channel.onmessage = null;
          entry.channel.onerror = null;
          entry.channel.close();
        }
      } catch (_) {}
      try {
        if (entry.pc) {
          entry.pc.onicecandidate = null;
          entry.pc.ondatachannel = null;
          entry.pc.onconnectionstatechange = null;
          entry.pc.close();
        }
      } catch (_) {}
      if (role === "participant" && peerId === hostClientId) {
        clearPendingP2PRequests("webrtc-not-ready");
      }
    }

    function closeAllPeers() {
      Array.from(peerLinks.keys()).forEach((peerId) => closePeer(peerId));
    }

    function toSessionDescription(value) {
      if (!value || typeof value !== "object") return null;
      const normalized = {
        type: String(value.type || "").trim(),
        sdp: String(value.sdp || "").trim(),
      };
      if (!normalized.type || !normalized.sdp) return null;
      if (RTCSessionDescriptionCtor) {
        return new RTCSessionDescriptionCtor(normalized);
      }
      return normalized;
    }

    function toIceCandidate(value) {
      if (!value || typeof value !== "object") return null;
      const candidate = {
        candidate: String(value.candidate || "").trim(),
        sdpMid:
          value.sdpMid === undefined || value.sdpMid === null
            ? null
            : String(value.sdpMid),
        sdpMLineIndex:
          value.sdpMLineIndex === undefined || value.sdpMLineIndex === null
            ? null
            : Number(value.sdpMLineIndex),
      };
      if (!candidate.candidate) return null;
      if (RTCIceCandidateCtor) {
        return new RTCIceCandidateCtor(candidate);
      }
      return candidate;
    }

    async function sendRtcSignal(targetClientId, signalType, signalPayload) {
      if (
        !signalingTransport ||
        typeof signalingTransport.sendRtcSignal !== "function"
      ) {
        throw new Error("webrtc-signaling-unavailable");
      }
      return signalingTransport.sendRtcSignal({
        sessionCode: roomCode,
        sourceClientId: clientId,
        targetClientId: normalizeClientId(targetClientId),
        signalType: String(signalType || "").trim().toLowerCase(),
        signalPayload:
          signalPayload === undefined || signalPayload === null
            ? null
            : signalPayload,
      });
    }

    function attachDataChannel(peerId, channel) {
      const entry = peerLinks.get(peerId);
      if (!entry || !channel) return;
      entry.channel = channel;
      entry.open = channel.readyState === "open";

      channel.onopen = () => {
        entry.open = true;
        emitConnectionState("connected");
        emitTransportDiagnostic("relay-fallback", {
          active: false,
          reason: "",
          relayParticipantsCount: 0,
        });
      };

      channel.onclose = () => {
        entry.open = false;
      };

      channel.onerror = (event) => {
        logger("[SyncWebRTC] data channel error", event);
      };

      channel.onmessage = (event) => {
        try {
          const payload = JSON.parse(String(event?.data || ""));
          if (!payload || typeof payload !== "object") return;
          handlePeerDataMessage(peerId, payload);
        } catch (_) {}
      };
    }

    async function createOfferForPeer(peerId) {
      const entry = peerLinks.get(peerId);
      if (!entry || !entry.pc) return;
      try {
        const offer = await entry.pc.createOffer();
        await entry.pc.setLocalDescription(offer);
        await sendRtcSignal(peerId, "offer", {
          type: offer.type,
          sdp: offer.sdp,
        });
      } catch (error) {
        logger("[SyncWebRTC] create offer failed", error);
      }
    }

    function ensurePeer(peerClientId, initiator = false) {
      const peerId = normalizeClientId(peerClientId);
      if (!peerId || peerId === clientId) return null;
      const existing = peerLinks.get(peerId);
      if (existing) return existing;

      const pc = new RTCPeerConnectionCtor(rtcConfiguration);
      const entry = {
        peerId,
        pc,
        channel: null,
        open: false,
        initiator: initiator === true,
      };
      peerLinks.set(peerId, entry);

      pc.onicecandidate = (event) => {
        if (!event || !event.candidate) return;
        const candidatePayload =
          typeof event.candidate.toJSON === "function"
            ? event.candidate.toJSON()
            : {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
              };
        void sendRtcSignal(peerId, "ice-candidate", candidatePayload).catch(
          (error) => {
            logger("[SyncWebRTC] send candidate failed", error);
          },
        );
      };

      pc.onconnectionstatechange = () => {
        const state = String(pc.connectionState || "").trim().toLowerCase();
        if (state === "failed" || state === "disconnected") {
          emitConnectionState("reconnecting");
          emitTransportDiagnostic("relay-fallback", {
            active: true,
            reason: "peer-failed",
            relayParticipantsCount:
              role === "host" ? Math.max(0, Number(lastMeshFallbackCount || 0) || 0) : 1,
          });
          closePeer(peerId);
          if (role === "host") {
            void ensurePeer(peerId, true);
          } else if (role === "participant" && peerId === hostClientId) {
            void sendRtcSignal(peerId, "peer-reset", {}).catch(() => {});
          }
        }
      };

      pc.ondatachannel = (event) => {
        attachDataChannel(peerId, event?.channel || null);
      };

      if (entry.initiator) {
        const channel = pc.createDataChannel("posechrono-sync-control", {
          ordered: true,
        });
        attachDataChannel(peerId, channel);
        void createOfferForPeer(peerId);
      }

      return entry;
    }

    async function handleRtcSignal(eventPayload) {
      const targetClientId = normalizeClientId(eventPayload?.targetClientId);
      if (targetClientId && targetClientId !== clientId) return;

      const sourceClientId = normalizeClientId(eventPayload?.sourceClientId);
      if (!sourceClientId || sourceClientId === clientId) return;

      const signalType = String(eventPayload?.signalType || "")
        .trim()
        .toLowerCase();
      const signalPayload =
        eventPayload?.signalPayload && typeof eventPayload.signalPayload === "object"
          ? eventPayload.signalPayload
          : null;

      if (!signalType) return;

      if (signalType === "peer-reset") {
        closePeer(sourceClientId);
        if (role === "host") {
          ensurePeer(sourceClientId, true);
        }
        return;
      }

      if (signalType === "offer") {
        if (role === "host") return;
        const entry = ensurePeer(sourceClientId, false);
        if (!entry || !entry.pc) return;
        const remote = toSessionDescription(signalPayload);
        if (!remote) return;
        await entry.pc.setRemoteDescription(remote);
        const answer = await entry.pc.createAnswer();
        await entry.pc.setLocalDescription(answer);
        await sendRtcSignal(sourceClientId, "answer", {
          type: answer.type,
          sdp: answer.sdp,
        });
        return;
      }

      if (signalType === "answer") {
        const entry = peerLinks.get(sourceClientId);
        if (!entry || !entry.pc) return;
        const remote = toSessionDescription(signalPayload);
        if (!remote) return;
        await entry.pc.setRemoteDescription(remote);
        return;
      }

      if (signalType === "ice-candidate") {
        const entry = ensurePeer(
          sourceClientId,
          role === "host",
        );
        if (!entry || !entry.pc) return;
        const candidate = toIceCandidate(signalPayload);
        if (!candidate) return;
        try {
          await entry.pc.addIceCandidate(candidate);
        } catch (_) {}
      }
    }

    function syncPeersFromSnapshot(snapshot) {
      if (!snapshot || typeof snapshot !== "object") return;
      const participantIds = Array.isArray(snapshot.participantIds)
        ? snapshot.participantIds
            .map((id) => normalizeClientId(id))
            .filter((id) => !!id)
        : [];
      const nextHostId = normalizeClientId(snapshot.hostClientId || hostClientId);
      if (nextHostId) {
        hostClientId = nextHostId;
      }

      if (role === "host") {
        const desiredOrdered = participantIds.filter(
          (id) => id && id !== hostClientId,
        );
        const limitedDesired = new Set(desiredOrdered.slice(0, maxMeshPeers));
        const skippedPeers = desiredOrdered.slice(maxMeshPeers);
        const skippedCount = skippedPeers.length;
        if (skippedPeers.length > 0) {
          logger(
            `[SyncWebRTC] mesh peer limit reached (${maxMeshPeers}), fallback relay for: ${skippedPeers.join(", ")}`,
          );
        }
        if (skippedCount !== lastMeshFallbackCount) {
          lastMeshFallbackCount = skippedCount;
          emitTransportDiagnostic("relay-fallback", {
            active: skippedCount > 0,
            reason: skippedCount > 0 ? "mesh-limit" : "",
            meshLimit: maxMeshPeers,
            relayParticipantsCount: skippedCount,
            relayParticipantIds: skippedPeers,
          });
        }
        Array.from(peerLinks.keys()).forEach((peerId) => {
          if (!limitedDesired.has(peerId)) {
            closePeer(peerId);
          }
        });
        limitedDesired.forEach((peerId) => {
          if (!peerLinks.has(peerId)) {
            ensurePeer(peerId, true);
          }
        });
        return;
      }

      if (role === "participant") {
        const targetHostId = hostClientId && hostClientId !== clientId
          ? hostClientId
          : "";
        Array.from(peerLinks.keys()).forEach((peerId) => {
          if (!targetHostId || peerId !== targetHostId) {
            closePeer(peerId);
          }
        });
        if (targetHostId && !peerLinks.has(targetHostId)) {
          ensurePeer(targetHostId, false);
        }
      }
    }

    function bindRoomContext(snapshot, nextRole, requestPayload = {}) {
      role = nextRole === "host" ? "host" : "participant";
      roomCode = normalizeSessionCode(snapshot?.sessionCode || roomCode);
      hostClientId = normalizeClientId(snapshot?.hostClientId || hostClientId);
      lastRoomSnapshot =
        snapshot && typeof snapshot === "object" ? { ...snapshot } : null;
      if (role === "host") {
        clientId = normalizeClientId(requestPayload.hostClientId || hostClientId);
      } else {
        clientId = normalizeClientId(requestPayload.clientId || clientId);
      }
      syncPeersFromSnapshot(snapshot);
    }

    function clearRoomContext() {
      roomCode = "";
      role = "none";
      hostClientId = "";
      lastRoomSnapshot = null;
      lastMeshFallbackCount = 0;
      closeAllPeers();
      clearPendingP2PRequests("webrtc-not-ready");
      clearLatencySamples();
    }

    function onSignalingEvent(sessionCode, eventPayload) {
      if (!eventPayload || typeof eventPayload !== "object") return;
      const code = normalizeSessionCode(sessionCode);
      if (!code) return;

      if (eventPayload.type === "rtc-signal") {
        void handleRtcSignal(eventPayload).catch((error) => {
          logger("[SyncWebRTC] rtc signal handling failed", error);
        });
        return;
      }

      if (eventPayload.type === "room-updated" && eventPayload.snapshot) {
        if (code === roomCode) {
          lastRoomSnapshot = { ...eventPayload.snapshot };
          syncPeersFromSnapshot(eventPayload.snapshot);
        }
      }

      dispatchRoomEvent(code, eventPayload);
    }

    function subscribe(sessionCode, handler) {
      if (typeof handler !== "function") return () => {};
      const code = normalizeSessionCode(sessionCode);
      if (!code) return () => {};

      if (!roomBindings.has(code)) {
        const handlers = new Set();
        const unsubscribe = signalingTransport.subscribe(
          code,
          (eventPayload) => onSignalingEvent(code, eventPayload),
        );
        roomBindings.set(code, {
          handlers,
          unsubscribe:
            typeof unsubscribe === "function" ? unsubscribe : () => {},
        });
      }

      const entry = roomBindings.get(code);
      entry.handlers.add(handler);

      return () => {
        const active = roomBindings.get(code);
        if (!active) return;
        active.handlers.delete(handler);
        if (active.handlers.size <= 0) {
          try {
            active.unsubscribe();
          } catch (_) {}
          roomBindings.delete(code);
        }
      };
    }

    function broadcastStateToPeers(statePayload) {
      const payload = JSON.stringify({
        kind: "session-state-updated",
        sessionCode: roomCode,
        sourceClientId: clientId,
        state: statePayload,
        ts: now(),
      });

      let sent = 0;
      peerLinks.forEach((entry) => {
        if (!entry || !entry.channel) return;
        if (entry.channel.readyState !== "open") return;
        try {
          entry.channel.send(payload);
          sent += 1;
        } catch (_) {}
      });
      return sent;
    }

    if (
      signalingTransport &&
      typeof signalingTransport.onConnectionStateChange === "function"
    ) {
      signalingTransport.onConnectionStateChange((nextState) => {
        const normalized = String(nextState || "disconnected")
          .trim()
          .toLowerCase();
        if (!normalized) return;
        if (explicitDisconnect && normalized !== "disconnected") return;
        if (normalized === "connected" && hasOpenPeerChannel()) {
          emitConnectionState("connected");
          return;
        }
        emitConnectionState(normalized);
      });
    }

    function onConnectionStateChange(listener) {
      if (typeof listener !== "function") return () => {};
      connectionStateListeners.add(listener);
      return () => {
        connectionStateListeners.delete(listener);
      };
    }

    async function createRoom(payload) {
      explicitDisconnect = false;
      clearPendingP2PRequests("webrtc-not-ready");
      clearLocalMediaFiles();
      const snapshot = await signalingTransport.createRoom(payload || {});
      bindRoomContext(snapshot, "host", payload || {});
      return snapshot;
    }

    async function joinRoom(payload) {
      explicitDisconnect = false;
      clearPendingP2PRequests("webrtc-not-ready");
      const snapshot = await signalingTransport.joinRoom(payload || {});
      bindRoomContext(snapshot, "participant", payload || {});
      return snapshot;
    }

    async function leaveRoom(payload) {
      try {
        return await signalingTransport.leaveRoom(payload || {});
      } finally {
        const normalizedPayloadCode = normalizeSessionCode(payload?.sessionCode);
        const normalizedPayloadClientId = normalizeClientId(payload?.clientId);
        if (
          normalizedPayloadCode &&
          normalizedPayloadCode === roomCode &&
          normalizedPayloadClientId &&
          normalizedPayloadClientId === clientId
        ) {
          clearRoomContext();
          clearLocalMediaFiles();
        }
      }
    }

    function disconnect() {
      explicitDisconnect = true;
      clearRoomContext();
      clearLocalMediaFiles();
      roomBindings.forEach((entry) => {
        try {
          entry.unsubscribe();
        } catch (_) {}
      });
      roomBindings.clear();
      if (
        signalingTransport &&
        typeof signalingTransport.disconnect === "function"
      ) {
        signalingTransport.disconnect();
      }
      emitConnectionState("disconnected");
    }

    return {
      createRoom,
      joinRoom,
      leaveRoom,
      async updateRoom(payload) {
        const snapshot = await signalingTransport.updateRoom(payload || {});
        if (snapshot && typeof snapshot === "object") {
          lastRoomSnapshot = { ...snapshot };
          if (normalizeSessionCode(snapshot.sessionCode) === roomCode) {
            syncPeersFromSnapshot(snapshot);
          }
        }
        return snapshot;
      },
      async updateSessionState(payload) {
        const result = await signalingTransport.updateSessionState(payload || {});
        const sourceClientId = normalizeClientId(payload?.sourceClientId);
        if (
          role === "host" &&
          sourceClientId &&
          sourceClientId === hostClientId
        ) {
          broadcastStateToPeers(result);
        }
        return result;
      },
      updateParticipantState(payload) {
        return signalingTransport.updateParticipantState(payload || {});
      },
      uploadSessionPack(payload) {
        return signalingTransport.uploadSessionPack(payload || {});
      },
      getSessionPack(payload) {
        return signalingTransport.getSessionPack(payload || {});
      },
      resetSessionMediaPack(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        if (role === "host") {
          clearLocalMediaFiles();
        }
        return signalingTransport.resetSessionMediaPack(payload || {});
      },
      uploadSessionMediaFile(payload) {
        if (!mediaTransferEnabled) {
          return Promise.reject(new Error("media-transfer-disabled"));
        }
        const safePayload = payload || {};
        if (role === "host" && safePayload.file && typeof safePayload.file === "object") {
          try {
            storeLocalMediaFile(safePayload.file);
          } catch (error) {
            logger("[SyncWebRTC] local media mirror failed", error);
          }
        }
        if (mirrorMediaToRelay === false) {
          logger("[SyncWebRTC] mirrorMediaToRelay=false ignored in current build (relay metadata required)");
        }
        return signalingTransport.uploadSessionMediaFile(safePayload);
      },
      async getSessionMediaManifest(payload) {
        if (!mediaTransferEnabled) {
          throw new Error("media-transfer-disabled");
        }
        const safePayload = payload || {};
        if (role === "participant" && getOpenHostChannel()) {
          try {
            return await requestMediaManifestFromHost();
          } catch (error) {
            logger("[SyncWebRTC] P2P media manifest failed, fallback relay", error);
          }
        }
        return signalingTransport.getSessionMediaManifest(safePayload);
      },
      async getSessionMediaFile(payload) {
        if (!mediaTransferEnabled) {
          throw new Error("media-transfer-disabled");
        }
        const safePayload = payload || {};
        if (role === "participant" && getOpenHostChannel()) {
          try {
            return await requestMediaFileFromHost(safePayload.identity);
          } catch (error) {
            logger("[SyncWebRTC] P2P media file failed, fallback relay", error);
          }
        }
        return signalingTransport.getSessionMediaFile(safePayload);
      },
      sendRtcSignal(payload) {
        return sendRtcSignal(
          payload?.targetClientId,
          payload?.signalType,
          payload?.signalPayload,
        );
      },
      async getRoomSnapshot(sessionCode) {
        const snapshot = await signalingTransport.getRoomSnapshot(sessionCode);
        if (snapshot && typeof snapshot === "object") {
          lastRoomSnapshot = { ...snapshot };
          if (normalizeSessionCode(snapshot.sessionCode) === roomCode) {
            syncPeersFromSnapshot(snapshot);
          }
        }
        return snapshot;
      },
      subscribe,
      disconnect,
      onConnectionStateChange,
      getConnectionState() {
        return connectionState;
      },
    };
  }

  sharedRoot.createSyncTransportWebRTC = createSyncTransportWebRTC;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sync-session-core.js ===== */
(function initPoseChronoSharedSyncSessionCore(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSyncSessionService(options = {}) {
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();
    const random =
      typeof options.random === "function"
        ? options.random
        : () => Math.random();
    const logger =
      typeof options.logger === "function" ? options.logger : () => {};
    const transport =
      options.transport ||
      (typeof sharedRoot.createSyncTransportMock === "function"
        ? sharedRoot.createSyncTransportMock()
        : null);

    const listeners = new Set();
    const clientId = String(
      options.clientId ||
        `client-${Math.floor(now()).toString(36)}-${Math.floor(random() * 1e8).toString(36)}`,
    );

    let roomUnsubscribe = null;
    let roomCode = "";
    let role = "none";
    let sessionPassword = "";
    let participantName = "";

    const state = {
      status: "idle",
      role: "none",
      sessionCode: "",
      sessionName: "",
      hostClientId: "",
      controlMode: "host-only",
      participantsCount: 0,
      participantIds: [],
      participantProfiles: {},
      participantSyncStates: {},
      sessionPackMeta: null,
      sessionMediaMeta: null,
      sharedSessionState: null,
      sharedSessionStateRevision: 0,
      p2pFallbackActive: false,
      p2pFallbackReason: "",
      p2pMeshLimit: 0,
      p2pRelayParticipantsCount: 0,
      p2pRelayParticipantIds: [],
      clientId,
      lastError: "",
      updatedAt: now(),
    };

    function cloneState() {
      return { ...state };
    }

    function emitState() {
      const snapshot = cloneState();
      listeners.forEach((listener) => {
        try {
          listener(snapshot);
        } catch (_) {}
      });
    }

    function patchState(patch) {
      if (!patch || typeof patch !== "object") return;
      Object.assign(state, patch);
      state.updatedAt = now();
      emitState();
    }

    function normalizeControlMode(input) {
      return String(input || "").trim() === "shared-pause"
        ? "shared-pause"
        : "host-only";
    }

    function normalizeCode(input) {
      const normalized = String(input || "")
        .trim()
        .toUpperCase();
      if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(normalized)) {
        return "";
      }
      return normalized;
    }

    function normalizeSessionName(input) {
      const value = String(input || "").trim();
      return value || "PoseChrono Session";
    }

    function normalizeParticipantProfiles(input) {
      if (!input || typeof input !== "object") return {};
      const out = {};
      Object.keys(input).forEach((clientIdKey) => {
        const clientIdValue = String(clientIdKey || "").trim();
        if (!clientIdValue) return;
        const nameValue = String(input[clientIdKey] || "")
          .replace(/[\u0000-\u001f\u007f]/g, "")
          .trim()
          .slice(0, 32);
        out[clientIdValue] = nameValue;
      });
      return out;
    }

    function normalizeParticipantSyncState(input) {
      const value = String(input || "").trim().toLowerCase();
      if (
        value === "ready" ||
        value === "missing" ||
        value === "connecting" ||
        value === "downloading"
      ) {
        return value;
      }
      return "missing";
    }

    function normalizeParticipantSyncStates(input) {
      if (!input || typeof input !== "object") return {};
      const out = {};
      Object.keys(input).forEach((clientIdKey) => {
        const clientIdValue = String(clientIdKey || "").trim();
        if (!clientIdValue) return;
        out[clientIdValue] = normalizeParticipantSyncState(input[clientIdKey]);
      });
      return out;
    }

    function normalizeSharedSessionStatePayload(input, fallbackRevision = 0) {
      if (!input || typeof input !== "object") {
        return { payload: null, revision: Math.max(0, Number(fallbackRevision) || 0) };
      }

      const clone = {};
      Object.keys(input).forEach((key) => {
        if (!key) return;
        const value = input[key];
        if (value === undefined) return;
        if (typeof value === "function") return;
        clone[key] = value;
      });

      const inferredRevision = Math.max(
        Number(clone.revision || fallbackRevision || 0) || 0,
        0,
      );
      if (!clone.revision) {
        clone.revision = inferredRevision;
      }
      return {
        payload: clone,
        revision: inferredRevision,
      };
    }

    function normalizeSessionPackMeta(input) {
      if (!input || typeof input !== "object") return null;
      const hash = String(input.hash || "").trim();
      const uploadedBy = String(input.uploadedBy || "").trim();
      const size = Math.max(0, Number(input.size || 0) || 0);
      const updatedAt = Math.max(0, Number(input.updatedAt || 0) || 0);
      const imagesCount = Math.max(0, Number(input.imagesCount || 0) || 0);
      const mediaRefsCount = Math.max(0, Number(input.mediaRefsCount || 0) || 0);
      return {
        hash,
        uploadedBy,
        size,
        updatedAt,
        imagesCount,
        mediaRefsCount,
      };
    }

    function normalizeSessionMediaMeta(input) {
      if (!input || typeof input !== "object") return null;
      return {
        filesCount: Math.max(0, Number(input.filesCount || 0) || 0),
        totalBytes: Math.max(0, Number(input.totalBytes || 0) || 0),
        updatedAt: Math.max(0, Number(input.updatedAt || 0) || 0),
        uploadedBy: String(input.uploadedBy || "").trim(),
      };
    }

    function normalizeP2pFallbackReason(input) {
      const value = String(input || "").trim().toLowerCase();
      if (value === "mesh-limit" || value === "peer-failed") {
        return value;
      }
      return "";
    }

    function applyTransportDiagnostic(diagnostic) {
      if (!diagnostic || typeof diagnostic !== "object") return;
      const kind = String(diagnostic.kind || "").trim().toLowerCase();
      if (kind !== "relay-fallback") return;

      const active = diagnostic.active === true;
      const reason = active
        ? normalizeP2pFallbackReason(diagnostic.reason)
        : "";
      const meshLimit = Math.max(0, Number(diagnostic.meshLimit || 0) || 0);
      const relayParticipantsCount = Math.max(
        0,
        Number(diagnostic.relayParticipantsCount || 0) || 0,
      );
      const relayParticipantIds = Array.isArray(diagnostic.relayParticipantIds)
        ? diagnostic.relayParticipantIds
            .map((id) => String(id || "").trim())
            .filter((id) => !!id)
        : [];

      patchState({
        p2pFallbackActive: active,
        p2pFallbackReason: reason,
        p2pMeshLimit: meshLimit,
        p2pRelayParticipantsCount: relayParticipantsCount,
        p2pRelayParticipantIds: relayParticipantIds,
      });
    }

    function randomCodePart(length) {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i = 0; i < length; i += 1) {
        out += chars[Math.floor(random() * chars.length)];
      }
      return out;
    }

    function createSessionCode() {
      return `${randomCodePart(4)}-${randomCodePart(4)}`;
    }

    function clearRoomSubscription() {
      if (typeof roomUnsubscribe === "function") {
        try {
          roomUnsubscribe();
        } catch (_) {}
      }
      roomUnsubscribe = null;
    }

    // Transport connection state awareness (reconnection handling)
    if (transport && typeof transport.onConnectionStateChange === "function") {
      transport.onConnectionStateChange((connectionState) => {
        if (connectionState === "reconnecting") {
          if (state.status === "hosting" || state.status === "joined") {
            patchState({ lastError: "websocket-reconnecting" });
          }
          return;
        }

        if (connectionState === "connected") {
          if (!roomCode) return;

          if (role === "host") {
            // Host: re-fetch snapshot to resync
            if (typeof transport.getRoomSnapshot === "function") {
              transport
                .getRoomSnapshot(roomCode)
                .then((snapshot) => {
                  if (snapshot) applyRoomSnapshot(snapshot, "host");
                  patchState({ lastError: "" });
                })
                .catch((err) => {
                  logger("[Sync] host post-reconnect snapshot fetch failed", err);
                });
            }
            return;
          }

          if (role === "participant") {
            // Participant: try snapshot, if not-joined then auto re-join
            const attemptReJoin = () => {
              if (typeof transport.joinRoom !== "function") return;
              transport
                .joinRoom({
                  sessionCode: roomCode,
                  password: sessionPassword,
                  participantName: participantName,
                  clientId,
                })
                .then((snapshot) => {
                  applyRoomSnapshot(snapshot, "participant");
                  patchState({ lastError: "" });
                })
                .catch((joinErr) => {
                  logger("[Sync] post-reconnect re-join failed", joinErr);
                  const joinErrCode = String(joinErr?.message || "");
                  if (
                    joinErrCode === "session-not-found" ||
                    joinErrCode === "session-closed"
                  ) {
                    clearRoomSubscription();
                    roomCode = "";
                    role = "none";
                    sessionPassword = "";
                    participantName = "";
                    patchState({
                      status: "idle",
                      role: "none",
                      sessionCode: "",
                      hostClientId: "",
                      participantsCount: 0,
                      participantIds: [],
                      participantProfiles: {},
                      participantSyncStates: {},
                      sessionPackMeta: null,
                      sessionMediaMeta: null,
                      sharedSessionState: null,
                      sharedSessionStateRevision: 0,
                      p2pFallbackActive: false,
                      p2pFallbackReason: "",
                      p2pMeshLimit: 0,
                      p2pRelayParticipantsCount: 0,
                      p2pRelayParticipantIds: [],
                      lastError: "session-not-found",
                    });
                  }
                });
            };

            if (typeof transport.getRoomSnapshot === "function") {
              transport
                .getRoomSnapshot(roomCode)
                .then((snapshot) => {
                  if (snapshot) applyRoomSnapshot(snapshot, "participant");
                  patchState({ lastError: "" });
                })
                .catch((err) => {
                  const errCode = String(err?.message || "");
                  if (errCode === "not-joined") {
                    attemptReJoin();
                  } else if (errCode === "session-not-found") {
                    clearRoomSubscription();
                    roomCode = "";
                    role = "none";
                    sessionPassword = "";
                    participantName = "";
                    patchState({
                      status: "idle",
                      role: "none",
                      sessionCode: "",
                      hostClientId: "",
                      participantsCount: 0,
                      participantIds: [],
                      participantProfiles: {},
                      participantSyncStates: {},
                      sessionPackMeta: null,
                      sessionMediaMeta: null,
                      sharedSessionState: null,
                      sharedSessionStateRevision: 0,
                      p2pFallbackActive: false,
                      p2pFallbackReason: "",
                      p2pMeshLimit: 0,
                      p2pRelayParticipantsCount: 0,
                      p2pRelayParticipantIds: [],
                      lastError: "session-not-found",
                    });
                  } else {
                    logger("[Sync] participant post-reconnect snapshot failed", err);
                  }
                });
            } else {
              attemptReJoin();
            }
          }
          return;
        }

        if (connectionState === "disconnected") {
          // Transport gave up reconnecting
          if (state.status === "hosting" || state.status === "joined") {
            patchState({ lastError: "websocket-disconnected" });
          }
        }
      });
    }

    function applyRoomSnapshot(snapshot, forceRole = null) {
      if (!snapshot || typeof snapshot !== "object") return;
      const normalizedSharedState = normalizeSharedSessionStatePayload(
        snapshot.sessionState,
        snapshot.sessionStateRevision,
      );
      patchState({
        status:
          forceRole === "host"
            ? "hosting"
            : forceRole === "participant"
              ? "joined"
              : role === "host"
                ? "hosting"
                : "joined",
        role: forceRole || role,
        sessionCode: snapshot.sessionCode || roomCode || "",
        sessionName: snapshot.sessionName || state.sessionName,
        hostClientId: String(snapshot.hostClientId || state.hostClientId || "").trim(),
        controlMode: normalizeControlMode(snapshot.controlMode),
        participantsCount: Math.max(
          0,
          Number(snapshot.participantsCount || 0) || 0,
        ),
        participantIds: Array.isArray(snapshot.participantIds)
          ? snapshot.participantIds
              .map((id) => String(id || "").trim())
              .filter((id) => !!id)
          : [],
        participantProfiles: normalizeParticipantProfiles(snapshot.participantProfiles),
        participantSyncStates: normalizeParticipantSyncStates(
          snapshot.participantSyncStates,
        ),
        sessionPackMeta: normalizeSessionPackMeta(snapshot.sessionPackMeta),
        sessionMediaMeta: normalizeSessionMediaMeta(snapshot.sessionMediaMeta),
        sharedSessionState: normalizedSharedState.payload,
        sharedSessionStateRevision: normalizedSharedState.revision,
        lastError: "",
      });
    }

    function bindRoom(roomSessionCode, roomRole) {
      const code = normalizeCode(roomSessionCode);
      clearRoomSubscription();
      if (!transport || !code || typeof transport.subscribe !== "function") return;

      roomUnsubscribe = transport.subscribe(code, (eventPayload) => {
        if (!eventPayload || typeof eventPayload !== "object") return;

        if (eventPayload.type === "room-updated") {
          applyRoomSnapshot(eventPayload.snapshot, roomRole);
          return;
        }

        if (eventPayload.type === "session-state-updated") {
          const normalizedSharedState = normalizeSharedSessionStatePayload(
            eventPayload.state,
            eventPayload.state?.revision,
          );
          if (
            normalizedSharedState.revision <
            (Number(state.sharedSessionStateRevision || 0) || 0)
          ) {
            return;
          }
          patchState({
            sharedSessionState: normalizedSharedState.payload,
            sharedSessionStateRevision: normalizedSharedState.revision,
            lastError: "",
          });
          return;
        }

        if (eventPayload.type === "transport-diagnostic") {
          applyTransportDiagnostic(eventPayload.diagnostic);
          return;
        }

        if (eventPayload.type === "room-closed") {
          clearRoomSubscription();
          roomCode = "";
          role = "none";
          sessionPassword = "";
          participantName = "";
          const closeSource = String(eventPayload.source || "").trim();
          const errorCode =
            closeSource === "host-left"
              ? "host-disconnected"
              : closeSource === "ttl-expired"
                ? "session-expired"
                : "session-closed";
          patchState({
            status: "idle",
            role: "none",
            sessionCode: "",
            hostClientId: "",
            participantsCount: 0,
            participantIds: [],
            participantProfiles: {},
            participantSyncStates: {},
            sessionPackMeta: null,
            sessionMediaMeta: null,
            sharedSessionState: null,
            sharedSessionStateRevision: 0,
            p2pFallbackActive: false,
            p2pFallbackReason: "",
            p2pMeshLimit: 0,
            p2pRelayParticipantsCount: 0,
            p2pRelayParticipantIds: [],
            lastError: errorCode,
          });
        }
      });
    }

    async function hostSession(input = {}) {
      if (!transport || typeof transport.createRoom !== "function") {
        throw new Error("transport-unavailable");
      }

      const rawRequestedCode = String(input.sessionCode || "").trim();
      const requestedCode = normalizeCode(rawRequestedCode);
      if (rawRequestedCode && !requestedCode) {
        throw new Error("invalid-session-code");
      }
      const sessionCode = requestedCode || createSessionCode();
      const sessionName = normalizeSessionName(input.sessionName);
      const controlMode = normalizeControlMode(input.controlMode);
      const password = String(input.password || "");

      patchState({
        status: "connecting",
        role: "host",
        lastError: "",
      });

      try {
        const snapshot = await transport.createRoom({
          sessionCode,
          sessionName,
          controlMode,
          hostClientId: clientId,
          password,
        });

        role = "host";
        roomCode = sessionCode;
        bindRoom(sessionCode, "host");
        applyRoomSnapshot(snapshot, "host");

        return {
          sessionCode: snapshot.sessionCode,
          snapshot,
        };
      } catch (error) {
        clearRoomSubscription();
        roomCode = "";
        role = "none";
        patchState({
          status: "idle",
          role: "none",
          sessionCode: "",
          hostClientId: "",
          participantsCount: 0,
          participantIds: [],
          participantProfiles: {},
          participantSyncStates: {},
          sessionPackMeta: null,
            sessionMediaMeta: null,
            sharedSessionState: null,
            sharedSessionStateRevision: 0,
            p2pFallbackActive: false,
            p2pFallbackReason: "",
            p2pMeshLimit: 0,
            p2pRelayParticipantsCount: 0,
            p2pRelayParticipantIds: [],
            lastError: String(error?.message || "request-failed"),
          });
        throw error;
      }
    }

    async function joinSession(input = {}) {
      if (!transport || typeof transport.joinRoom !== "function") {
        throw new Error("transport-unavailable");
      }

      const rawSessionCode = String(input.sessionCode || "").trim();
      const sessionCode = normalizeCode(rawSessionCode);
      if (!sessionCode) {
        throw new Error(rawSessionCode ? "invalid-session-code" : "missing-session-code");
      }

      patchState({
        status: "connecting",
        role: "participant",
        lastError: "",
      });

      const joinPassword = String(input.password || "");
      const joinParticipantName = String(input.participantName || "");

      try {
        const snapshot = await transport.joinRoom({
          sessionCode,
          password: joinPassword,
          participantName: joinParticipantName,
          clientId,
        });

        role = "participant";
        roomCode = sessionCode;
        sessionPassword = joinPassword;
        participantName = joinParticipantName;
        bindRoom(sessionCode, "participant");
        applyRoomSnapshot(snapshot, "participant");

        return {
          sessionCode: snapshot.sessionCode,
          snapshot,
        };
      } catch (error) {
        clearRoomSubscription();
        roomCode = "";
        role = "none";
        patchState({
          status: "idle",
          role: "none",
          sessionCode: "",
          hostClientId: "",
          participantsCount: 0,
          participantIds: [],
          participantProfiles: {},
          participantSyncStates: {},
          sessionPackMeta: null,
          sessionMediaMeta: null,
          sharedSessionState: null,
          sharedSessionStateRevision: 0,
          p2pFallbackActive: false,
          p2pFallbackReason: "",
          p2pMeshLimit: 0,
          p2pRelayParticipantsCount: 0,
          p2pRelayParticipantIds: [],
          lastError: String(error?.message || "request-failed"),
        });
        throw error;
      }
    }

    async function leaveSession() {
      if (!roomCode) return { left: false };
      const codeToLeave = roomCode;

      try {
        if (transport && typeof transport.leaveRoom === "function") {
          await transport.leaveRoom({
            sessionCode: codeToLeave,
            clientId,
          });
        }
      } catch (error) {
        logger("[Sync] leaveSession error", error);
      }

      clearRoomSubscription();
      roomCode = "";
      role = "none";
      sessionPassword = "";
      participantName = "";
      patchState({
        status: "idle",
        role: "none",
        sessionCode: "",
        sessionName: "",
        hostClientId: "",
        controlMode: "host-only",
        participantsCount: 0,
        participantIds: [],
        participantProfiles: {},
        participantSyncStates: {},
        sessionPackMeta: null,
        sessionMediaMeta: null,
        sharedSessionState: null,
        sharedSessionStateRevision: 0,
        p2pFallbackActive: false,
        p2pFallbackReason: "",
        p2pMeshLimit: 0,
        p2pRelayParticipantsCount: 0,
        p2pRelayParticipantIds: [],
      });

      return { left: true };
    }

    async function updateSessionMeta(input = {}) {
      if (role !== "host") return false;
      if (!roomCode) return false;
      if (!transport || typeof transport.updateRoom !== "function") return false;

      const patch = {};
      if (typeof input.sessionName === "string") {
        patch.sessionName = normalizeSessionName(input.sessionName);
      }
      if (typeof input.controlMode === "string") {
        patch.controlMode = normalizeControlMode(input.controlMode);
      }

      const snapshot = await transport.updateRoom({
        sessionCode: roomCode,
        sourceClientId: clientId,
        patch,
      });
      applyRoomSnapshot(snapshot, "host");
      return true;
    }

    async function publishSessionState(input = {}) {
      if (role !== "host") return false;
      if (!roomCode) return false;
      if (!transport || typeof transport.updateSessionState !== "function") {
        return false;
      }

      const payload =
        input && typeof input === "object" ? { ...input } : {};
      const statePayload = await transport.updateSessionState({
        sessionCode: roomCode,
        sourceClientId: clientId,
        payload,
      });
      const normalizedSharedState = normalizeSharedSessionStatePayload(
        statePayload,
        statePayload?.revision,
      );
      patchState({
        sharedSessionState: normalizedSharedState.payload,
        sharedSessionStateRevision: normalizedSharedState.revision,
        lastError: "",
      });
      return true;
    }

    async function publishSessionPack(input = {}) {
      if (role !== "host") return false;
      if (!roomCode) return false;
      if (!transport || typeof transport.uploadSessionPack !== "function") {
        return false;
      }
      const payload = input && typeof input === "object" ? { ...input } : {};
      const snapshot = await transport.uploadSessionPack({
        sessionCode: roomCode,
        sourceClientId: clientId,
        pack: payload.pack,
      });
      applyRoomSnapshot(snapshot, "host");
      return state.sessionPackMeta;
    }

    async function fetchSessionPack() {
      if (!roomCode) return null;
      if (!transport || typeof transport.getSessionPack !== "function") {
        return null;
      }
      const result = await transport.getSessionPack({
        sessionCode: roomCode,
        sourceClientId: clientId,
      });
      if (!result || typeof result !== "object") return null;
      return {
        pack: result.pack && typeof result.pack === "object" ? result.pack : null,
        hash: String(result.hash || "").trim(),
        updatedAt: Math.max(0, Number(result.updatedAt || 0) || 0),
        size: Math.max(0, Number(result.size || 0) || 0),
      };
    }

    async function resetSessionMediaPack() {
      if (role !== "host") return false;
      if (!roomCode) return false;
      if (!transport || typeof transport.resetSessionMediaPack !== "function") {
        return false;
      }
      const snapshot = await transport.resetSessionMediaPack({
        sessionCode: roomCode,
        sourceClientId: clientId,
      });
      applyRoomSnapshot(snapshot, "host");
      return true;
    }

    async function publishSessionMediaFile(input = {}) {
      if (role !== "host") return false;
      if (!roomCode) return false;
      if (!transport || typeof transport.uploadSessionMediaFile !== "function") {
        return false;
      }
      const snapshot = await transport.uploadSessionMediaFile({
        sessionCode: roomCode,
        sourceClientId: clientId,
        file: input.file || null,
      });
      applyRoomSnapshot(snapshot, "host");
      return true;
    }

    async function fetchSessionMediaManifest() {
      if (!roomCode) return null;
      if (!transport || typeof transport.getSessionMediaManifest !== "function") {
        return null;
      }
      const result = await transport.getSessionMediaManifest({
        sessionCode: roomCode,
        sourceClientId: clientId,
      });
      if (!result || typeof result !== "object") return null;
      return {
        files: Array.isArray(result.files) ? result.files.slice() : [],
        filesCount: Math.max(0, Number(result.filesCount || 0) || 0),
        totalBytes: Math.max(0, Number(result.totalBytes || 0) || 0),
        updatedAt: Math.max(0, Number(result.updatedAt || 0) || 0),
        uploadedBy: String(result.uploadedBy || "").trim(),
      };
    }

    async function fetchSessionMediaFile(input = {}) {
      if (!roomCode) return null;
      if (!transport || typeof transport.getSessionMediaFile !== "function") {
        return null;
      }
      const result = await transport.getSessionMediaFile({
        sessionCode: roomCode,
        sourceClientId: clientId,
        identity: String(input.identity || "").trim(),
      });
      if (!result || typeof result !== "object") return null;
      const file = result.file && typeof result.file === "object" ? result.file : null;
      if (!file) return null;
      return {
        file: {
          identity: String(file.identity || "").trim(),
          name: String(file.name || "").trim(),
          ext: String(file.ext || "").trim().toLowerCase(),
          mime: String(file.mime || "").trim().toLowerCase(),
          size: Math.max(0, Number(file.size || 0) || 0),
          sha256: String(file.sha256 || "").trim().toLowerCase(),
          dataBase64: String(file.dataBase64 || "").trim(),
          updatedAt: Math.max(0, Number(file.updatedAt || 0) || 0),
        },
      };
    }

    async function requestSharedPlayback(input = {}) {
      if (role !== "participant") return false;
      if (!roomCode) return false;
      if (normalizeControlMode(state.controlMode) !== "shared-pause") return false;
      if (!transport || typeof transport.updateSessionState !== "function") {
        return false;
      }

      const requestType =
        String(input.requestType || "").trim() === "play" ? "play" : "pause";
      const payload = {
        requestType,
        isPlaying: requestType === "play",
        reason: String(
          input.reason ||
            (requestType === "play"
              ? "participant-shared-play"
              : "participant-shared-pause"),
        ),
        ts: now(),
      };

      const statePayload = await transport.updateSessionState({
        sessionCode: roomCode,
        sourceClientId: clientId,
        payload,
      });
      const normalizedSharedState = normalizeSharedSessionStatePayload(
        statePayload,
        statePayload?.revision,
      );
      patchState({
        sharedSessionState: normalizedSharedState.payload,
        sharedSessionStateRevision: normalizedSharedState.revision,
        lastError: "",
      });
      return true;
    }

    async function requestSharedPause(input = {}) {
      return requestSharedPlayback({
        ...input,
        requestType: "pause",
      });
    }

    async function updateParticipantState(input = {}) {
      if (!roomCode) return false;
      if (
        !transport ||
        typeof transport.updateParticipantState !== "function"
      ) {
        return false;
      }
      if (role !== "participant" && role !== "host") return false;
      const snapshot = await transport.updateParticipantState({
        sessionCode: roomCode,
        sourceClientId: clientId,
        syncState: input.syncState,
      });
      applyRoomSnapshot(snapshot, role === "host" ? "host" : "participant");
      return true;
    }

    function getState() {
      return cloneState();
    }

    function subscribe(listener) {
      if (typeof listener !== "function") {
        return () => {};
      }
      listeners.add(listener);
      try {
        listener(cloneState());
      } catch (_) {}
      return () => {
        listeners.delete(listener);
      };
    }

    return {
      getState,
      subscribe,
      hostSession,
      joinSession,
      leaveSession,
      updateSessionMeta,
      publishSessionState,
      publishSessionPack,
      fetchSessionPack,
      resetSessionMediaPack,
      publishSessionMediaFile,
      fetchSessionMediaManifest,
      fetchSessionMediaFile,
      requestSharedPlayback,
      requestSharedPause,
      updateParticipantState,
    };
  }

  sharedRoot.createSyncSessionService = createSyncSessionService;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/preferences-transfer-utils.js ===== */
(function initPoseChronoSharedPreferencesTransferUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPreferencesTransferUtils(options = {}) {
    const doc = options.document || (typeof document !== "undefined" ? document : null);
    const urlApi = options.URL || (typeof URL !== "undefined" ? URL : null);
    const BlobCtor = options.Blob || (typeof Blob !== "undefined" ? Blob : null);
    const FileReaderCtor =
      options.FileReader || (typeof FileReader !== "undefined" ? FileReader : null);
    const scheduleTimeout =
      typeof options.setTimeout === "function" ? options.setTimeout : setTimeout;
    const logError =
      typeof options.logError === "function" ? options.logError : () => {};

    function createBackupFilename(nowDate = null) {
      const now = nowDate instanceof Date ? nowDate : new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, "0");
      const dd = String(now.getDate()).padStart(2, "0");
      const hh = String(now.getHours()).padStart(2, "0");
      const min = String(now.getMinutes()).padStart(2, "0");
      const ss = String(now.getSeconds()).padStart(2, "0");
      return `posechrono-backup-${yyyy}${mm}${dd}-${hh}${min}${ss}.json`;
    }

    function downloadJsonPayload(filename, payload) {
      if (!doc || !doc.body || !urlApi || !BlobCtor) return false;
      try {
        const content = JSON.stringify(payload, null, 2);
        const blob = new BlobCtor([content], {
          type: "application/json;charset=utf-8",
        });
        const objectUrl = urlApi.createObjectURL(blob);
        const anchor = doc.createElement("a");
        anchor.href = objectUrl;
        anchor.download = filename;
        doc.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        scheduleTimeout(() => urlApi.revokeObjectURL(objectUrl), 0);
        return true;
      } catch (error) {
        logError(error);
        return false;
      }
    }

    function pickJsonFileText() {
      return new Promise((resolve) => {
        if (!doc || !doc.body || !FileReaderCtor) {
          resolve(null);
          return;
        }
        const input = doc.createElement("input");
        input.type = "file";
        input.accept = ".json,application/json";
        input.style.display = "none";
        doc.body.appendChild(input);

        const cleanup = () => {
          input.remove();
        };

        input.addEventListener(
          "change",
          () => {
            const file = input.files && input.files[0];
            if (!file) {
              cleanup();
              resolve(null);
              return;
            }
            const reader = new FileReaderCtor();
            reader.onload = () => {
              cleanup();
              resolve(typeof reader.result === "string" ? reader.result : null);
            };
            reader.onerror = () => {
              cleanup();
              resolve(null);
            };
            reader.readAsText(file, "utf-8");
          },
          { once: true },
        );

        input.click();
      });
    }

    function hasAnySectionSelected(selections) {
      if (!selections || typeof selections !== "object") return false;
      return Object.values(selections).some(Boolean);
    }

    function getAvailableSectionsFromPackage(parsed) {
      const sections =
        parsed && typeof parsed === "object" && parsed.sections
          ? parsed.sections
          : {};
      return {
        ui: !!sections.ui,
        hotkeys: !!sections.hotkeys,
        plans: !!sections.plans,
        timeline: !!sections.timeline,
      };
    }

    function isValidPreferencesPackage(parsed) {
      return !!(
        parsed &&
        typeof parsed === "object" &&
        parsed.sections &&
        typeof parsed.sections === "object"
      );
    }

    return {
      createBackupFilename,
      downloadJsonPayload,
      pickJsonFileText,
      hasAnySectionSelected,
      getAvailableSectionsFromPackage,
      isValidPreferencesPackage,
    };
  }

  sharedRoot.createPreferencesTransferUtils = createPreferencesTransferUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-access-utils.js ===== */
(function initPoseChronoSharedPlatformAccessUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPlatformAccessUtils(options = {}) {
    const getterName = String(options.getterName || "getPoseChronoPlatform");

    function getPlatform() {
      try {
        if (
          typeof window !== "undefined" &&
          typeof window[getterName] === "function"
        ) {
          return window[getterName]();
        }
      } catch (_) {}
      return null;
    }

    return {
      getPlatform,
    };
  }

  sharedRoot.createPlatformAccessUtils = createPlatformAccessUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-capability-utils.js ===== */
(function initPoseChronoSharedPlatformCapabilityUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createCapabilityWarner(options = {}) {
    const warned = new Set();
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const logger =
      typeof options.logger === "function" ? options.logger : console.warn;
    const prefix = String(options.prefix || "[Platform]");

    return function warnMissingCapability(capabilityKey, operationLabel) {
      const capability = String(capabilityKey || "").trim();
      if (!capability) return;
      if (warned.has(capability)) return;

      const platform = getPlatform();
      const hasPlatformCapabilities =
        !!platform &&
        !!platform.capabilities &&
        Object.prototype.hasOwnProperty.call(platform.capabilities, capability);

      if (!hasPlatformCapabilities || platform.capabilities[capability]) return;

      warned.add(capability);
      logger(
        `${prefix} Missing capability "${capability}" for "${operationLabel}".`,
      );
    };
  }

  sharedRoot.createCapabilityWarner = createCapabilityWarner;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-ops-utils.js ===== */
(function initPoseChronoSharedPlatformOpsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function resolvePath(target, path) {
    const parts = String(path || "")
      .split(".")
      .map((part) => part.trim())
      .filter(Boolean);
    if (!target || parts.length === 0) return null;
    let node = target;
    for (const part of parts) {
      if (!node || typeof node !== "object") return null;
      node = node[part];
    }
    return node;
  }

  function createPlatformOpsUtils(options = {}) {
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const warnMissingCapability =
      typeof options.warnMissingCapability === "function"
        ? options.warnMissingCapability
        : () => {};

    function call(path, args = [], config = {}) {
      const platform = getPlatform();
      const fn = resolvePath(platform, path);
      const safeArgs = Array.isArray(args) ? args : [args];
      if (typeof fn === "function") {
        try {
          fn(...safeArgs);
          return true;
        } catch (_) {}
      }
      if (config.capability && config.operationLabel) {
        warnMissingCapability(config.capability, config.operationLabel);
      }
      return false;
    }

    async function callAsync(path, args = [], config = {}) {
      const platform = getPlatform();
      const fn = resolvePath(platform, path);
      const safeArgs = Array.isArray(args) ? args : [args];
      if (typeof fn === "function") {
        try {
          return await fn(...safeArgs);
        } catch (_) {}
      }
      if (config.capability && config.operationLabel) {
        warnMissingCapability(config.capability, config.operationLabel);
      }
      return config.fallback;
    }

    async function callBoolean(path, args = [], config = {}) {
      const failToken = Symbol("platform-op-fail");
      const result = await callAsync(path, args, {
        capability: config.capability,
        operationLabel: config.operationLabel,
        fallback: failToken,
      });
      return result !== failToken;
    }

    async function callArray(path, args = [], config = {}) {
      const result = await callAsync(path, args, {
        capability: config.capability,
        operationLabel: config.operationLabel,
        fallback: [],
      });
      return Array.isArray(result) ? result : [];
    }

    return {
      call,
      callAsync,
      callBoolean,
      callArray,
    };
  }

  sharedRoot.createPlatformOpsUtils = createPlatformOpsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-window-utils.js ===== */
(function initPoseChronoSharedPlatformWindowUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPlatformWindowUtils(options = {}) {
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const warnMissingCapability =
      typeof options.warnMissingCapability === "function"
        ? options.warnMissingCapability
        : () => {};
    let fallbackMaximizedState = false;

    async function toggleMaximize() {
      const platform = getPlatform();
      try {
        if (platform?.window) {
          const canMaximize = typeof platform.window.maximize === "function";
          const canUnmaximize = typeof platform.window.unmaximize === "function";
          const canReadMaximized = typeof platform.window.isMaximized === "function";

          if (canReadMaximized) {
            try {
              const isMaximized = !!(await platform.window.isMaximized());
              fallbackMaximizedState = isMaximized;
              if (isMaximized && canUnmaximize) {
                await platform.window.unmaximize();
                fallbackMaximizedState = false;
                return null;
              }
              if (!isMaximized && canMaximize) {
                await platform.window.maximize();
                fallbackMaximizedState = true;
                return null;
              }
            } catch (_) {}
          }

          if (canMaximize && canUnmaximize) {
            if (fallbackMaximizedState) {
              await platform.window.unmaximize();
              fallbackMaximizedState = false;
            } else {
              await platform.window.maximize();
              fallbackMaximizedState = true;
            }
            return null;
          }
          if (canMaximize) {
            await platform.window.maximize();
            fallbackMaximizedState = true;
            return null;
          }
          if (canUnmaximize) {
            await platform.window.unmaximize();
            fallbackMaximizedState = false;
            return null;
          }
        }
      } catch (_) {}
      warnMissingCapability("windowControls", "window.toggleMaximize");
    }

    async function toggleAlwaysOnTop() {
      const platform = getPlatform();
      try {
        if (platform?.window) {
          const isOnTop = await (platform.window.isAlwaysOnTop?.() || false);
          if (platform.window.setAlwaysOnTop) {
            await platform.window.setAlwaysOnTop(!isOnTop);
          }
          return !isOnTop;
        }
      } catch (_) {}
      warnMissingCapability("windowControls", "window.toggleAlwaysOnTop");
      return false;
    }

    return {
      toggleMaximize,
      toggleAlwaysOnTop,
    };
  }

  sharedRoot.createPlatformWindowUtils = createPlatformWindowUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/image-context-menu-bindings-utils.js ===== */
(function initPoseChronoSharedImageContextMenuBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindImageContextMenus(input = {}) {
    const targets = Array.isArray(input.targets) ? input.targets : [];
    const onOpenMenu =
      typeof input.onOpenMenu === "function" ? input.onOpenMenu : null;
    if (!targets.length || !onOpenMenu) return false;

    let boundCount = 0;
    targets.forEach((target) => {
      if (!target || typeof target.addEventListener !== "function") return;
      target.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onOpenMenu(event.clientX, event.clientY, event);
      });
      boundCount += 1;
    });

    return boundCount > 0;
  }

  function createImageContextMenuBindingsUtils() {
    return {
      bindImageContextMenus,
    };
  }

  sharedRoot.createImageContextMenuBindingsUtils =
    createImageContextMenuBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/action-buttons-bindings-utils.js ===== */
(function initPoseChronoSharedActionButtonsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindActionButtons(input = {}) {
    const deleteBtn = input.deleteBtn;
    const revealBtn = input.revealBtn;
    const onDelete = typeof input.onDelete === "function" ? input.onDelete : null;
    const onReveal = typeof input.onReveal === "function" ? input.onReveal : null;
    const onRevealContextMenu =
      typeof input.onRevealContextMenu === "function"
        ? input.onRevealContextMenu
        : null;

    let hasAnyBinding = false;

    if (deleteBtn && onDelete && typeof deleteBtn.addEventListener === "function") {
      deleteBtn.addEventListener("click", onDelete);
      hasAnyBinding = true;
    }

    if (revealBtn && typeof revealBtn.addEventListener === "function") {
      if (onReveal) {
        revealBtn.addEventListener("click", onReveal);
        hasAnyBinding = true;
      }
      if (onRevealContextMenu) {
        revealBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onRevealContextMenu(event.clientX, event.clientY, event);
        });
        hasAnyBinding = true;
      }
    }

    return hasAnyBinding;
  }

  function createActionButtonsBindingsUtils() {
    return {
      bindActionButtons,
    };
  }

  sharedRoot.createActionButtonsBindingsUtils = createActionButtonsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-plan-utils.js ===== */
(function initPoseChronoSharedSessionPlanUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSessionPlanUtils(options = {}) {
    const schemaVersion = Number(options.schemaVersion || 1);
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();

    function clampInt(value, min, max, fallback = min) {
      const num = Number(value);
      if (!Number.isFinite(num)) return fallback;
      return Math.max(min, Math.min(max, Math.round(num)));
    }

    function normalizeCustomStep(step) {
      if (!step || typeof step !== "object") return null;
      const type =
        step.type === "pause" ? "pause" : step.type === "pose" ? "pose" : null;
      if (!type) return null;

      const duration = clampInt(step.duration, 1, 86400, 60);
      const count = type === "pause" ? 1 : clampInt(step.count, 1, 10000, 1);
      const idCandidate = Number(step.id);
      const id = Number.isFinite(idCandidate)
        ? idCandidate
        : now() + Math.floor(Math.random() * 10000);

      return { type, count, duration, id };
    }

    function normalizeSessionPlansPayload(raw) {
      const source =
        raw && typeof raw === "object" && Array.isArray(raw.plans)
          ? raw.plans
          : Array.isArray(raw)
            ? raw
            : [];

      let repaired = false;
      const plans = [];

      source.forEach((plan, index) => {
        if (!plan || typeof plan !== "object") {
          repaired = true;
          return;
        }
        const nameRaw = String(plan.name ?? "").trim();
        const name =
          nameRaw.length > 0 ? nameRaw.slice(0, 120) : `Plan ${index + 1}`;
        if (name !== nameRaw) repaired = true;

        const date = clampInt(plan.date, 0, 4102444800000, now());
        const rawSteps = Array.isArray(plan.steps) ? plan.steps : [];
        if (!Array.isArray(plan.steps)) repaired = true;
        const steps = rawSteps
          .map((step) => normalizeCustomStep(step))
          .filter(Boolean);
        if (steps.length !== rawSteps.length) repaired = true;
        if (steps.length === 0) {
          repaired = true;
          return;
        }

        plans.push({
          name,
          steps,
          date,
        });
      });

      const payload = {
        schemaVersion,
        plans,
      };
      if (
        !raw ||
        typeof raw !== "object" ||
        raw.schemaVersion !== schemaVersion ||
        !Array.isArray(raw.plans)
      ) {
        repaired = true;
      }
      return { payload, plans, repaired };
    }

    function renderPlansListHtml(plans, options = {}) {
      const safePlans = Array.isArray(plans) ? plans : [];
      if (safePlans.length === 0) return "";

      const escapeHtml =
        typeof options.escapeHtml === "function"
          ? options.escapeHtml
          : (value) => String(value ?? "");
      const formatDuration =
        typeof options.formatDuration === "function"
          ? options.formatDuration
          : () => "0s";
      const calculatePlanDuration =
        typeof options.calculatePlanDuration === "function"
          ? options.calculatePlanDuration
          : () => 0;
      const calculatePlanPoses =
        typeof options.calculatePlanPoses === "function"
          ? options.calculatePlanPoses
          : () => 0;
      const getPlanWord =
        typeof options.getPlanWord === "function"
          ? options.getPlanWord
          : () => "";
      const loadLabel = String(options.loadLabel || "Load");
      const deleteButtonIcon = String(options.deleteButtonIcon || "");

      return safePlans
        .map((plan, index) => {
          const totalDuration = calculatePlanDuration(plan.steps);
          const totalPoses = calculatePlanPoses(plan.steps);
          const totalSteps = (plan.steps || []).length;
          const durationText = formatDuration(totalDuration);
          const posesLabel = getPlanWord("pose", totalPoses);
          const stepsLabel = getPlanWord("step", totalSteps);
          return `
      <div class="plan-item">
        <div class="plan-info">
          <div class="plan-name" data-index="${index}" contenteditable="false" style="cursor: pointer;">${escapeHtml(plan.name)}</div>
          <div class="plan-meta">${durationText} - ${totalPoses} ${posesLabel} - ${totalSteps} ${stepsLabel}</div>
        </div>
        <div class="plan-actions">
          <button type="button" class="plan-btn plan-load-btn" data-index="${index}">${loadLabel}</button>
          <button type="button" class="plan-btn plan-delete-btn" data-index="${index}">${deleteButtonIcon}</button>
        </div>
      </div>
    `;
        })
        .join("");
    }

    function formatPlanDeleteSummary(plan, options = {}) {
      const safePlan = plan && typeof plan === "object" ? plan : { steps: [] };
      const formatDuration =
        typeof options.formatDuration === "function"
          ? options.formatDuration
          : () => "0s";
      const calculatePlanDuration =
        typeof options.calculatePlanDuration === "function"
          ? options.calculatePlanDuration
          : () => 0;
      const calculatePlanPoses =
        typeof options.calculatePlanPoses === "function"
          ? options.calculatePlanPoses
          : () => 0;
      const getPlanWord =
        typeof options.getPlanWord === "function"
          ? options.getPlanWord
          : () => "";

      const totalDuration = formatDuration(calculatePlanDuration(safePlan.steps));
      const totalPoses = calculatePlanPoses(safePlan.steps);
      const stepsCount = (safePlan.steps || []).length;
      const posesLabel = getPlanWord("pose", totalPoses);
      const stepsLabel = getPlanWord("step", stepsCount);

      return {
        totalDuration,
        totalPoses,
        stepsCount,
        posesLabel,
        stepsLabel,
        summary: `${safePlan.name} (${totalDuration} - ${totalPoses} ${posesLabel}, ${stepsCount} ${stepsLabel})`,
      };
    }

    function getPlanSaveValidation(input = {}) {
      const name = String(input.name || "").trim();
      const queueLength = Number(input.queueLength || 0);
      if (!name) {
        return { ok: false, reason: "empty-name" };
      }
      if (queueLength <= 0) {
        return { ok: false, reason: "empty-queue" };
      }
      return { ok: true, reason: "" };
    }

    function createPlanEntry(input = {}) {
      const name = String(input.name || "").trim();
      const queue = Array.isArray(input.queue) ? input.queue : [];
      const date =
        Number.isFinite(Number(input.date)) && Number(input.date) > 0
          ? Number(input.date)
          : now();
      return {
        name,
        steps: JSON.parse(JSON.stringify(queue)),
        date,
      };
    }

    return {
      clampInt,
      normalizeCustomStep,
      normalizeSessionPlansPayload,
      renderPlansListHtml,
      formatPlanDeleteSummary,
      getPlanSaveValidation,
      createPlanEntry,
    };
  }

  sharedRoot.createSessionPlanUtils = createSessionPlanUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-metrics.js ===== */
(function initPoseChronoSharedSessionMetrics(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSessionMetricsUtils() {
    function toFiniteNumber(value, fallback = 0) {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    }

    function calculatePlanDuration(steps) {
      if (!Array.isArray(steps)) return 0;
      return steps.reduce((total, step) => {
        if (!step || typeof step !== "object") return total;
        const duration = Math.max(0, toFiniteNumber(step.duration, 0));
        if (step.type === "pause") return total + duration;
        const count = Math.max(0, toFiniteNumber(step.count, 0));
        return total + count * duration;
      }, 0);
    }

    function calculatePlanPoses(steps) {
      if (!Array.isArray(steps)) return 0;
      return steps.reduce((total, step) => {
        if (!step || typeof step !== "object" || step.type === "pause") {
          return total;
        }
        return total + Math.max(0, toFiniteNumber(step.count, 0));
      }, 0);
    }

    function clampMemoryPosesCount(requestedCount, imagesCount, fallback = 1) {
      const min = 1;
      const images = Math.max(min, Math.round(toFiniteNumber(imagesCount, min)));
      const desired = Math.round(toFiniteNumber(requestedCount, fallback));
      return Math.max(min, Math.min(desired, images));
    }

    function calculateMemoryTotalSeconds(posesCount, drawingTime, displayTime) {
      const poses = Math.max(0, toFiniteNumber(posesCount, 0));
      const drawing = Math.max(0, toFiniteNumber(drawingTime, 0));
      const display = Math.max(0, toFiniteNumber(displayTime, 0));
      return poses * (drawing + display);
    }

    return {
      calculatePlanDuration,
      calculatePlanPoses,
      clampMemoryPosesCount,
      calculateMemoryTotalSeconds,
    };
  }

  sharedRoot.createSessionMetricsUtils = createSessionMetricsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-controls-bindings-utils.js ===== */
(function initPoseChronoSharedSessionControlsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toElementArray(value) {
    if (!value) return [];
    if (Array.isArray(value)) return value.filter(Boolean);
    if (
      typeof value !== "string" &&
      typeof value !== "function" &&
      typeof value.length === "number"
    ) {
      try {
        return Array.from(value).filter(Boolean);
      } catch (_) {
        return [];
      }
    }
    return [];
  }

  function bindMemoryOverlayButtons(input = {}) {
    const memoryOverlay = input.memoryOverlay || null;
    const memoryPeekBtn = input.memoryPeekBtn || null;
    const memoryRevealBtn = input.memoryRevealBtn || null;
    const getRevealLabel =
      typeof input.getRevealLabel === "function" ? input.getRevealLabel : null;

    let bound = false;

    if (memoryPeekBtn && typeof memoryPeekBtn.addEventListener === "function") {
      memoryPeekBtn.addEventListener("mousedown", (event) => {
        event.stopPropagation();
        if (memoryOverlay && !memoryPeekBtn.disabled) {
          memoryOverlay.classList.add("peek-active");
          memoryOverlay.classList.add("peek-content-hidden");
        }
      });

      memoryPeekBtn.addEventListener("mouseup", (event) => {
        event.stopPropagation();
        if (memoryOverlay) {
          memoryOverlay.classList.remove("peek-active");
          memoryOverlay.classList.remove("peek-content-hidden");
        }
      });

      memoryPeekBtn.addEventListener("mouseleave", () => {
        if (memoryOverlay) {
          memoryOverlay.classList.remove("peek-active");
          memoryOverlay.classList.remove("peek-content-hidden");
        }
      });

      bound = true;
    }

    if (memoryRevealBtn && typeof memoryRevealBtn.addEventListener === "function") {
      memoryRevealBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!memoryOverlay) return;
        const isRevealed = memoryOverlay.classList.toggle("revealed");
        if (getRevealLabel) {
          memoryRevealBtn.textContent = getRevealLabel(isRevealed);
        }
        if (memoryPeekBtn) {
          memoryPeekBtn.disabled = isRevealed;
        }
      });
      bound = true;
    }

    return bound;
  }

  function bindShuffleAndAutoFlipButtons(input = {}) {
    const randomShuffleBtn = input.randomShuffleBtn || null;
    const autoFlipBtn = input.autoFlipBtn || null;
    const state = input.state || null;
    const onShuffleToggle =
      typeof input.onShuffleToggle === "function" ? input.onShuffleToggle : null;
    const onAutoFlipContextMenu =
      typeof input.onAutoFlipContextMenu === "function"
        ? input.onAutoFlipContextMenu
        : null;

    let bound = false;

    if (randomShuffleBtn && state && typeof randomShuffleBtn.addEventListener === "function") {
      randomShuffleBtn.classList.toggle("active", !!state.randomShuffle);
      randomShuffleBtn.addEventListener("click", () => {
        state.randomShuffle = !state.randomShuffle;
        randomShuffleBtn.classList.toggle("active", !!state.randomShuffle);
        if (onShuffleToggle) {
          onShuffleToggle(!!state.randomShuffle);
        }
      });
      bound = true;
    }

    if (autoFlipBtn && state && typeof autoFlipBtn.addEventListener === "function") {
      autoFlipBtn.classList.toggle("active", !!state.autoFlip);
      autoFlipBtn.addEventListener("click", () => {
        state.autoFlip = !state.autoFlip;
        autoFlipBtn.classList.toggle("active", !!state.autoFlip);
      });

      if (onAutoFlipContextMenu) {
        autoFlipBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onAutoFlipContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindTimerControlsAndProgress(input = {}) {
    const soundBtn = input.soundBtn || null;
    const toggleTimerBtn = input.toggleTimerBtn || null;
    const timerDisplay = input.timerDisplay || null;
    const progressBar = input.progressBar || null;
    const pauseCentralBlock = input.pauseCentralBlock || null;
    const state = input.state || {};
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);

    const onToggleSound =
      typeof input.onToggleSound === "function" ? input.onToggleSound : null;
    const onToggleTimer =
      typeof input.onToggleTimer === "function" ? input.onToggleTimer : null;
    const onShowProgressBarContextMenu =
      typeof input.onShowProgressBarContextMenu === "function"
        ? input.onShowProgressBarContextMenu
        : null;
    const onShowTimerContextMenu =
      typeof input.onShowTimerContextMenu === "function"
        ? input.onShowTimerContextMenu
        : null;
    const onShowPauseCircleContextMenu =
      typeof input.onShowPauseCircleContextMenu === "function"
        ? input.onShowPauseCircleContextMenu
        : null;
    const onUpdateTimerDisplay =
      typeof input.onUpdateTimerDisplay === "function"
        ? input.onUpdateTimerDisplay
        : null;

    let bound = false;
    let isDraggingProgress = false;

    if (soundBtn && onToggleSound && typeof soundBtn.addEventListener === "function") {
      soundBtn.addEventListener("click", onToggleSound);
      bound = true;
    }

    if (toggleTimerBtn && typeof toggleTimerBtn.addEventListener === "function") {
      if (onToggleTimer) {
        toggleTimerBtn.addEventListener("click", onToggleTimer);
      }
      if (onShowProgressBarContextMenu) {
        toggleTimerBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressBarContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (
      timerDisplay &&
      onShowTimerContextMenu &&
      typeof timerDisplay.addEventListener === "function"
    ) {
      timerDisplay.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onShowTimerContextMenu(event.clientX, event.clientY, event);
      });
      bound = true;
    }

    if (progressBar && typeof progressBar.addEventListener === "function") {
      progressBar.addEventListener("click", (event) => {
        if (event.button !== 0) return;
        if (!state.isPlaying && state.selectedDuration > 0) return;
        const rect = progressBar.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        state.timeRemaining = Math.round(percent * state.selectedDuration);
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
      });

      if (onShowProgressBarContextMenu) {
        progressBar.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          event.stopPropagation();
          onShowProgressBarContextMenu(event.clientX, event.clientY, event);
        });
      }

      progressBar.addEventListener("mousedown", (event) => {
        if (event.button !== 0) return;
        if (state.selectedDuration <= 0) return;
        isDraggingProgress = true;
        const rect = progressBar.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        state.timeRemaining = Math.max(
          0,
          Math.min(
            state.selectedDuration,
            Math.round(percent * state.selectedDuration),
          ),
        );
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
        progressBar.style.cursor = "grabbing";
      });
      bound = true;
    }

    if (documentRef && progressBar && typeof documentRef.addEventListener === "function") {
      documentRef.addEventListener("mousemove", (event) => {
        if (!isDraggingProgress) return;
        const rect = progressBar.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(1, (event.clientX - rect.left) / rect.width),
        );
        state.timeRemaining = Math.round(percent * state.selectedDuration);
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
      });

      documentRef.addEventListener("mouseup", () => {
        if (!isDraggingProgress) return;
        isDraggingProgress = false;
        progressBar.style.cursor = "pointer";
      });
      bound = true;
    }

    if (
      pauseCentralBlock &&
      onShowPauseCircleContextMenu &&
      typeof pauseCentralBlock.addEventListener === "function"
    ) {
      pauseCentralBlock.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onShowPauseCircleContextMenu(event.clientX, event.clientY, event);
      });
      bound = true;
    }

    return bound;
  }

  function bindVideoScrubbing(input = {}) {
    const currentVideo = input.currentVideo || null;
    const state = input.state || {};
    const frameStepState = input.frameStepState || {};
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const performanceRef =
      input.performanceRef ||
      (typeof performance !== "undefined" ? performance : null);
    const requestAnimationFrameRef =
      input.requestAnimationFrameRef ||
      (typeof requestAnimationFrame === "function"
        ? requestAnimationFrame
        : null);
    const cancelAnimationFrameRef =
      input.cancelAnimationFrameRef ||
      (typeof cancelAnimationFrame === "function" ? cancelAnimationFrame : null);
    const onUpdateVideoTimeDisplay =
      typeof input.onUpdateVideoTimeDisplay === "function"
        ? input.onUpdateVideoTimeDisplay
        : null;

    if (
      !currentVideo ||
      !documentRef ||
      !performanceRef ||
      !requestAnimationFrameRef
    ) {
      return false;
    }

    let isScrubbingVideo = false;
    let scrubStartX = 0;
    let scrubStartTime = 0;
    let scrubTargetTime = 0;
    let scrubRafId = null;
    let scrubLastSeekTime = 0;
    const SCRUB_MIN_INTERVAL = 1000 / 30;

    function performScrubSeek() {
      scrubRafId = null;

      if (!isScrubbingVideo || !currentVideo.duration) return;

      const now = performanceRef.now();
      if (now - scrubLastSeekTime < SCRUB_MIN_INTERVAL) {
        scrubRafId = requestAnimationFrameRef(performScrubSeek);
        return;
      }

      scrubLastSeekTime = now;

      if (
        frameStepState.vfcSupported &&
        typeof currentVideo.requestVideoFrameCallback === "function"
      ) {
        currentVideo.currentTime = scrubTargetTime;
        currentVideo.requestVideoFrameCallback(() => {
          if (onUpdateVideoTimeDisplay) {
            onUpdateVideoTimeDisplay();
          }
          if (isScrubbingVideo && scrubTargetTime !== currentVideo.currentTime) {
            scrubRafId = requestAnimationFrameRef(performScrubSeek);
          }
        });
      } else {
        currentVideo.currentTime = scrubTargetTime;
        if (onUpdateVideoTimeDisplay) {
          onUpdateVideoTimeDisplay();
        }
      }
    }

    currentVideo.addEventListener("keydown", (event) => {
      if (event.key !== " ") return;
      event.preventDefault();
      event.stopPropagation();
    });

    currentVideo.addEventListener("mousedown", (event) => {
      if (!state.isVideoFile || !currentVideo.duration) return;
      isScrubbingVideo = true;
      scrubStartX = event.clientX;
      scrubStartTime = currentVideo.currentTime;
      scrubTargetTime = scrubStartTime;
      currentVideo.style.cursor = "ew-resize";
      event.preventDefault();
    });

    documentRef.addEventListener("mousemove", (event) => {
      if (!isScrubbingVideo || !currentVideo.duration) return;

      const deltaX = event.clientX - scrubStartX;
      const videoWidth = currentVideo.offsetWidth || 800;
      let sensitivity = currentVideo.duration / videoWidth;

      if (event.shiftKey) {
        sensitivity *= 0.1;
      }

      scrubTargetTime = Math.max(
        0,
        Math.min(currentVideo.duration, scrubStartTime + deltaX * sensitivity),
      );

      if (!scrubRafId) {
        scrubRafId = requestAnimationFrameRef(performScrubSeek);
      }
    });

    documentRef.addEventListener("mouseup", () => {
      if (!isScrubbingVideo) return;
      isScrubbingVideo = false;
      currentVideo.style.cursor = "";
      if (scrubRafId && cancelAnimationFrameRef) {
        cancelAnimationFrameRef(scrubRafId);
        scrubRafId = null;
      }
      if (currentVideo.currentTime !== scrubTargetTime) {
        currentVideo.currentTime = scrubTargetTime;
        if (onUpdateVideoTimeDisplay) {
          onUpdateVideoTimeDisplay();
        }
      }
    });

    return true;
  }

  function bindVideoControls(input = {}) {
    const videoPlayBtn = input.videoPlayBtn || null;
    const videoSlowerBtn = input.videoSlowerBtn || null;
    const videoFasterBtn = input.videoFasterBtn || null;
    const videoPrevFrameBtn = input.videoPrevFrameBtn || null;
    const videoNextFrameBtn = input.videoNextFrameBtn || null;
    const videoLoopBtn = input.videoLoopBtn || null;
    const videoConfigBtn = input.videoConfigBtn || null;
    const videoSpeedDisplay = input.videoSpeedDisplay || null;
    const videoTimeline = input.videoTimeline || null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const state = input.state || {};
    const frameStepState = input.frameStepState || {};
    const icons = input.icons || {};
    const t = typeof input.translate === "function" ? input.translate : null;

    const onToggleVideoPlayPause =
      typeof input.onToggleVideoPlayPause === "function"
        ? input.onToggleVideoPlayPause
        : null;
    const onChangeVideoSpeed =
      typeof input.onChangeVideoSpeed === "function"
        ? input.onChangeVideoSpeed
        : null;
    const onStepFrame =
      typeof input.onStepFrame === "function" ? input.onStepFrame : null;
    const onProcessFrameStepLoop =
      typeof input.onProcessFrameStepLoop === "function"
        ? input.onProcessFrameStepLoop
        : null;
    const onStopFrameSteppingFromButton =
      typeof input.onStopFrameSteppingFromButton === "function"
        ? input.onStopFrameSteppingFromButton
        : null;
    const onToggleVideoLoop =
      typeof input.onToggleVideoLoop === "function" ? input.onToggleVideoLoop : null;
    const onShowVideoConfig =
      typeof input.onShowVideoConfig === "function" ? input.onShowVideoConfig : null;
    const onShowSpeedPopup =
      typeof input.onShowSpeedPopup === "function" ? input.onShowSpeedPopup : null;
    const onSeekVideo =
      typeof input.onSeekVideo === "function" ? input.onSeekVideo : null;

    let bound = false;

    if (videoPlayBtn && typeof videoPlayBtn.addEventListener === "function") {
      if (icons.VIDEO_PLAY) {
        videoPlayBtn.innerHTML = icons.VIDEO_PLAY;
      }
      if (onToggleVideoPlayPause) {
        videoPlayBtn.addEventListener("click", onToggleVideoPlayPause);
      }
      bound = true;
    }

    if (videoSlowerBtn && typeof videoSlowerBtn.addEventListener === "function") {
      if (icons.VIDEO_SLOWER) {
        videoSlowerBtn.innerHTML = icons.VIDEO_SLOWER;
      }
      if (onChangeVideoSpeed) {
        videoSlowerBtn.addEventListener("click", () => onChangeVideoSpeed(-1));
      }
      bound = true;
    }

    if (videoFasterBtn && typeof videoFasterBtn.addEventListener === "function") {
      if (icons.VIDEO_FASTER) {
        videoFasterBtn.innerHTML = icons.VIDEO_FASTER;
      }
      if (onChangeVideoSpeed) {
        videoFasterBtn.addEventListener("click", () => onChangeVideoSpeed(1));
      }
      bound = true;
    }

    if (videoPrevFrameBtn && typeof videoPrevFrameBtn.addEventListener === "function") {
      if (icons.VIDEO_PREV_FRAME) {
        videoPrevFrameBtn.innerHTML = icons.VIDEO_PREV_FRAME;
      }
      if (onStepFrame && onProcessFrameStepLoop) {
        videoPrevFrameBtn.addEventListener("mousedown", (event) => {
          event.preventDefault();
          onStepFrame(-1, false);
          frameStepState.buttonHoldTimeout = setTimeout(() => {
            frameStepState.isHoldingKey = true;
            frameStepState.pendingDirection = -1;
            onProcessFrameStepLoop();
          }, 200);
        });
      }
      if (onStopFrameSteppingFromButton) {
        videoPrevFrameBtn.addEventListener("mouseup", onStopFrameSteppingFromButton);
        videoPrevFrameBtn.addEventListener(
          "mouseleave",
          onStopFrameSteppingFromButton,
        );
      }
      bound = true;
    }

    if (videoNextFrameBtn && typeof videoNextFrameBtn.addEventListener === "function") {
      if (icons.VIDEO_NEXT_FRAME) {
        videoNextFrameBtn.innerHTML = icons.VIDEO_NEXT_FRAME;
      }
      if (onStepFrame && onProcessFrameStepLoop) {
        videoNextFrameBtn.addEventListener("mousedown", (event) => {
          event.preventDefault();
          onStepFrame(1, false);
          frameStepState.buttonHoldTimeout = setTimeout(() => {
            frameStepState.isHoldingKey = true;
            frameStepState.pendingDirection = 1;
            onProcessFrameStepLoop();
          }, 200);
        });
      }
      if (onStopFrameSteppingFromButton) {
        videoNextFrameBtn.addEventListener("mouseup", onStopFrameSteppingFromButton);
        videoNextFrameBtn.addEventListener(
          "mouseleave",
          onStopFrameSteppingFromButton,
        );
      }
      bound = true;
    }

    if (videoLoopBtn && typeof videoLoopBtn.addEventListener === "function") {
      if (state.videoLoop) {
        videoLoopBtn.innerHTML = icons.VIDEO_LOOP_ON || "";
      } else {
        videoLoopBtn.innerHTML = icons.VIDEO_LOOP_OFF || "";
      }
      if (onToggleVideoLoop) {
        videoLoopBtn.addEventListener("click", onToggleVideoLoop);
      }
      if (onShowVideoConfig) {
        videoLoopBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowVideoConfig();
        });
      }
      bound = true;
    }

    if (videoConfigBtn && typeof videoConfigBtn.addEventListener === "function") {
      if (icons.VIDEO_CONFIG) {
        videoConfigBtn.innerHTML = icons.VIDEO_CONFIG;
      }
      if (onShowVideoConfig) {
        videoConfigBtn.addEventListener("click", onShowVideoConfig);
      }
      bound = true;
    }

    if (videoSpeedDisplay && typeof videoSpeedDisplay.addEventListener === "function") {
      const speedIndicator = videoSpeedDisplay.parentElement;
      if (speedIndicator) {
        speedIndicator.style.cursor = "pointer";
        if (onShowSpeedPopup) {
          speedIndicator.addEventListener("click", onShowSpeedPopup);
        }
        if (t) {
          speedIndicator.setAttribute("data-tooltip", t("video.clickToAdjustSpeed"));
        }
      }
      bound = true;
    }

    if (videoTimeline && onSeekVideo && typeof videoTimeline.addEventListener === "function") {
      let isDraggingTimeline = false;

      videoTimeline.addEventListener("click", onSeekVideo);
      videoTimeline.addEventListener("mousedown", (event) => {
        isDraggingTimeline = true;
        onSeekVideo(event);
      });

      if (documentRef && typeof documentRef.addEventListener === "function") {
        documentRef.addEventListener("mousemove", (event) => {
          if (!isDraggingTimeline) return;
          onSeekVideo(event);
        });

        documentRef.addEventListener("mouseup", () => {
          isDraggingTimeline = false;
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindPrimarySessionButtons(input = {}) {
    const playPauseBtn = input.playPauseBtn || null;
    const prevBtn = input.prevBtn || null;
    const nextBtn = input.nextBtn || null;
    const settingsBtn = input.settingsBtn || null;
    const flipHorizontalBtn = input.flipHorizontalBtn || null;
    const flipVerticalBtn = input.flipVerticalBtn || null;
    const grayscaleBtn = input.grayscaleBtn || null;
    const blurBtn = input.blurBtn || null;
    const annotateBtn = input.annotateBtn || null;
    const progressiveBlurBtn = input.progressiveBlurBtn || null;
    const homeProgressiveBlurBtn = input.homeProgressiveBlurBtn || null;

    const onTogglePlayPause =
      typeof input.onTogglePlayPause === "function"
        ? input.onTogglePlayPause
        : null;
    const onPreviousImage =
      typeof input.onPreviousImage === "function" ? input.onPreviousImage : null;
    const onShowPrevImageMenu =
      typeof input.onShowPrevImageMenu === "function"
        ? input.onShowPrevImageMenu
        : null;
    const onNextImage =
      typeof input.onNextImage === "function" ? input.onNextImage : null;
    const onShowNextImageMenu =
      typeof input.onShowNextImageMenu === "function"
        ? input.onShowNextImageMenu
        : null;
    const onSettingsClick =
      typeof input.onSettingsClick === "function" ? input.onSettingsClick : null;
    const onSettingsContextMenu =
      typeof input.onSettingsContextMenu === "function"
        ? input.onSettingsContextMenu
        : null;
    const onToggleFlipHorizontal =
      typeof input.onToggleFlipHorizontal === "function"
        ? input.onToggleFlipHorizontal
        : null;
    const onToggleFlipVertical =
      typeof input.onToggleFlipVertical === "function"
        ? input.onToggleFlipVertical
        : null;
    const onToggleGrayscale =
      typeof input.onToggleGrayscale === "function"
        ? input.onToggleGrayscale
        : null;
    const onToggleBlur =
      typeof input.onToggleBlur === "function" ? input.onToggleBlur : null;
    const onShowBlurMenu =
      typeof input.onShowBlurMenu === "function" ? input.onShowBlurMenu : null;
    const onToggleAnnotate =
      typeof input.onToggleAnnotate === "function"
        ? input.onToggleAnnotate
        : null;
    const onToggleProgressiveBlur =
      typeof input.onToggleProgressiveBlur === "function"
        ? input.onToggleProgressiveBlur
        : null;
    const onShowProgressiveBlurMenu =
      typeof input.onShowProgressiveBlurMenu === "function"
        ? input.onShowProgressiveBlurMenu
        : null;

    let bound = false;

    if (playPauseBtn && onTogglePlayPause) {
      playPauseBtn.addEventListener("click", onTogglePlayPause);
      bound = true;
    }

    if (prevBtn) {
      if (onPreviousImage) {
        prevBtn.addEventListener("click", onPreviousImage);
      }
      if (onShowPrevImageMenu) {
        prevBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowPrevImageMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (nextBtn) {
      if (onNextImage) {
        nextBtn.addEventListener("click", onNextImage);
      }
      if (onShowNextImageMenu) {
        nextBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowNextImageMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (settingsBtn) {
      if (onSettingsClick) {
        settingsBtn.addEventListener("click", () => {
          void onSettingsClick();
        });
      }
      if (onSettingsContextMenu) {
        settingsBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onSettingsContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (flipHorizontalBtn && onToggleFlipHorizontal) {
      flipHorizontalBtn.addEventListener("click", onToggleFlipHorizontal);
      bound = true;
    }
    if (flipVerticalBtn && onToggleFlipVertical) {
      flipVerticalBtn.addEventListener("click", onToggleFlipVertical);
      bound = true;
    }
    if (grayscaleBtn && onToggleGrayscale) {
      grayscaleBtn.addEventListener("click", onToggleGrayscale);
      bound = true;
    }

    if (blurBtn) {
      if (onToggleBlur) {
        blurBtn.addEventListener("click", onToggleBlur);
      }
      if (onShowBlurMenu) {
        blurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (annotateBtn && onToggleAnnotate) {
      annotateBtn.addEventListener("click", onToggleAnnotate);
      bound = true;
    }

    if (progressiveBlurBtn) {
      if (onToggleProgressiveBlur) {
        progressiveBlurBtn.addEventListener("click", onToggleProgressiveBlur);
      }
      if (onShowProgressiveBlurMenu) {
        progressiveBlurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressiveBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (homeProgressiveBlurBtn) {
      if (onToggleProgressiveBlur) {
        homeProgressiveBlurBtn.addEventListener("click", onToggleProgressiveBlur);
      }
      if (onShowProgressiveBlurMenu) {
        homeProgressiveBlurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressiveBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindSessionEntryAndModeControls(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const startBtn = input.startBtn || null;
    const chooseMediaFolderBtn = input.chooseMediaFolderBtn || null;
    const stopBtn = input.stopBtn || null;
    const closeReviewBtn = input.closeReviewBtn || null;
    const customAddBtn = input.customAddBtn || null;
    const addPauseBtn = input.addPauseBtn || null;
    const customInputs = toElementArray(input.customInputs);

    const onStartSession =
      typeof input.onStartSession === "function" ? input.onStartSession : null;
    const onChooseMediaFolder =
      typeof input.onChooseMediaFolder === "function"
        ? input.onChooseMediaFolder
        : null;
    const onShowReview =
      typeof input.onShowReview === "function" ? input.onShowReview : null;
    const onCloseReview =
      typeof input.onCloseReview === "function" ? input.onCloseReview : null;
    const onSwitchMode =
      typeof input.onSwitchMode === "function" ? input.onSwitchMode : null;
    const onAddCustomStep =
      typeof input.onAddCustomStep === "function" ? input.onAddCustomStep : null;
    const onAddCustomPause =
      typeof input.onAddCustomPause === "function" ? input.onAddCustomPause : null;

    let bound = false;

    if (startBtn && onStartSession) {
      startBtn.addEventListener("click", onStartSession);
      bound = true;
    }

    if (chooseMediaFolderBtn && onChooseMediaFolder) {
      chooseMediaFolderBtn.addEventListener("click", () => {
        void onChooseMediaFolder();
      });
      bound = true;
    }

    if (stopBtn && onShowReview) {
      stopBtn.addEventListener("click", onShowReview);
      bound = true;
    }

    if (closeReviewBtn && onCloseReview) {
      closeReviewBtn.addEventListener("click", onCloseReview);
      bound = true;
    }

    if (documentRef && onSwitchMode) {
      documentRef.querySelectorAll(".mode-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          onSwitchMode(btn.dataset.mode);
        });
      });
      bound = true;
    }

    if (customAddBtn && onAddCustomStep) {
      customAddBtn.onclick = (event) => {
        event.preventDefault();
        onAddCustomStep();
      };
      bound = true;
    }

    if (addPauseBtn && onAddCustomPause) {
      addPauseBtn.onclick = (event) => {
        event.preventDefault();
        onAddCustomPause();
      };
      bound = true;
    }

    if (onAddCustomStep) {
      customInputs.forEach((inputEl) => {
        if (!inputEl || typeof inputEl.addEventListener !== "function") return;
        inputEl.addEventListener("keydown", (event) => {
          if (event.key !== "Enter") return;
          event.preventDefault();
          onAddCustomStep();
        });
      });
      bound = bound || customInputs.length > 0;
    }

    return bound;
  }

  function bindGlobalSettingsControls(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const globalSettingsModal = input.globalSettingsModal || null;
    const closeGlobalSettingsModalBtn = input.closeGlobalSettingsModalBtn || null;
    const globalSettingsToggleGridBtn = input.globalSettingsToggleGridBtn || null;
    const globalSettingsToggleThemeBtn = input.globalSettingsToggleThemeBtn || null;
    const globalSettingsOpenHotkeysBtn = input.globalSettingsOpenHotkeysBtn || null;
    const globalSettingsTitlebarAlwaysVisibleInput =
      input.globalSettingsTitlebarAlwaysVisibleInput || null;
    const globalSettingsLanguageSelect = input.globalSettingsLanguageSelect || null;
    const globalSettingsDefaultModeGroup = input.globalSettingsDefaultModeGroup || null;

    const onCloseGlobalSettingsModal =
      typeof input.onCloseGlobalSettingsModal === "function"
        ? input.onCloseGlobalSettingsModal
        : null;
    const onToggleGrid =
      typeof input.onToggleGrid === "function" ? input.onToggleGrid : null;
    const onToggleTheme =
      typeof input.onToggleTheme === "function" ? input.onToggleTheme : null;
    const onOpenHotkeys =
      typeof input.onOpenHotkeys === "function" ? input.onOpenHotkeys : null;
    const onTitlebarAlwaysVisibleChanged =
      typeof input.onTitlebarAlwaysVisibleChanged === "function"
        ? input.onTitlebarAlwaysVisibleChanged
        : null;
    const onLanguageSelected =
      typeof input.onLanguageSelected === "function"
        ? input.onLanguageSelected
        : null;
    const onDefaultModeSelected =
      typeof input.onDefaultModeSelected === "function"
        ? input.onDefaultModeSelected
        : null;

    let bound = false;

    if (closeGlobalSettingsModalBtn && onCloseGlobalSettingsModal) {
      closeGlobalSettingsModalBtn.addEventListener("click", () => {
        onCloseGlobalSettingsModal();
      });
      bound = true;
    }

    if (globalSettingsModal && onCloseGlobalSettingsModal) {
      globalSettingsModal.addEventListener("click", (event) => {
        if (event.target !== globalSettingsModal) return;
        onCloseGlobalSettingsModal();
      });
      bound = true;
    }

    if (globalSettingsToggleGridBtn && onToggleGrid) {
      const isCheckboxControl =
        globalSettingsToggleGridBtn.tagName === "INPUT" &&
        String(globalSettingsToggleGridBtn.type || "").toLowerCase() ===
          "checkbox";
      const eventName = isCheckboxControl ? "change" : "click";
      globalSettingsToggleGridBtn.addEventListener(eventName, () => {
        onToggleGrid({
          isCheckboxControl,
          checked: !!globalSettingsToggleGridBtn.checked,
        });
      });
      bound = true;
    }

    if (globalSettingsToggleThemeBtn && onToggleTheme) {
      globalSettingsToggleThemeBtn.addEventListener("click", onToggleTheme);
      bound = true;
    }

    if (globalSettingsOpenHotkeysBtn && onOpenHotkeys) {
      globalSettingsOpenHotkeysBtn.addEventListener("click", onOpenHotkeys);
      bound = true;
    }

    if (
      globalSettingsTitlebarAlwaysVisibleInput &&
      onTitlebarAlwaysVisibleChanged
    ) {
      globalSettingsTitlebarAlwaysVisibleInput.addEventListener("change", () => {
        onTitlebarAlwaysVisibleChanged(
          !!globalSettingsTitlebarAlwaysVisibleInput.checked,
        );
      });
      bound = true;
    }

    if (globalSettingsLanguageSelect && onLanguageSelected) {
      const isNativeSelect =
        globalSettingsLanguageSelect.tagName === "SELECT" &&
        typeof globalSettingsLanguageSelect.addEventListener === "function";

      if (isNativeSelect) {
        globalSettingsLanguageSelect.addEventListener("change", () => {
          onLanguageSelected(globalSettingsLanguageSelect.value);
        });
        bound = true;
      } else {
        const languageTrigger = globalSettingsLanguageSelect.querySelector(
          ".global-settings-language-trigger",
        );
        const languageMenu = globalSettingsLanguageSelect.querySelector(
          ".global-settings-language-menu",
        );
        const languageOptions = Array.from(
          globalSettingsLanguageSelect.querySelectorAll(
            ".global-settings-language-option[data-lang]",
          ),
        );

        const closeLanguageMenu = () => {
          if (!languageMenu) return;
          languageMenu.hidden = true;
          globalSettingsLanguageSelect.classList.remove("is-open");
          if (languageTrigger) {
            languageTrigger.setAttribute("aria-expanded", "false");
          }
        };

        const openLanguageMenu = () => {
          if (!languageMenu || languageOptions.length === 0) return;
          languageMenu.hidden = false;
          globalSettingsLanguageSelect.classList.add("is-open");
          if (languageTrigger) {
            languageTrigger.setAttribute("aria-expanded", "true");
          }
        };

        const toggleLanguageMenu = () => {
          if (!languageMenu) return;
          if (languageMenu.hidden) {
            openLanguageMenu();
          } else {
            closeLanguageMenu();
          }
        };

        if (languageTrigger) {
          languageTrigger.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleLanguageMenu();
          });
          languageTrigger.addEventListener("keydown", (event) => {
            if (
              event.key === "Enter" ||
              event.key === " " ||
              event.key === "ArrowDown"
            ) {
              event.preventDefault();
              openLanguageMenu();
            }
          });
          bound = true;
        }

        languageOptions.forEach((optionEl) => {
          optionEl.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            const nextLanguage = String(optionEl.dataset.lang || "").trim();
            if (!nextLanguage) return;
            globalSettingsLanguageSelect.dataset.value = nextLanguage;
            closeLanguageMenu();
            onLanguageSelected(nextLanguage);
          });
          optionEl.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              event.preventDefault();
              closeLanguageMenu();
              if (languageTrigger && typeof languageTrigger.focus === "function") {
                languageTrigger.focus();
              }
              return;
            }
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              const nextLanguage = String(optionEl.dataset.lang || "").trim();
              if (!nextLanguage) return;
              globalSettingsLanguageSelect.dataset.value = nextLanguage;
              closeLanguageMenu();
              onLanguageSelected(nextLanguage);
            }
          });
        });
        bound = bound || languageOptions.length > 0;

        if (documentRef && typeof documentRef.addEventListener === "function") {
          documentRef.addEventListener("click", (event) => {
            if (!globalSettingsLanguageSelect.contains(event.target)) {
              closeLanguageMenu();
            }
          });
          documentRef.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              closeLanguageMenu();
            }
          });
          bound = true;
        }
      }
    }

    if (globalSettingsDefaultModeGroup && onDefaultModeSelected) {
      globalSettingsDefaultModeGroup.addEventListener("click", (event) => {
        const modeBtn = event.target.closest(".search-toggle-btn[data-mode]");
        if (!modeBtn || !globalSettingsDefaultModeGroup.contains(modeBtn)) return;
        onDefaultModeSelected(modeBtn.dataset.mode);
      });
      bound = true;
    }

    return bound;
  }

  function bindGlobalSettingsActionButtons(input = {}) {
    const globalResetSettingsBtn = input.globalResetSettingsBtn || null;
    const globalSettingsExportPrefsBtn = input.globalSettingsExportPrefsBtn || null;
    const globalSettingsImportPrefsBtn = input.globalSettingsImportPrefsBtn || null;
    const globalSettingsRepairStorageBtn = input.globalSettingsRepairStorageBtn || null;

    const onResetSettings =
      typeof input.onResetSettings === "function" ? input.onResetSettings : null;
    const onExportPreferences =
      typeof input.onExportPreferences === "function"
        ? input.onExportPreferences
        : null;
    const onImportPreferences =
      typeof input.onImportPreferences === "function"
        ? input.onImportPreferences
        : null;
    const onRepairStorage =
      typeof input.onRepairStorage === "function" ? input.onRepairStorage : null;

    let bound = false;

    if (globalResetSettingsBtn && onResetSettings) {
      globalResetSettingsBtn.addEventListener("click", async () => {
        await onResetSettings();
      });
      bound = true;
    }

    if (globalSettingsExportPrefsBtn && onExportPreferences) {
      globalSettingsExportPrefsBtn.addEventListener("click", async () => {
        await onExportPreferences();
      });
      bound = true;
    }

    if (globalSettingsImportPrefsBtn && onImportPreferences) {
      globalSettingsImportPrefsBtn.addEventListener("click", async () => {
        await onImportPreferences();
      });
      bound = true;
    }

    if (globalSettingsRepairStorageBtn && onRepairStorage) {
      globalSettingsRepairStorageBtn.addEventListener("click", async () => {
        await onRepairStorage();
      });
      bound = true;
    }

    return bound;
  }

  function bindClassicDurationButtons(input = {}) {
    const durationBtns = toElementArray(input.durationBtns);
    const hoursInput = input.hoursInput || null;
    const minutesInput = input.minutesInput || null;
    const secondsInput = input.secondsInput || null;
    const domInputGroups = toElementArray(input.domInputGroups);
    const state = input.state || {};
    const getDurationFromButton =
      typeof input.getDurationFromButton === "function"
        ? input.getDurationFromButton
        : null;
    const onToggleDurationButtonsForValue =
      typeof input.onToggleDurationButtonsForValue === "function"
        ? input.onToggleDurationButtonsForValue
        : null;

    if (
      durationBtns.length === 0 ||
      !getDurationFromButton ||
      !onToggleDurationButtonsForValue
    ) {
      return false;
    }

    durationBtns.forEach((btn) => {
      if (!btn || typeof btn.addEventListener !== "function") return;
      btn.addEventListener("click", () => {
        const durationValue = getDurationFromButton(btn);
        onToggleDurationButtonsForValue(durationBtns, durationValue);
        state.selectedDuration = durationValue;
        if (hoursInput) hoursInput.value = 0;
        if (minutesInput) minutesInput.value = 0;
        if (secondsInput) secondsInput.value = 0;
        domInputGroups.forEach((group) => {
          if (group && group.classList) {
            group.classList.remove("active");
          }
        });
      });
    });

    return true;
  }

  function bindMemoryTypeSwitchButtons(input = {}) {
    const memoryTypeBtns = toElementArray(input.memoryTypeBtns);
    const memoryFlashSettings = input.memoryFlashSettings || null;
    const memoryProgressiveSettings = input.memoryProgressiveSettings || null;
    const state = input.state || {};

    if (memoryTypeBtns.length === 0) return false;

    memoryTypeBtns.forEach((btn) => {
      if (!btn || typeof btn.addEventListener !== "function") return;
      btn.addEventListener("click", () => {
        const memoryType = btn.dataset.memoryType;
        state.memoryType = memoryType;

        memoryTypeBtns.forEach((item) => item.classList.remove("active"));
        btn.classList.add("active");

        if (!memoryFlashSettings || !memoryProgressiveSettings) return;
        if (memoryType === "flash") {
          memoryFlashSettings.style.display = "block";
          memoryProgressiveSettings.style.display = "none";
        } else {
          memoryFlashSettings.style.display = "none";
          memoryProgressiveSettings.style.display = "block";
        }
      });
    });

    return true;
  }

  function bindMemoryDurationControls(input = {}) {
    const memoryFlashBtns = toElementArray(input.memoryFlashBtns);
    const memoryProgressiveBtns = toElementArray(input.memoryProgressiveBtns);
    const memoryProgressiveMinutes = input.memoryProgressiveMinutes || null;
    const memoryProgressiveSeconds = input.memoryProgressiveSeconds || null;
    const memoryProgressiveCustomTime = input.memoryProgressiveCustomTime || null;
    const memoryFlashMinutes = input.memoryFlashMinutes || null;
    const memoryFlashSeconds = input.memoryFlashSeconds || null;
    const memoryCustomTime = input.memoryCustomTime || null;
    const memoryDrawingTimeInput = input.memoryDrawingTimeInput || null;
    const state = input.state || {};

    const getDurationFromButton =
      typeof input.getDurationFromButton === "function"
        ? input.getDurationFromButton
        : null;
    const onToggleDurationButtonsForValue =
      typeof input.onToggleDurationButtonsForValue === "function"
        ? input.onToggleDurationButtonsForValue
        : null;
    const onClearDurationButtonsActive =
      typeof input.onClearDurationButtonsActive === "function"
        ? input.onClearDurationButtonsActive
        : null;
    const onReadMinutesSecondsInputValues =
      typeof input.onReadMinutesSecondsInputValues === "function"
        ? input.onReadMinutesSecondsInputValues
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;

    let bound = false;

    if (
      memoryFlashBtns.length > 0 &&
      getDurationFromButton &&
      onToggleDurationButtonsForValue
    ) {
      memoryFlashBtns.forEach((btn) => {
        if (!btn || typeof btn.addEventListener !== "function") return;
        btn.addEventListener("click", () => {
          const durationValue = getDurationFromButton(btn);
          onToggleDurationButtonsForValue(memoryFlashBtns, durationValue);
          state.memoryDuration = durationValue;

          if (memoryCustomTime) {
            memoryCustomTime.classList.remove("active");
          }
          if (memoryFlashMinutes) memoryFlashMinutes.value = 0;
          if (memoryFlashSeconds) memoryFlashSeconds.value = 0;
          if (onUpdateMemoryTotalDuration) {
            onUpdateMemoryTotalDuration();
          }
          if (state.memoryDrawingTime > 0 && memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.add("active");
          }
        });
      });
      bound = true;
    }

    if (
      memoryProgressiveBtns.length > 0 &&
      getDurationFromButton &&
      onToggleDurationButtonsForValue
    ) {
      memoryProgressiveBtns.forEach((btn) => {
        if (!btn || typeof btn.addEventListener !== "function") return;
        btn.addEventListener("click", () => {
          const durationValue = getDurationFromButton(btn);
          onToggleDurationButtonsForValue(memoryProgressiveBtns, durationValue);
          state.selectedDuration = durationValue;
          if (memoryProgressiveCustomTime) {
            memoryProgressiveCustomTime.classList.remove("active");
          }
          if (memoryProgressiveMinutes) memoryProgressiveMinutes.value = 0;
          if (memoryProgressiveSeconds) memoryProgressiveSeconds.value = 0;
        });
      });
      bound = true;
    }

    if (
      memoryProgressiveMinutes &&
      memoryProgressiveSeconds &&
      onReadMinutesSecondsInputValues
    ) {
      const updateMemoryProgressiveDuration = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryProgressiveMinutes,
          memoryProgressiveSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (onClearDurationButtonsActive) {
            onClearDurationButtonsActive(memoryProgressiveBtns);
          }
          if (memoryProgressiveCustomTime) {
            memoryProgressiveCustomTime.classList.add("active");
          }
          state.selectedDuration = totalSeconds;
        } else if (memoryProgressiveCustomTime) {
          memoryProgressiveCustomTime.classList.remove("active");
        }
      };

      memoryProgressiveMinutes.addEventListener(
        "input",
        updateMemoryProgressiveDuration,
      );
      memoryProgressiveSeconds.addEventListener(
        "input",
        updateMemoryProgressiveDuration,
      );
      bound = true;
    }

    if (memoryFlashMinutes && memoryFlashSeconds && onReadMinutesSecondsInputValues) {
      const updateMemoryDuration = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryFlashMinutes,
          memoryFlashSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (onClearDurationButtonsActive) {
            onClearDurationButtonsActive(memoryFlashBtns);
          }
          if (memoryCustomTime) {
            memoryCustomTime.classList.add("active");
          }
          state.memoryDuration = totalSeconds;
        } else if (memoryCustomTime) {
          memoryCustomTime.classList.remove("active");
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      };

      memoryFlashMinutes.addEventListener("input", updateMemoryDuration);
      memoryFlashSeconds.addEventListener("input", updateMemoryDuration);
      bound = true;
    }

    return bound;
  }

  function bindMemoryDrawingTimeControls(input = {}) {
    const memoryDrawingMinutes = input.memoryDrawingMinutes || null;
    const memoryDrawingSeconds = input.memoryDrawingSeconds || null;
    const memoryDrawingTimeInput = input.memoryDrawingTimeInput || null;
    const noPressureBtn = input.noPressureBtn || null;
    const state = input.state || {};

    const onReadMinutesSecondsInputValues =
      typeof input.onReadMinutesSecondsInputValues === "function"
        ? input.onReadMinutesSecondsInputValues
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;

    let bound = false;

    if (
      memoryDrawingMinutes &&
      memoryDrawingSeconds &&
      onReadMinutesSecondsInputValues
    ) {
      const updateMemoryDrawingTime = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryDrawingMinutes,
          memoryDrawingSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.add("active");
          }
          if (noPressureBtn) {
            noPressureBtn.classList.remove("active");
          }
          state.memoryDrawingTime = totalSeconds;
          state.memoryNoPressure = false;
        } else {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.remove("active");
          }
          state.memoryDrawingTime = 0;
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      };

      memoryDrawingMinutes.addEventListener("input", updateMemoryDrawingTime);
      memoryDrawingSeconds.addEventListener("input", updateMemoryDrawingTime);
      bound = true;
    }

    if (noPressureBtn) {
      noPressureBtn.addEventListener("click", () => {
        const isActive = noPressureBtn.classList.toggle("active");
        if (isActive) {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.remove("active");
          }
          if (memoryDrawingMinutes) memoryDrawingMinutes.value = 0;
          if (memoryDrawingSeconds) memoryDrawingSeconds.value = 0;
          state.memoryDrawingTime = 0;
          state.memoryNoPressure = true;
        } else {
          state.memoryNoPressure = false;
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      });
      bound = true;
    }

    return bound;
  }

  function makeEditableNumericValue(input = {}) {
    const valueElement = input.valueElement || null;
    const sliderElement = input.sliderElement || null;
    const onUpdate =
      typeof input.onUpdate === "function" ? input.onUpdate : null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    if (!valueElement || !sliderElement || !documentRef) return false;

    const currentValue = parseInt(valueElement.textContent, 10);
    const min = parseInt(sliderElement.min, 10);
    const max = parseInt(sliderElement.max, 10);

    const editInput = documentRef.createElement("input");
    editInput.type = "number";
    editInput.min = min;
    editInput.max = max;
    editInput.value = Number.isFinite(currentValue) ? currentValue : min;
    editInput.style.cssText = `
      width: 50px;
      padding: 2px 4px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--color-primary);
      border-radius: 4px;
      color: var(--color-primary);
      font-weight: bold;
      font-size: inherit;
      text-align: center;
    `;

    const validateAndRestore = () => {
      let newValue = parseInt(editInput.value, 10);
      if (Number.isNaN(newValue) || newValue < min) {
        newValue = min;
      } else if (newValue > max) {
        newValue = max;
      }
      sliderElement.value = newValue;
      valueElement.textContent = newValue;
      valueElement.style.display = "";
      if (onUpdate) {
        onUpdate(newValue);
      }
      editInput.remove();
    };

    valueElement.style.display = "none";
    valueElement.parentElement.appendChild(editInput);
    editInput.focus();
    editInput.select();

    editInput.addEventListener("blur", validateAndRestore);
    editInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        validateAndRestore();
      } else if (event.key === "Escape") {
        event.preventDefault();
        valueElement.style.display = "";
        editInput.remove();
      }
    });

    return true;
  }

  function bindMemoryPoseSliders(input = {}) {
    const memoryPosesSlider = input.memoryPosesSlider || null;
    const memoryPosesValue = input.memoryPosesValue || null;
    const memoryProgressivePosesSlider = input.memoryProgressivePosesSlider || null;
    const memoryProgressivePosesValue = input.memoryProgressivePosesValue || null;
    const state = input.state || {};
    const clickToEnterLabel = input.clickToEnterLabel || "";

    const onInitSliderWithGradient =
      typeof input.onInitSliderWithGradient === "function"
        ? input.onInitSliderWithGradient
        : null;
    const onUpdateSliderGradient =
      typeof input.onUpdateSliderGradient === "function"
        ? input.onUpdateSliderGradient
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);

    let bound = false;

    if (memoryPosesSlider && memoryPosesValue) {
      if (onInitSliderWithGradient) {
        onInitSliderWithGradient(memoryPosesSlider);
      }

      memoryPosesSlider.addEventListener("input", (event) => {
        const value = parseInt(event.target.value, 10);
        state.memoryPosesCount = value;
        memoryPosesValue.textContent = value;
        if (onUpdateSliderGradient) {
          onUpdateSliderGradient(memoryPosesSlider);
        }
        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      });

      memoryPosesValue.style.cursor = "pointer";
      if (clickToEnterLabel) {
        memoryPosesValue.title = clickToEnterLabel;
      }
      memoryPosesValue.addEventListener("click", () => {
        makeEditableNumericValue({
          valueElement: memoryPosesValue,
          sliderElement: memoryPosesSlider,
          documentRef,
          onUpdate: (newValue) => {
            state.memoryPosesCount = newValue;
            if (onUpdateSliderGradient) {
              onUpdateSliderGradient(memoryPosesSlider);
            }
            if (onUpdateMemoryTotalDuration) {
              onUpdateMemoryTotalDuration();
            }
          },
        });
      });
      bound = true;
    }

    if (memoryProgressivePosesSlider && memoryProgressivePosesValue) {
      if (onInitSliderWithGradient) {
        onInitSliderWithGradient(memoryProgressivePosesSlider);
      }

      memoryProgressivePosesSlider.addEventListener("input", (event) => {
        const value = parseInt(event.target.value, 10);
        state.memoryPosesCount = value;
        memoryProgressivePosesValue.textContent = value;
        if (onUpdateSliderGradient) {
          onUpdateSliderGradient(memoryProgressivePosesSlider);
        }
      });

      memoryProgressivePosesValue.style.cursor = "pointer";
      if (clickToEnterLabel) {
        memoryProgressivePosesValue.title = clickToEnterLabel;
      }
      memoryProgressivePosesValue.addEventListener("click", () => {
        makeEditableNumericValue({
          valueElement: memoryProgressivePosesValue,
          sliderElement: memoryProgressivePosesSlider,
          documentRef,
          onUpdate: (newValue) => {
            state.memoryPosesCount = newValue;
            if (onUpdateSliderGradient) {
              onUpdateSliderGradient(memoryProgressivePosesSlider);
            }
          },
        });
      });
      bound = true;
    }

    return bound;
  }

  function bindCustomHmsTimerInputs(input = {}) {
    const inputs = toElementArray(input.inputs);
    const state = input.state || {};
    const domDurationButtons = toElementArray(input.domDurationButtons);
    const domInputGroups = toElementArray(input.domInputGroups);

    const onReadHmsInputValues =
      typeof input.onReadHmsInputValues === "function"
        ? input.onReadHmsInputValues
        : null;
    const onClearDurationButtonsActive =
      typeof input.onClearDurationButtonsActive === "function"
        ? input.onClearDurationButtonsActive
        : null;
    const onUpdateTimerDisplay =
      typeof input.onUpdateTimerDisplay === "function"
        ? input.onUpdateTimerDisplay
        : null;
    const createDebounce =
      typeof input.createDebounce === "function" ? input.createDebounce : null;
    const debounceMs = Number(input.debounceMs || 50);

    if (!onReadHmsInputValues || inputs.length === 0) return false;

    const handler = () => {
      const result = onReadHmsInputValues();
      const totalCustom = Number(result?.totalSeconds || 0);
      if (totalCustom > 0) {
        if (onClearDurationButtonsActive) {
          onClearDurationButtonsActive(domDurationButtons);
        }
        domInputGroups.forEach((group) => {
          if (group && group.classList) {
            group.classList.add("active");
          }
        });
        state.selectedDuration = totalCustom;
      }
      state.timeRemaining = state.selectedDuration;
      if (onUpdateTimerDisplay) {
        onUpdateTimerDisplay();
      }
    };

    const debouncedHandler = createDebounce
      ? createDebounce(handler, debounceMs)
      : handler;

    inputs.forEach((inputEl) => {
      if (!inputEl || typeof inputEl.addEventListener !== "function") return;
      inputEl.addEventListener("input", debouncedHandler);
    });

    return true;
  }

  function bindSessionPlansModalBasics(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const managePlansBtn = input.managePlansBtn || null;
    const closePlansModal = input.closePlansModal || null;
    const sessionPlansModal = input.sessionPlansModal || null;
    const onOpen = typeof input.onOpen === "function" ? input.onOpen : null;
    const onClose = typeof input.onClose === "function" ? input.onClose : null;

    if (!sessionPlansModal) return false;

    const escapeHandler = (event) => {
      if (
        event.key === "Escape" &&
        !sessionPlansModal.classList.contains("hidden")
      ) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (onClose) {
          onClose("escape");
        }
        if (documentRef) {
          documentRef.removeEventListener("keydown", escapeHandler, true);
        }
      }
    };

    if (managePlansBtn) {
      managePlansBtn.addEventListener("click", async () => {
        if (onOpen) {
          await onOpen();
        }
        if (documentRef) {
          documentRef.addEventListener("keydown", escapeHandler, true);
        }
      });
    }

    if (closePlansModal) {
      closePlansModal.addEventListener("click", () => {
        if (onClose) {
          onClose("button");
        }
        if (documentRef) {
          documentRef.removeEventListener("keydown", escapeHandler, true);
        }
      });
    }

    sessionPlansModal.addEventListener("click", (event) => {
      if (event.target !== sessionPlansModal) return;
      if (onClose) {
        onClose("overlay");
      }
    });

    return true;
  }

  function bindSessionPlansCrudControls(input = {}) {
    const savePlanBtn = input.savePlanBtn || null;
    const savedPlansList = input.savedPlansList || null;
    const onSavePlan =
      typeof input.onSavePlan === "function" ? input.onSavePlan : null;
    const onSavedPlansClick =
      typeof input.onSavedPlansClick === "function"
        ? input.onSavedPlansClick
        : null;

    let bound = false;

    if (savePlanBtn && onSavePlan) {
      savePlanBtn.addEventListener("click", async () => {
        await onSavePlan();
      });
      bound = true;
    }

    if (savedPlansList && onSavedPlansClick) {
      savedPlansList.addEventListener("click", async (event) => {
        await onSavedPlansClick(event);
      });
      bound = true;
    }

    return bound;
  }

  function resolveMemoryTotalDurationDisplay(input = {}) {
    const state = input.state || {};
    const calculateTotalSeconds =
      typeof input.calculateTotalSeconds === "function"
        ? input.calculateTotalSeconds
        : null;

    if (state.memoryNoPressure) {
      return { visible: false, text: "" };
    }

    if (!state.memoryDrawingTime || state.memoryDrawingTime === 0) {
      return { visible: false, text: "" };
    }

    if (!calculateTotalSeconds) {
      return { visible: false, text: "" };
    }

    const posesCount = state.memoryPosesCount || 10;
    const drawingTime = state.memoryDrawingTime || 0;
    const displayTime = state.memoryDuration || 0;
    const totalSeconds = Number(
      calculateTotalSeconds(posesCount, drawingTime, displayTime),
    );

    const safeSeconds = Number.isFinite(totalSeconds)
      ? Math.max(0, Math.floor(totalSeconds))
      : 0;
    const hours = Math.floor(safeSeconds / 3600);
    const minutes = Math.floor((safeSeconds % 3600) / 60);
    const seconds = safeSeconds % 60;

    let formattedTime = "";
    if (hours > 0) {
      formattedTime += `${hours}h `;
    }
    if (minutes > 0 || hours > 0) {
      formattedTime += `${minutes}min `;
    }
    formattedTime += `${seconds}s`;

    return {
      visible: true,
      text: formattedTime.trim(),
      totalSeconds: safeSeconds,
    };
  }

  function createSessionControlsBindingsUtils() {
    return {
      bindMemoryOverlayButtons,
      bindShuffleAndAutoFlipButtons,
      bindTimerControlsAndProgress,
      bindVideoScrubbing,
      bindVideoControls,
      bindPrimarySessionButtons,
      bindSessionEntryAndModeControls,
      bindGlobalSettingsControls,
      bindGlobalSettingsActionButtons,
      bindClassicDurationButtons,
      bindMemoryTypeSwitchButtons,
      bindMemoryDurationControls,
      bindMemoryDrawingTimeControls,
      makeEditableNumericValue,
      bindMemoryPoseSliders,
      bindCustomHmsTimerInputs,
      bindSessionPlansModalBasics,
      bindSessionPlansCrudControls,
      resolveMemoryTotalDurationDisplay,
    };
  }

  sharedRoot.createSessionControlsBindingsUtils = createSessionControlsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-surface-interactions-bindings-utils.js ===== */
(function initPoseChronoSharedSessionSurfaceInteractionsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindSessionSurfaceInteractions(input = {}) {
    const documentRef = input.documentRef || null;
    const currentImage = input.currentImage || null;
    const memoryOverlay = input.memoryOverlay || null;
    const state = input.state || null;
    const onToggleSidebar =
      typeof input.onToggleSidebar === "function" ? input.onToggleSidebar : null;
    const onNextImage =
      typeof input.onNextImage === "function" ? input.onNextImage : null;

    let bound = false;

    if (currentImage && typeof currentImage.addEventListener === "function" && onToggleSidebar) {
      currentImage.addEventListener("click", () => {
        if (!documentRef) {
          onToggleSidebar();
          return;
        }
        const gridPopup = documentRef.getElementById("grid-config-popup");
        const silhouettePopup = documentRef.getElementById(
          "silhouette-config-popup",
        );
        if (gridPopup || silhouettePopup) return;
        onToggleSidebar();
      });
      bound = true;
    }

    if (memoryOverlay && typeof memoryOverlay.addEventListener === "function" && state && onNextImage) {
      memoryOverlay.addEventListener("click", (event) => {
        if (event?.target && typeof event.target.closest === "function") {
          if (event.target.closest(".memory-overlay-btn")) return;
        }
        if (
          state.sessionMode === "memory" &&
          state.memoryHidden &&
          state.memoryNoPressure
        ) {
          onNextImage();
        }
      });
      bound = true;
    }

    return bound;
  }

  function createSessionSurfaceInteractionsBindingsUtils() {
    return {
      bindSessionSurfaceInteractions,
    };
  }

  sharedRoot.createSessionSurfaceInteractionsBindingsUtils =
    createSessionSurfaceInteractionsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/custom-session-utils.js ===== */
(function initPoseChronoSharedCustomSessionUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function toPositiveInt(value, fallback = 0) {
    return Math.max(0, toInt(value, fallback));
  }

  function isPoseStep(step) {
    return !!step && typeof step === "object" && step.type === "pose";
  }

  function findNextPoseStepIndex(queue, fromIndex) {
    if (!Array.isArray(queue)) return -1;
    const start = Math.max(-1, toInt(fromIndex, -1));
    for (let i = start + 1; i < queue.length; i++) {
      if (isPoseStep(queue[i])) return i;
    }
    return -1;
  }

  function findPrevPoseStepIndex(queue, fromIndex) {
    if (!Array.isArray(queue)) return -1;
    const start = Math.min(queue.length, toInt(fromIndex, queue.length));
    for (let i = start - 1; i >= 0; i--) {
      if (isPoseStep(queue[i])) return i;
    }
    return -1;
  }

  function findNextPoseStep(queue, fromIndex) {
    const idx = findNextPoseStepIndex(queue, fromIndex);
    return idx >= 0 ? queue[idx] : null;
  }

  function hasNextPoseGroup(queue, fromIndex) {
    return findNextPoseStepIndex(queue, fromIndex) >= 0;
  }

  function hasPrevPoseGroup(queue, fromIndex) {
    return findPrevPoseStepIndex(queue, fromIndex) >= 0;
  }

  function getCustomPoseSessionProgress(queue, currentStepIndex, currentPoseInStep) {
    if (!Array.isArray(queue) || queue.length === 0) {
      return {
        totalPoses: 0,
        globalPoseIndex: 0,
        poseGroupCount: 0,
        showGlobal: false,
      };
    }

    const stepIndex = toInt(currentStepIndex, 0);
    const poseInStep = Math.max(1, toInt(currentPoseInStep, 1));
    let totalPoses = 0;
    let poseGroupCount = 0;
    let globalPoseIndex = 0;

    for (let i = 0; i < queue.length; i++) {
      const step = queue[i];
      if (!isPoseStep(step)) continue;
      const count = Math.max(1, toInt(step.count, 1));
      poseGroupCount += 1;
      totalPoses += count;
      if (i < stepIndex) {
        globalPoseIndex += count;
      }
    }

    const current = queue[stepIndex];
    if (isPoseStep(current)) {
      const currentCount = Math.max(1, toInt(current.count, 1));
      globalPoseIndex += Math.min(currentCount, Math.max(1, poseInStep));
    } else if (totalPoses > 0 && globalPoseIndex <= 0) {
      globalPoseIndex = 1;
    }

    return {
      totalPoses,
      globalPoseIndex: Math.min(Math.max(globalPoseIndex, 0), totalPoses),
      poseGroupCount,
      showGlobal: poseGroupCount > 1,
    };
  }

  function calculateCustomTotalRemainingSeconds(
    queue,
    currentStepIndex,
    currentPoseInStep,
    timeRemaining,
  ) {
    const totalNow = toPositiveInt(timeRemaining, 0);
    if (!Array.isArray(queue) || queue.length === 0) return totalNow;

    const stepIndex = toInt(currentStepIndex, 0);
    const poseInStep = Math.max(1, toInt(currentPoseInStep, 1));
    let total = totalNow;

    for (let i = stepIndex + 1; i < queue.length; i++) {
      const step = queue[i];
      if (!step || typeof step !== "object") continue;
      const duration = toPositiveInt(step.duration, 0);
      if (step.type === "pause") {
        total += duration;
      } else {
        const count = Math.max(1, toInt(step.count, 1));
        total += duration * count;
      }
    }

    const current = queue[stepIndex];
    if (isPoseStep(current)) {
      const duration = toPositiveInt(current.duration, 0);
      const count = Math.max(1, toInt(current.count, 1));
      const posesRemaining = Math.max(0, count - poseInStep);
      total += posesRemaining * duration;
    }

    return total;
  }

  function getStepTotalSeconds(step) {
    if (!step || typeof step !== "object") return 0;
    const duration = toPositiveInt(step.duration, 0);
    if (step.type === "pause") return duration;
    const count = Math.max(1, toInt(step.count, 1));
    return duration * count;
  }

  function calculateQueueTotalSeconds(queue) {
    if (!Array.isArray(queue) || queue.length === 0) return 0;
    return queue.reduce((total, step) => total + getStepTotalSeconds(step), 0);
  }

  function stepDurationToHms(duration) {
    const safe = Math.max(0, toInt(duration, 0));
    return {
      hours: Math.floor(safe / 3600),
      minutes: Math.floor((safe % 3600) / 60),
      seconds: safe % 60,
    };
  }

  function updateStepDurationFromUnit(step, type, value, minDuration = 1) {
    if (!step || typeof step !== "object") {
      return { updated: false, duration: 0 };
    }
    const safeType = String(type || "").toLowerCase();
    if (safeType !== "h" && safeType !== "m" && safeType !== "s") {
      return { updated: false, duration: toPositiveInt(step.duration, 0) };
    }

    const parts = stepDurationToHms(step.duration);
    const nextValue = Math.max(0, toInt(value, 0));

    if (safeType === "h") parts.hours = nextValue;
    if (safeType === "m") parts.minutes = nextValue;
    if (safeType === "s") parts.seconds = nextValue;

    const rawDuration =
      parts.hours * 3600 + parts.minutes * 60 + parts.seconds;
    const boundedDuration = Math.max(
      Math.max(0, toInt(minDuration, 1)),
      rawDuration,
    );
    step.duration = boundedDuration;
    return {
      updated: true,
      duration: boundedDuration,
      parts: {
        hours: parts.hours,
        minutes: parts.minutes,
        seconds: parts.seconds,
      },
    };
  }

  function updateStepPositiveIntField(step, field, value, minValue = 1) {
    if (!step || typeof step !== "object") {
      return { updated: false, value: 0 };
    }
    const safeField = String(field || "").trim();
    if (!safeField) {
      return { updated: false, value: 0 };
    }

    const min = Math.max(0, toInt(minValue, 1));
    const nextValue = toInt(value, NaN);
    if (!Number.isFinite(nextValue) || nextValue < min) {
      return { updated: false, value: toPositiveInt(step[safeField], 0) };
    }

    step[safeField] = nextValue;
    return {
      updated: true,
      value: nextValue,
      field: safeField,
    };
  }

  function getStepDisplayModel(step) {
    const safeStep = step && typeof step === "object" ? step : {};
    const isPause = safeStep.type === "pause";
    const duration = toPositiveInt(safeStep.duration, 0);
    const count = isPause ? 1 : Math.max(1, toInt(safeStep.count, 1));
    const hms = stepDurationToHms(duration);
    return {
      isPause,
      count,
      duration,
      groupTotalSeconds: duration * count,
      hours: hms.hours,
      minutes: hms.minutes,
      seconds: hms.seconds,
    };
  }

  function createQueueStep(input = {}) {
    const isPause = !!input.isPause;
    const duration = toPositiveInt(input.duration, 0);
    if (duration <= 0) return null;

    const count = isPause ? 1 : Math.max(1, toInt(input.count, 5));
    const idValue = input.id;
    const id =
      idValue !== undefined && idValue !== null
        ? idValue
        : typeof input.now === "function"
          ? input.now()
          : Date.now();

    return {
      type: isPause ? "pause" : "pose",
      count,
      duration,
      id,
    };
  }

  function resolveDropInsertIndex(sourceIndex, targetIndex, isBelow) {
    const sIdx = toInt(sourceIndex, -1);
    const tIdx = toInt(targetIndex, -1);
    if (sIdx < 0 || tIdx < 0) return -1;
    return isBelow ? tIdx + 1 : tIdx;
  }

  function applyQueueDropOperation(
    queue,
    sourceIndex,
    targetIndex,
    isBelow,
    isDuplicate,
    cloneItem,
  ) {
    if (!Array.isArray(queue) || queue.length === 0) {
      return { changed: false, finalIndex: -1 };
    }

    const sIdx = toInt(sourceIndex, -1);
    const tIdx = toInt(targetIndex, -1);
    if (
      sIdx < 0 ||
      tIdx < 0 ||
      sIdx >= queue.length ||
      tIdx >= queue.length
    ) {
      return { changed: false, finalIndex: -1 };
    }

    let finalIndex = resolveDropInsertIndex(sIdx, tIdx, !!isBelow);
    if (finalIndex < 0) return { changed: false, finalIndex: -1 };

    if (sIdx < finalIndex) {
      finalIndex -= 1;
    }

    if (isDuplicate) {
      const sourceItem = queue[sIdx];
      if (!sourceItem || typeof sourceItem !== "object") {
        return { changed: false, finalIndex };
      }
      const duplicate =
        typeof cloneItem === "function"
          ? cloneItem(sourceItem)
          : { ...sourceItem };
      queue.splice(finalIndex, 0, duplicate);
      return { changed: true, finalIndex, duplicate: true };
    }

    if (sIdx === finalIndex) {
      return { changed: false, finalIndex };
    }

    const moved = queue.splice(sIdx, 1)[0];
    queue.splice(finalIndex, 0, moved);
    return { changed: true, finalIndex, duplicate: false };
  }

  function createCustomSessionUtils() {
    return {
      findNextPoseStepIndex,
      findPrevPoseStepIndex,
      findNextPoseStep,
      hasNextPoseGroup,
      hasPrevPoseGroup,
      getCustomPoseSessionProgress,
      calculateCustomTotalRemainingSeconds,
      getStepTotalSeconds,
      calculateQueueTotalSeconds,
      stepDurationToHms,
      updateStepDurationFromUnit,
      updateStepPositiveIntField,
      getStepDisplayModel,
      createQueueStep,
      resolveDropInsertIndex,
      applyQueueDropOperation,
    };
  }

  sharedRoot.createCustomSessionUtils = createCustomSessionUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-flow-utils.js ===== */
(function initPoseChronoSharedSessionFlowUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function toPositiveInt(value, fallback = 0) {
    return Math.max(0, toInt(value, fallback));
  }

  function resolveClassicDuration(
    hours,
    minutes,
    seconds,
    activeButtonDuration,
    fallbackSelectedDuration,
  ) {
    const h = Math.max(0, toInt(hours, 0));
    const m = Math.max(0, toInt(minutes, 0));
    const s = Math.max(0, toInt(seconds, 0));
    const manualTotal = h * 3600 + m * 60 + s;
    if (manualTotal > 0) return manualTotal;
    const fromButton = toPositiveInt(activeButtonDuration, 0);
    if (fromButton > 0) return fromButton;
    return toPositiveInt(fallbackSelectedDuration, 60);
  }

  function resolveSessionStartState(input = {}) {
    const mode = String(input.sessionMode || "classique").toLowerCase();
    const selectedDuration = toPositiveInt(input.selectedDuration, 60);
    const queue = Array.isArray(input.customQueue) ? input.customQueue : [];
    const memoryType = String(input.memoryType || "flash").toLowerCase();
    const imagesLength = Math.max(1, toInt(input.imagesLength, 1));
    const memoryPosesCountRaw = toInt(input.memoryPosesCount, 1);
    const clampMemoryPosesCount =
      typeof input.clampMemoryPosesCount === "function"
        ? input.clampMemoryPosesCount
        : (count, len, fallback = 1) =>
            Math.max(1, Math.min(toInt(count, fallback), Math.max(1, len)));

    const out = {
      isValid: true,
      selectedDuration,
      timeRemaining: selectedDuration,
      currentStepIndex: 0,
      currentPoseInStep: 1,
      memoryPosesCount: clampMemoryPosesCount(memoryPosesCountRaw, imagesLength, 1),
      memoryHidden: false,
    };

    if (mode === "custom") {
      if (queue.length === 0) {
        out.isValid = false;
        return out;
      }
      const firstStep = queue[0] || {};
      const firstDuration = toPositiveInt(firstStep.duration, selectedDuration);
      out.currentStepIndex = 0;
      out.currentPoseInStep = 1;
      out.selectedDuration = firstDuration;
      out.timeRemaining = firstDuration;
      return out;
    }

    if (mode === "memory") {
      if (memoryType === "flash") {
        const duration = toPositiveInt(input.memoryDuration, selectedDuration);
        out.selectedDuration = duration;
        out.timeRemaining = duration;
      } else {
        out.timeRemaining = selectedDuration;
      }
      return out;
    }

    if (mode === "relax") {
      out.timeRemaining = 0;
      return out;
    }

    out.timeRemaining = selectedDuration;
    return out;
  }

  function advanceCustomCursor(queue, currentStepIndex, currentPoseInStep) {
    const safeQueue = Array.isArray(queue) ? queue : [];
    let stepIndex = toInt(currentStepIndex, 0);
    let poseInStep = Math.max(1, toInt(currentPoseInStep, 1));

    const current = safeQueue[stepIndex];
    if (!current || typeof current !== "object") {
      return {
        finished: true,
        currentStepIndex: stepIndex,
        currentPoseInStep: poseInStep,
        nextStep: null,
        enteredNewStep: false,
        soundCue: null,
      };
    }

    const count = Math.max(1, toInt(current.count, 1));
    let enteredNewStep = false;
    if (poseInStep < count) {
      poseInStep += 1;
    } else {
      stepIndex += 1;
      poseInStep = 1;
      enteredNewStep = true;
    }

    if (stepIndex >= safeQueue.length) {
      return {
        finished: true,
        currentStepIndex: stepIndex,
        currentPoseInStep: poseInStep,
        nextStep: null,
        enteredNewStep,
        soundCue: null,
      };
    }

    const nextStep = safeQueue[stepIndex];
    const soundCue = enteredNewStep
      ? nextStep?.type === "pause"
        ? "pause"
        : "group"
      : null;

    return {
      finished: false,
      currentStepIndex: stepIndex,
      currentPoseInStep: poseInStep,
      nextStep,
      enteredNewStep,
      soundCue,
    };
  }

  function shouldEndMemorySession(currentIndex, memoryPosesCount) {
    const idx = Math.max(0, toInt(currentIndex, 0));
    const limit = Math.max(1, toInt(memoryPosesCount, 1));
    return idx + 1 >= limit;
  }

  function nextCyclicIndex(index, length) {
    const total = Math.max(1, toInt(length, 1));
    const current = Math.max(0, toInt(index, 0));
    return (current + 1) % total;
  }

  function createSessionFlowUtils() {
    return {
      resolveClassicDuration,
      resolveSessionStartState,
      advanceCustomCursor,
      shouldEndMemorySession,
      nextCyclicIndex,
    };
  }

  sharedRoot.createSessionFlowUtils = createSessionFlowUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timer-tick-utils.js ===== */
(function initPoseChronoSharedTimerTickUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function isCustomPauseStep(sessionMode, customQueue, currentStepIndex) {
    if (String(sessionMode) !== "custom") return false;
    const queue = Array.isArray(customQueue) ? customQueue : [];
    const index = Math.max(0, Math.round(toNumber(currentStepIndex, 0)));
    return queue[index]?.type === "pause";
  }

  function shouldEnterMemoryHiddenPhase(state) {
    return (
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash" &&
      toNumber(state?.timeRemaining, 0) < 0 &&
      !state?.memoryHidden
    );
  }

  function shouldAdvanceFromMemoryHiddenPhase(state) {
    return (
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash" &&
      !!state?.memoryHidden &&
      toNumber(state?.timeRemaining, 0) < 0
    );
  }

  function getTickSoundDecision(state) {
    if (!state?.soundEnabled) {
      return { playTick: false, volume: 0 };
    }
    const timeRemaining = toNumber(state.timeRemaining, 0);
    const selectedDuration = Math.max(0, toNumber(state.selectedDuration, 0));
    const isCustomPause = !!state.isCustomPause;
    const thresholdOverride = state.thresholdOverride != null
      ? Number(state.thresholdOverride)
      : null;
    const threshold =
      thresholdOverride != null && Number.isFinite(thresholdOverride) && thresholdOverride >= 0
        ? thresholdOverride
        : Math.min(selectedDuration * 0.2, 15);
    if (
      !isCustomPause &&
      threshold > 0 &&
      timeRemaining <= threshold &&
      timeRemaining > 0
    ) {
      return {
        playTick: true,
        volume: (threshold - timeRemaining) / threshold,
      };
    }
    return { playTick: false, volume: 0 };
  }

  function shouldPlayEndSound(state) {
    if (!state?.soundEnabled) return false;
    const isMemoryFlash =
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash";
    return toNumber(state?.timeRemaining, 0) === 0 && !isMemoryFlash;
  }

  function shouldAutoAdvanceOnTimerEnd(state) {
    const isMemoryFlash =
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash";
    return toNumber(state?.timeRemaining, 0) <= 0 && !isMemoryFlash;
  }

  function createTimerTickUtils() {
    return {
      isCustomPauseStep,
      shouldEnterMemoryHiddenPhase,
      shouldAdvanceFromMemoryHiddenPhase,
      getTickSoundDecision,
      shouldPlayEndSound,
      shouldAutoAdvanceOnTimerEnd,
    };
  }

  sharedRoot.createTimerTickUtils = createTimerTickUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-session-utils.js ===== */
(function initPoseChronoSharedReviewSessionUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function sanitizeCustomQueue(queue) {
    if (!Array.isArray(queue)) return null;
    return queue
      .filter((step) => step && typeof step === "object")
      .map((step) => ({
        type: step.type,
        count: toInt(step.count, 0),
        duration: toInt(step.duration, 0),
      }));
  }

  function mapSessionImages(images) {
    if (!Array.isArray(images)) return [];
    return images
      .filter((img) => img && typeof img === "object")
      .map((img) => ({
        id: img.id,
        filePath: img.filePath,
        path: img.path || img.filePath,
        file: img.file || img.filePath,
        ext: img.ext,
        thumbnailURL: img.thumbnailURL || img.thumbnail || "",
        thumbnail: img.thumbnail || img.thumbnailURL || "",
        url: img.url,
        name: img.name,
      }));
  }

  function buildSessionDetails(input = {}) {
    const mode = String(input.sessionMode || "classique");
    const images = mapSessionImages(input.imagesSeen);
    return {
      mode,
      memoryType: mode === "memory" ? input.memoryType || null : null,
      customQueue: mode === "custom" ? sanitizeCustomQueue(input.customQueue) : null,
      images,
    };
  }

  function computeReviewSummary(imagesSeen, totalSessionTime) {
    const poses = Array.isArray(imagesSeen) ? imagesSeen.length : 0;
    const sessionTime = Math.max(0, toInt(totalSessionTime, 0));
    const mins = Math.floor(sessionTime / 60);
    const secs = sessionTime % 60;
    return {
      sessionPoses: poses,
      sessionTime,
      mins,
      secs,
      shouldRecord: poses > 0 && sessionTime > 0,
    };
  }

  function createReviewSessionUtils() {
    return {
      sanitizeCustomQueue,
      mapSessionImages,
      buildSessionDetails,
      computeReviewSummary,
    };
  }

  sharedRoot.createReviewSessionUtils = createReviewSessionUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-grid-utils.js ===== */
(function initPoseChronoSharedReviewGridUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function defaultIsVideoFile() {
    return false;
  }

  function defaultGetDurationSeconds() {
    return 0;
  }

  function defaultIsAnnotated() {
    return false;
  }

  function defaultFormatDuration(seconds) {
    const safe = Math.max(0, Math.floor(Number(seconds) || 0));
    const m = Math.floor(safe / 60);
    const s = safe % 60;
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function normalizeReviewImageSource(rawValue) {
    const raw = String(rawValue || "").trim();
    if (!raw) return "";
    if (/^(https?:|file:|data:|blob:)/i.test(raw)) {
      return raw;
    }
    const normalized = raw.replace(/\\/g, "/");
    if (/^[a-zA-Z]:\//.test(normalized)) {
      return `file:///${normalized}`;
    }
    if (normalized.startsWith("/")) {
      return `file://${normalized}`;
    }
    return `file:///${normalized.replace(/^\/+/, "")}`;
  }

  function buildReviewGridItems(imagesSeen, options = {}) {
    const images = Array.isArray(imagesSeen) ? imagesSeen : [];
    const isVideoFile =
      typeof options.isVideoFile === "function"
        ? options.isVideoFile
        : defaultIsVideoFile;
    const getDurationSeconds =
      typeof options.getDurationSeconds === "function"
        ? options.getDurationSeconds
        : defaultGetDurationSeconds;
    const isAnnotated =
      typeof options.isAnnotated === "function"
        ? options.isAnnotated
        : defaultIsAnnotated;
    const formatDuration =
      typeof options.formatDuration === "function"
        ? options.formatDuration
        : defaultFormatDuration;
    const includeDurations = options.includeDurations !== false;

    return images.map((image, index) => {
      const isVideo = !!isVideoFile(image);
      const thumbnailSrc = image?.thumbnailURL || image?.thumbnail || "";
      const fallbackSrc = normalizeReviewImageSource(
        image?.filePath || image?.path || image?.file || "",
      );
      const durationSeconds = includeDurations ? getDurationSeconds(image) : 0;
      const durationText = includeDurations
        ? formatDuration(durationSeconds)
        : null;
      const annotated = !!isAnnotated(image);
      const hasMetaBadge = !!durationText || annotated;

      return {
        index,
        image,
        isVideo,
        src: thumbnailSrc || fallbackSrc,
        durationText,
        annotated,
        hasMetaBadge,
      };
    });
  }

  function createReviewGridUtils() {
    return {
      buildReviewGridItems,
    };
  }

  sharedRoot.createReviewGridUtils = createReviewGridUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-interactions-utils.js ===== */
(function initPoseChronoSharedReviewInteractionsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function getDurationToggleCopy(isVisible) {
    return isVisible
      ? {
          i18nKey: "drawing.hideDurations",
          defaultValue: "Hide durations",
        }
      : {
          i18nKey: "drawing.showDurations",
          defaultValue: "Show durations",
        };
  }

  function getDurationToggleTransition(isVisible) {
    if (isVisible) {
      return {
        nextVisible: false,
        animateHide: true,
        renderBeforeShow: false,
        animateShow: false,
      };
    }
    return {
      nextVisible: true,
      animateHide: false,
      renderBeforeShow: true,
      animateShow: true,
    };
  }

  function normalizeReviewIndex(index, length) {
    const total = Math.max(0, Math.floor(Number(length) || 0));
    if (total === 0) return 0;
    const idx = Math.floor(Number(index) || 0);
    return Math.max(0, Math.min(idx, total - 1));
  }

  function createReviewInteractionsUtils() {
    return {
      getDurationToggleCopy,
      getDurationToggleTransition,
      normalizeReviewIndex,
    };
  }

  sharedRoot.createReviewInteractionsUtils = createReviewInteractionsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/screen-context-menu-bindings-utils.js ===== */
(function initPoseChronoSharedScreenContextMenuBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindScreenBackgroundContextMenu(input = {}) {
    const screenElement = input.screenElement;
    const containerSelector = input.containerSelector;
    const onOpenMenu =
      typeof input.onOpenMenu === "function" ? input.onOpenMenu : null;

    if (
      !screenElement ||
      typeof screenElement.addEventListener !== "function" ||
      !containerSelector ||
      !onOpenMenu
    ) {
      return false;
    }

    screenElement.addEventListener("contextmenu", (event) => {
      const target = event.target;
      const isInsideContainer =
        target && typeof target.closest === "function"
          ? target.closest(containerSelector)
          : null;
      if (isInsideContainer) return;
      event.preventDefault();
      onOpenMenu(event.clientX, event.clientY, event);
    });
    return true;
  }

  function bindMultipleScreenBackgroundContextMenus(input = {}) {
    const bindings = Array.isArray(input.bindings) ? input.bindings : [];
    let boundCount = 0;
    bindings.forEach((binding) => {
      if (bindScreenBackgroundContextMenu(binding)) {
        boundCount += 1;
      }
    });
    return boundCount;
  }

  function createScreenContextMenuBindingsUtils() {
    return {
      bindScreenBackgroundContextMenu,
      bindMultipleScreenBackgroundContextMenus,
    };
  }

  sharedRoot.createScreenContextMenuBindingsUtils =
    createScreenContextMenuBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-replay-utils.js ===== */
(function initPoseChronoSharedSessionReplayUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const VALID_MODES = new Set(["classique", "custom", "relax", "memory"]);
  const VALID_MEMORY_TYPES = new Set(["flash", "progressive"]);

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function normalizeMode(mode, fallback = "classique") {
    const normalized = String(mode || "").trim().toLowerCase();
    if (VALID_MODES.has(normalized)) return normalized;
    const fb = String(fallback || "classique").trim().toLowerCase();
    return VALID_MODES.has(fb) ? fb : "classique";
  }

  function normalizeMemoryType(memoryType, mode = "classique") {
    if (normalizeMode(mode) !== "memory") return null;
    const normalized = String(memoryType || "").trim().toLowerCase();
    if (VALID_MEMORY_TYPES.has(normalized)) return normalized;
    return "flash";
  }

  function sanitizeCustomQueue(customQueue) {
    if (!Array.isArray(customQueue)) return [];
    return customQueue
      .filter((step) => step && typeof step === "object")
      .map((step) => ({
        type: step.type === "pause" ? "pause" : "pose",
        count: Math.max(1, Math.round(toNumber(step.count, 1))),
        duration: Math.max(1, Math.round(toNumber(step.duration, 60))),
      }));
  }

  function extractImageIdsFromSession(session) {
    const images = Array.isArray(session?.images) ? session.images : [];
    const out = [];
    const seen = new Set();
    images.forEach((img) => {
      const id = typeof img === "object" && img !== null ? img.id : null;
      if (id === undefined || id === null) return;
      const key = String(id);
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(id);
    });
    return out;
  }

  function computeReplayDuration(session) {
    const poses = Math.max(0, toNumber(session?.poses, 0));
    const time = Math.max(0, toNumber(session?.time, 0));
    if (poses <= 0 || time <= 0) return null;
    return time / poses;
  }

  function buildReplayOptionsFromSession(session) {
    const mode = normalizeMode(session?.mode);
    const duration = computeReplayDuration(session);
    const customQueue = mode === "custom" ? sanitizeCustomQueue(session?.customQueue) : [];
    const memoryType = normalizeMemoryType(session?.memoryType, mode);
    return {
      mode,
      duration,
      customQueue,
      memoryType,
    };
  }

  function normalizeLoadSessionOptions(options) {
    const mode = normalizeMode(options?.mode);
    const durationRaw = toNumber(options?.duration, 0);
    const duration = durationRaw > 0 ? Math.round(durationRaw) : null;
    const customQueue = mode === "custom" ? sanitizeCustomQueue(options?.customQueue) : [];
    const memoryType = normalizeMemoryType(options?.memoryType, mode);
    return {
      mode,
      duration,
      customQueue,
      memoryType,
    };
  }

  function createSessionReplayUtils() {
    return {
      normalizeMode,
      normalizeMemoryType,
      sanitizeCustomQueue,
      extractImageIdsFromSession,
      computeReplayDuration,
      buildReplayOptionsFromSession,
      normalizeLoadSessionOptions,
    };
  }

  sharedRoot.createSessionReplayUtils = createSessionReplayUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-media-utils.js ===== */
(function initPoseChronoSharedSessionMediaUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function normalizeExt(ext) {
    return String(ext || "").trim().toLowerCase();
  }

  function toExtSet(extensions) {
    const set = new Set();
    if (!Array.isArray(extensions)) return set;
    extensions.forEach((ext) => {
      const key = normalizeExt(ext);
      if (key) set.add(key);
    });
    return set;
  }

  function filterByExtensions(items, extensions) {
    const source = Array.isArray(items) ? items : [];
    const extSet = toExtSet(extensions);
    if (extSet.size === 0) return [];
    return source.filter((item) => {
      if (!item || typeof item !== "object") return false;
      return extSet.has(normalizeExt(item.ext));
    });
  }

  function shuffleArray(items, randomFn = Math.random) {
    const arr = Array.isArray(items) ? [...items] : [];
    for (let i = arr.length - 1; i > 0; i--) {
      const r = Number(randomFn());
      const ratio = Number.isFinite(r) ? Math.max(0, Math.min(1, r)) : 0;
      const j = Math.floor(ratio * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function countByExtensions(items, imageExtensions, videoExtensions) {
    const source = Array.isArray(items) ? items : [];
    const imageSet = toExtSet(imageExtensions);
    const videoSet = toExtSet(videoExtensions);
    let imageCount = 0;
    let videoCount = 0;

    source.forEach((item) => {
      const ext = normalizeExt(item?.ext);
      if (!ext) return;
      if (imageSet.has(ext)) {
        imageCount += 1;
        return;
      }
      if (videoSet.has(ext)) {
        videoCount += 1;
      }
    });

    return {
      imageCount,
      videoCount,
      totalCount: imageCount + videoCount,
    };
  }

  function isVideoFile(item, videoExtensions) {
    if (!item || typeof item !== "object") return false;
    const ext = normalizeExt(item.ext);
    if (!ext) return false;
    const videoSet = toExtSet(videoExtensions);
    return videoSet.has(ext);
  }

  function isGifFile(item) {
    if (!item || typeof item !== "object") return false;
    return normalizeExt(item.ext) === "gif";
  }

  async function resolveMediaSelection(operations = {}) {
    const getSelectedItems =
      typeof operations.getSelectedItems === "function"
        ? operations.getSelectedItems
        : async () => [];
    const getSelectedFolders =
      typeof operations.getSelectedFolders === "function"
        ? operations.getSelectedFolders
        : async () => [];
    const queryItems =
      typeof operations.queryItems === "function"
        ? operations.queryItems
        : async () => [];
    const toFolderIds =
      typeof operations.toFolderIds === "function"
        ? operations.toFolderIds
        : (folders) =>
            (Array.isArray(folders) ? folders : [])
              .map((folder) => folder?.id)
              .filter((id) => id !== undefined && id !== null && id !== "");

    const selectedItems = await getSelectedItems();
    if (Array.isArray(selectedItems) && selectedItems.length > 0) {
      return { items: selectedItems, source: "selected-items" };
    }

    const selectedFolders = await getSelectedFolders();
    const folderIds = toFolderIds(selectedFolders);
    if (folderIds.length > 0) {
      const folderItems = await queryItems({ folders: folderIds });
      if (Array.isArray(folderItems) && folderItems.length > 0) {
        return { items: folderItems, source: "selected-folders" };
      }
    }

    const allItems = await queryItems({});
    return {
      items: Array.isArray(allItems) ? allItems : [],
      source: "all-items",
    };
  }

  function formatLoadedMediaCount(mediaCounts, translate, options = {}) {
    const counts = mediaCounts && typeof mediaCounts === "object" ? mediaCounts : {};
    const imageCount = Number.isFinite(Number(counts.imageCount))
      ? Number(counts.imageCount)
      : 0;
    const videoCount = Number.isFinite(Number(counts.videoCount))
      ? Number(counts.videoCount)
      : 0;
    const t =
      typeof translate === "function" ? translate : (key, fallback) => fallback || key;

    const imageSingularKey = options.imageSingularKey || "settings.imageLoaded";
    const imagePluralKey = options.imagePluralKey || "settings.imagesLoaded";
    const videoSingularKey = options.videoSingularKey || "settings.videoLoaded";
    const videoPluralKey = options.videoPluralKey || "settings.videosLoaded";
    const andKey = options.andKey || "misc.and";

    const parts = [];
    if (imageCount > 0) {
      parts.push(
        `${imageCount} ${t(
          imageCount === 1 ? imageSingularKey : imagePluralKey,
          imageCount === 1 ? "image loaded" : "images loaded",
        )}`,
      );
    }
    if (videoCount > 0) {
      parts.push(
        `${videoCount} ${t(
          videoCount === 1 ? videoSingularKey : videoPluralKey,
          videoCount === 1 ? "video loaded" : "videos loaded",
        )}`,
      );
    }

    if (parts.length === 0) return "";
    if (parts.length === 1) return parts[0];
    return `${parts[0]} ${t(andKey, "and")} ${parts[1]}`;
  }

  function createSessionMediaUtils() {
    return {
      normalizeExt,
      filterByExtensions,
      shuffleArray,
      countByExtensions,
      isVideoFile,
      isGifFile,
      resolveMediaSelection,
      formatLoadedMediaCount,
    };
  }

  sharedRoot.createSessionMediaUtils = createSessionMediaUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-mode-ui-utils.js ===== */
(function initPoseChronoSharedSessionModeUiUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const MODE_CLASSIQUE = "classique";
  const MODE_CUSTOM = "custom";
  const MODE_RELAX = "relax";
  const MODE_MEMORY = "memory";
  const VALID_MODES = new Set([
    MODE_CLASSIQUE,
    MODE_CUSTOM,
    MODE_RELAX,
    MODE_MEMORY,
  ]);
  const MODE_DESCRIPTION_KEY_BY_MODE = Object.freeze({
    [MODE_CLASSIQUE]: "modes.classic.description",
    [MODE_CUSTOM]: "modes.custom.description",
    [MODE_RELAX]: "modes.relax.description",
    [MODE_MEMORY]: "modes.memory.description",
  });

  function normalizeMode(mode, fallback = MODE_CLASSIQUE) {
    const normalized = String(mode ?? "")
      .trim()
      .toLowerCase();
    if (VALID_MODES.has(normalized)) return normalized;

    const fallbackNormalized = String(fallback ?? MODE_CLASSIQUE)
      .trim()
      .toLowerCase();
    return VALID_MODES.has(fallbackNormalized) ? fallbackNormalized : MODE_CLASSIQUE;
  }

  function resolveIncomingPanelKey(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    if (
      normalizedMode === MODE_CLASSIQUE ||
      normalizedMode === MODE_CUSTOM ||
      normalizedMode === MODE_MEMORY
    ) {
      return normalizedMode;
    }
    return null;
  }

  function resolveOutgoingPanelKey(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    if (
      previousMode === MODE_CLASSIQUE ||
      previousMode === MODE_CUSTOM ||
      previousMode === MODE_MEMORY
    ) {
      return previousMode;
    }
    return null;
  }

  function shouldHideAllPanelsFirst(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    return previousMode === "" || previousMode === MODE_RELAX;
  }

  function resolveRelaxFrozenPanelKey(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    if (previousMode === MODE_MEMORY) return MODE_MEMORY;
    if (previousMode === MODE_CUSTOM) return MODE_CUSTOM;
    return MODE_CLASSIQUE;
  }

  function resolveMemoryDurationTarget(input = {}) {
    const memoryType = String(input.memoryType || "flash")
      .trim()
      .toLowerCase();
    const targetType = memoryType === "progressive" ? "progressive" : "flash";
    const duration =
      targetType === "flash"
        ? Math.max(0, Number(input.memoryDuration) || 0)
        : Math.max(0, Number(input.selectedDuration) || 0);

    return {
      memoryType: targetType,
      duration,
    };
  }

  function shouldDisableProgressiveBlurForMode(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    return normalizedMode === MODE_MEMORY || normalizedMode === MODE_RELAX;
  }

  function resolveStartButtonDisabled(input = {}) {
    const imagesCount = Math.max(0, Number(input.imagesCount) || 0);
    if (imagesCount === 0) return true;
    const mode = normalizeMode(input.sessionMode, MODE_CLASSIQUE);
    if (mode === MODE_CUSTOM) {
      const customQueueLength = Math.max(0, Number(input.customQueueLength) || 0);
      return customQueueLength === 0;
    }
    if (mode === MODE_RELAX) return false;
    return (Number(input.selectedDuration) || 0) <= 0;
  }

  function resolveStartButtonUiState(input = {}) {
    const disabled = resolveStartButtonDisabled(input);
    return {
      disabled,
      opacity: disabled ? "0.5" : "1",
    };
  }

  function resolveHomeProgressiveBlurState(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    const isRelax = normalizedMode === MODE_RELAX;
    return {
      disabled: isRelax,
      opacity: isRelax ? "0.5" : "1",
      classDisabled: isRelax,
    };
  }

  function resolveProgressiveBlurControlState(input = {}) {
    const disabled = !!input.disabled;
    const keepActive = !!input.keepActive;
    return {
      disabled,
      opacity: disabled ? "0.3" : "1",
      pointerEvents: disabled ? "none" : "all",
      shouldClearActive: disabled && !keepActive,
    };
  }

  function resolveModeTransition(mode, previousModeRaw) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    const isRelax = normalizedMode === MODE_RELAX;
    return {
      mode: normalizedMode,
      isRelax,
      incomingPanelKey: isRelax ? null : resolveIncomingPanelKey(normalizedMode),
      outgoingPanelKey: resolveOutgoingPanelKey(previousModeRaw),
      hideAllPanelsFirst: !isRelax && shouldHideAllPanelsFirst(previousModeRaw),
      relaxFrozenPanelKey: isRelax
        ? resolveRelaxFrozenPanelKey(previousModeRaw)
        : null,
      disableProgressiveBlur: shouldDisableProgressiveBlurForMode(normalizedMode),
    };
  }

  function getModeDescriptionI18nKey(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    return (
      MODE_DESCRIPTION_KEY_BY_MODE[normalizedMode] ||
      MODE_DESCRIPTION_KEY_BY_MODE[MODE_CLASSIQUE]
    );
  }

  function resolveModeDescription(mode, translate, options = {}) {
    const t =
      typeof translate === "function" ? translate : (key, fallback) => fallback || key;
    const key = getModeDescriptionI18nKey(mode);
    const translated = t(key, "");

    if (translated && translated !== key) {
      return translated;
    }

    const fallbackKey = String(
      options.fallbackKey || "settings.sessionDescription",
    );
    const fallbackText = String(
      options.fallbackText || "Choose a session type",
    );
    return t(fallbackKey, fallbackText);
  }

  function createSessionModeUiUtils() {
    return {
      normalizeMode,
      resolveIncomingPanelKey,
      resolveOutgoingPanelKey,
      shouldHideAllPanelsFirst,
      resolveRelaxFrozenPanelKey,
      resolveMemoryDurationTarget,
      shouldDisableProgressiveBlurForMode,
      resolveStartButtonDisabled,
      resolveStartButtonUiState,
      resolveHomeProgressiveBlurState,
      resolveProgressiveBlurControlState,
      resolveModeTransition,
      getModeDescriptionI18nKey,
      resolveModeDescription,
    };
  }

  sharedRoot.createSessionModeUiUtils = createSessionModeUiUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sidebar-tooltips-utils.js ===== */
(function initPoseChronoSharedSidebarTooltipsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function safeSetTooltip(element, value) {
    if (!element || typeof element.setAttribute !== "function") return;
    element.setAttribute("data-tooltip", String(value || ""));
  }

  function updateSidebarTooltips(input = {}) {
    const buttons = input.buttons || {};
    const hotkeys = input.hotkeys || {};
    const t =
      typeof input.translate === "function"
        ? input.translate
        : (key, options = {}) => {
            if (options && typeof options.defaultValue === "string") {
              return options.defaultValue;
            }
            return key;
          };

    safeSetTooltip(
      buttons.flipHorizontalBtn,
      `${t("drawing.flipHorizontal")} (${hotkeys.FLIP_H || ""})`,
    );
    safeSetTooltip(buttons.flipVerticalBtn, t("drawing.flipVertical"));
    safeSetTooltip(
      buttons.grayscaleBtn,
      `${t("filters.grayscale")} (${String(hotkeys.GRAYSCALE || "").toUpperCase()})`,
    );
    safeSetTooltip(
      buttons.blurBtn,
      t("filters.blurTooltip", {
        hotkey: String(hotkeys.BLUR || "").toUpperCase(),
      }),
    );
    safeSetTooltip(buttons.progressiveBlurBtn, t("filters.progressiveBlur"));
  }

  function createSidebarTooltipsUtils() {
    return {
      updateSidebarTooltips,
    };
  }

  sharedRoot.createSidebarTooltipsUtils = createSidebarTooltipsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/keyboard-listener-bindings-utils.js ===== */
(function initPoseChronoSharedKeyboardListenerBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindCoreKeyboardShortcuts(input = {}) {
    const documentRef = input.documentRef;
    if (!documentRef || typeof documentRef.addEventListener !== "function") {
      return false;
    }

    if (typeof input.onMainKeydown === "function") {
      documentRef.addEventListener("keydown", input.onMainKeydown);
    }
    if (typeof input.onSettingsKeydown === "function") {
      documentRef.addEventListener("keydown", input.onSettingsKeydown);
    }
    if (typeof input.onFrameSteppingKeyup === "function") {
      documentRef.addEventListener("keyup", input.onFrameSteppingKeyup);
    }
    if (typeof input.onThemeKeydown === "function") {
      documentRef.addEventListener("keydown", input.onThemeKeydown);
    }
    if (typeof input.onPinKeydown === "function") {
      documentRef.addEventListener("keydown", input.onPinKeydown);
    }
    if (typeof input.onGlobalSettingsKeydown === "function") {
      documentRef.addEventListener("keydown", input.onGlobalSettingsKeydown);
    }

    return true;
  }

  function createKeyboardListenerBindingsUtils() {
    return {
      bindCoreKeyboardShortcuts,
    };
  }

  sharedRoot.createKeyboardListenerBindingsUtils =
    createKeyboardListenerBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/global-keyboard-shortcuts-utils.js ===== */
(function initPoseChronoSharedGlobalKeyboardShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || !!target.isContentEditable;
  }

  function shouldStopFrameSteppingOnKeyup(input = {}) {
    const event = input.event;
    const hotkeys = input.hotkeys || {};
    if (!event) return false;
    const key = event.key;
    return (
      key === "'" ||
      key === "PageDown" ||
      key === hotkeys.VIDEO_PREV_FRAME ||
      key === "(" ||
      key === "PageUp" ||
      key === hotkeys.VIDEO_NEXT_FRAME
    );
  }

  function handleThemeShortcut(input = {}) {
    const event = input.event;
    const themeHotkey = input.themeHotkey;
    const onToggleTheme =
      typeof input.onToggleTheme === "function" ? input.onToggleTheme : null;
    if (!event || !themeHotkey || !onToggleTheme) return false;
    if (event.key !== themeHotkey) return false;
    event.preventDefault();
    onToggleTheme();
    return true;
  }

  function isPinShortcutEvent(event) {
    return !!event && event.shiftKey && event.code === "KeyT";
  }

  async function handlePinShortcut(input = {}) {
    const event = input.event;
    const onToggleAlwaysOnTop =
      typeof input.onToggleAlwaysOnTop === "function"
        ? input.onToggleAlwaysOnTop
        : null;
    const onApplyState =
      typeof input.onApplyState === "function" ? input.onApplyState : null;

    if (!isPinShortcutEvent(event) || !onToggleAlwaysOnTop) return false;

    event.preventDefault();
    const isOnTop = await onToggleAlwaysOnTop();
    if (onApplyState) {
      onApplyState(!!isOnTop);
    }
    return true;
  }

  function handleGlobalSettingsShortcut(input = {}) {
    const event = input.event;
    const onOpenGlobalSettings =
      typeof input.onOpenGlobalSettings === "function"
        ? input.onOpenGlobalSettings
        : null;
    if (!event || !onOpenGlobalSettings) return false;

    const isModifier = event.ctrlKey || event.metaKey;
    const isGlobalSettingsKey =
      isModifier &&
      !event.shiftKey &&
      !event.altKey &&
      String(event.key || "").toLowerCase() === "k";
    if (!isGlobalSettingsKey || isTypingTarget(event.target)) return false;

    event.preventDefault();
    onOpenGlobalSettings();
    return true;
  }

  function createGlobalKeyboardShortcutsUtils() {
    return {
      shouldStopFrameSteppingOnKeyup,
      handleThemeShortcut,
      isPinShortcutEvent,
      handlePinShortcut,
      handleGlobalSettingsShortcut,
    };
  }

  sharedRoot.createGlobalKeyboardShortcutsUtils = createGlobalKeyboardShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/main-keyboard-shortcuts-utils.js ===== */
(function initPoseChronoSharedMainKeyboardShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA";
  }

  function callIfFn(fn, ...args) {
    if (typeof fn === "function") {
      return fn(...args);
    }
    return undefined;
  }

  function handleMainKeyboardShortcuts(input = {}) {
    const e = input.event;
    if (!e) return false;

    const drawingScreen = input.drawingScreen;
    if (!drawingScreen || drawingScreen.classList.contains("hidden")) return true;
    if (isTypingTarget(e.target)) return true;
    if (input.isDrawingModeActive) return true;

    const doc = input.documentRef || (typeof document !== "undefined" ? document : null);
    const win = input.windowRef || (typeof window !== "undefined" ? window : null);
    const state = input.state || {};
    const blurBtn = input.blurBtn || null;
    const config = input.config || {};
    const hk = config.HOTKEYS || {};

    if (!doc) return true;

    const key = e.key;
    const keyLow = String(key || "").toLowerCase();

    const tagsModal = doc.getElementById("tags-modal");
    const sessionPlansModal = doc.getElementById("session-plans-modal");
    const globalSettingsModal = doc.getElementById("global-settings-modal");

    const isAnyModalOpen =
      (tagsModal && !tagsModal.classList.contains("hidden")) ||
      (sessionPlansModal && !sessionPlansModal.classList.contains("hidden")) ||
      (globalSettingsModal && !globalSettingsModal.classList.contains("hidden"));

    if (isAnyModalOpen && key === "Escape") {
      e.preventDefault();

      if (tagsModal && !tagsModal.classList.contains("hidden")) {
        tagsModal.classList.add("hidden");
        if (state.wasPlayingBeforeModal) {
          callIfFn(input.startTimer);
          state.wasPlayingBeforeModal = false;
        }
        return true;
      }

      if (sessionPlansModal && !sessionPlansModal.classList.contains("hidden")) {
        sessionPlansModal.classList.add("hidden");
        return true;
      }

      if (
        globalSettingsModal &&
        !globalSettingsModal.classList.contains("hidden")
      ) {
        callIfFn(input.closeGlobalSettingsModal);
        return true;
      }

      return true;
    }

    if (isAnyModalOpen) return true;

    if (key === hk.FLIP_H) {
      e.preventDefault();
      callIfFn(input.toggleFlipHorizontal);
      return true;
    }

    if (key === " " && !e.shiftKey) {
      e.preventDefault();
      callIfFn(input.togglePlayPause);
      return true;
    }

    if (e.shiftKey && key === hk.GRID_MODAL) {
      e.preventDefault();
      callIfFn(input.showGridConfig);
      return true;
    }

    if (e.shiftKey && key === hk.SILHOUETTE_MODAL) {
      e.preventDefault();
      callIfFn(input.showSilhouetteConfig);
      return true;
    }

    switch (key) {
      case "Escape": {
        e.preventDefault();
        const gridPopup = doc.getElementById("grid-config-popup");
        const silhouettePopup = doc.getElementById("silhouette-config-popup");
        const imageInfoOverlay = doc.getElementById("image-info-overlay");

        if (gridPopup) {
          gridPopup.remove();
          if (input.wasPlayingBeforeModal && !state.isPlaying) {
            callIfFn(input.togglePlayPause);
          }
        } else if (silhouettePopup) {
          silhouettePopup.remove();
          if (input.wasPlayingBeforeModal && !state.isPlaying) {
            callIfFn(input.togglePlayPause);
          }
        } else if (!imageInfoOverlay) {
          callIfFn(input.showReview);
        }
        break;
      }
      case "Delete":
        e.preventDefault();
        callIfFn(input.deleteImage);
        break;
      case "ArrowUp":
        e.preventDefault();
        if (e.shiftKey) {
          if (state.silhouetteEnabled) {
            state.silhouetteBrightness = Math.min(
              state.silhouetteBrightness + 0.1,
              6,
            );
            callIfFn(input.applyImageFilters);
            const brightnessSlider = doc.getElementById("brightness-slider");
            const brightnessValue = doc.getElementById("brightness-value");
            if (brightnessSlider) {
              brightnessSlider.value = state.silhouetteBrightness;
              callIfFn(input.updateSliderGradient, brightnessSlider);
            }
            if (brightnessValue) {
              brightnessValue.textContent = state.silhouetteBrightness.toFixed(2);
            }
          }
        } else if (state.isBlurEnabled) {
          state.blurAmount = Math.min(state.blurAmount + 2.5, 100);
          callIfFn(input.updateBlurAmount);
          callIfFn(input.applyImageFilters);
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (e.shiftKey) {
          if (state.silhouetteEnabled) {
            state.silhouetteBrightness = Math.max(
              state.silhouetteBrightness - 0.1,
              0,
            );
            callIfFn(input.applyImageFilters);
            const brightnessSlider = doc.getElementById("brightness-slider");
            const brightnessValue = doc.getElementById("brightness-value");
            if (brightnessSlider) {
              brightnessSlider.value = state.silhouetteBrightness;
              callIfFn(input.updateSliderGradient, brightnessSlider);
            }
            if (brightnessValue) {
              brightnessValue.textContent = state.silhouetteBrightness.toFixed(2);
            }
          }
        } else if (state.isBlurEnabled) {
          state.blurAmount = Math.max(state.blurAmount - 2.5, 0);
          callIfFn(input.updateBlurAmount);
          callIfFn(input.applyImageFilters);
        }
        break;
      case "ArrowLeft":
        e.preventDefault();
        callIfFn(input.previousImage);
        break;
      case "ArrowRight":
        e.preventDefault();
        callIfFn(input.nextImage);
        break;
      default:
        break;
    }

    if (
      keyLow === String(hk.GRAYSCALE || "").toLowerCase() ||
      (e.ctrlKey && e.altKey && keyLow === "g")
    ) {
      callIfFn(input.toggleGrayscale);
    } else if (keyLow === String(hk.BLUR || "").toLowerCase()) {
      if (!state.isProgressiveBlur && blurBtn) {
        blurBtn.click();
      }
    } else if (keyLow === String(hk.ANNOTATE || "").toLowerCase()) {
      e.preventDefault();
      callIfFn(input.openDrawingMode);
    } else if (keyLow === String(hk.MUTE || "").toLowerCase()) {
      callIfFn(input.toggleSound);
    } else if (keyLow === String(hk.GRID || "").toLowerCase()) {
      state.gridEnabled = !state.gridEnabled;
      if (
        state.gridEnabled &&
        state.gridMode === "none" &&
        (!Array.isArray(state.gridGuides) || state.gridGuides.length === 0)
      ) {
        if (!Array.isArray(state.gridGuides)) state.gridGuides = [];
        state.gridGuides.push({ type: "vertical", position: 50 });
      }
      callIfFn(input.updateGridOverlay);
    } else if (keyLow === String(hk.SILHOUETTE || "").toLowerCase()) {
      state.silhouetteEnabled = !state.silhouetteEnabled;
      callIfFn(input.applyImageFilters);
    } else if (keyLow === String(hk.SIDEBAR || "").toLowerCase()) {
      callIfFn(input.toggleSidebar);
    } else if (keyLow === String(hk.INFO || "").toLowerCase()) {
      callIfFn(input.toggleImageInfo);
    } else if (keyLow === String(hk.TAGS || "").toLowerCase()) {
      e.preventDefault();
      if (!callIfFn(input.isTagsFeatureAvailable)) return true;
      if (typeof input.openTagsModal === "function") {
        const zoomOverlay = doc.getElementById("zoom-overlay");
        const zoomImage = win ? win.zoomOverlayCurrentImage || null : null;
        if (zoomOverlay && zoomImage) {
          input.openTagsModal(null, zoomImage);
        } else if (
          zoomOverlay &&
          win &&
          win.currentZoomIndex !== undefined &&
          win.currentZoomIndex !== null
        ) {
          input.openTagsModal(win.currentZoomIndex);
        } else {
          input.openTagsModal();
        }
      }
    }

    if (state.isVideoFile) {
      if (key === hk.VIDEO_SLOWER) {
        e.preventDefault();
        callIfFn(input.changeVideoSpeed, -1);
        return true;
      }
      if (key === hk.VIDEO_FASTER) {
        e.preventDefault();
        callIfFn(input.changeVideoSpeed, 1);
        return true;
      }
      if (key === hk.VIDEO_PREV_FRAME) {
        e.preventDefault();
        callIfFn(input.stepFrame, -1, e.repeat);
        return true;
      }
      if (key === hk.VIDEO_NEXT_FRAME) {
        e.preventDefault();
        callIfFn(input.stepFrame, 1, e.repeat);
        return true;
      }
      if (keyLow === String(hk.VIDEO_LOOP || "").toLowerCase()) {
        e.preventDefault();
        callIfFn(input.toggleVideoLoop);
        return true;
      }
      if (e.shiftKey && key === " ") {
        e.preventDefault();
        callIfFn(input.toggleVideoPlayPause);
        return true;
      }
      if (e.shiftKey && key === hk.VIDEO_CONFIG) {
        e.preventDefault();
        callIfFn(input.showVideoConfig);
        return true;
      }
    }

    return true;
  }

  function createMainKeyboardShortcutsUtils() {
    return {
      handleMainKeyboardShortcuts,
    };
  }

  sharedRoot.createMainKeyboardShortcutsUtils = createMainKeyboardShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/settings-shortcuts-utils.js ===== */
(function initPoseChronoSharedSettingsShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || !!target.isContentEditable;
  }

  function isPlainSpacePress(event) {
    const isSpace =
      event?.key === " " || event?.key === "Spacebar" || event?.code === "Space";
    if (!isSpace) return false;
    return !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey;
  }

  function handleSettingsScreenKeyboardShortcuts(input = {}) {
    const event = input.event;
    const settingsScreen = input.settingsScreen;
    const reviewScreen = input.reviewScreen;
    const startBtn = input.startBtn;
    const getTopOpenModal =
      typeof input.getTopOpenModal === "function" ? input.getTopOpenModal : null;
    const onStart = typeof input.onStart === "function" ? input.onStart : null;
    const onReturnHome =
      typeof input.onReturnHome === "function" ? input.onReturnHome : null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);

    if (!event) {
      return false;
    }

    if (!isPlainSpacePress(event) || isTypingTarget(event.target)) {
      return false;
    }

    const isSettingsVisible =
      !!settingsScreen && !settingsScreen.classList.contains("hidden");
    const isReviewVisible =
      !!reviewScreen && !reviewScreen.classList.contains("hidden");

    if (!isSettingsVisible && !isReviewVisible) {
      return false;
    }

    if (getTopOpenModal && getTopOpenModal()) return false;

    if (isReviewVisible) {
      const zoomOverlay =
        documentRef && typeof documentRef.getElementById === "function"
          ? documentRef.getElementById("zoom-overlay")
          : null;
      if (zoomOverlay) return false;

      event.preventDefault();
      if (onReturnHome) {
        onReturnHome();
      }
      return true;
    }

    if (!startBtn || startBtn.disabled) return false;

    event.preventDefault();
    if (onStart) {
      onStart();
    } else if (typeof startBtn.click === "function") {
      startBtn.click();
    }
    return true;
  }

  function createSettingsShortcutsUtils() {
    return {
      handleSettingsScreenKeyboardShortcuts,
    };
  }

  sharedRoot.createSettingsShortcutsUtils = createSettingsShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-time-format-utils.js ===== */
(function initPoseChronoSharedSessionTimeFormatUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSafeSeconds(value) {
    return Math.max(0, Math.floor(Number(value) || 0));
  }

  function formatCompactDuration(seconds) {
    const safe = toSafeSeconds(seconds);
    if (safe <= 0) return "0s";

    const h = Math.floor(safe / 3600);
    const m = Math.floor((safe % 3600) / 60);
    const s = safe % 60;

    const parts = [];
    if (h > 0) parts.push(`${h}h`);
    if (m > 0) parts.push(`${m}m`);
    if (s > 0 || parts.length === 0) parts.push(`${s}s`);
    return parts.join(" ");
  }

  function formatClockDuration(seconds) {
    const safe = toSafeSeconds(seconds);
    const h = Math.floor(safe / 3600);
    const m = Math.floor((safe % 3600) / 60);
    const s = safe % 60;

    if (h > 0) {
      return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function createSessionTimeFormatUtils() {
    return {
      toSafeSeconds,
      formatCompactDuration,
      formatClockDuration,
    };
  }

  sharedRoot.createSessionTimeFormatUtils = createSessionTimeFormatUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-duration-buttons-utils.js ===== */
(function initPoseChronoSharedSessionDurationButtonsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toDurationSeconds(value, fallback = 0) {
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
  }

  function getButtonDuration(button, fallback = 0) {
    if (!button || !button.dataset) return fallback;
    return toDurationSeconds(button.dataset.duration, fallback);
  }

  function setActiveDurationButtons(buttons, duration) {
    if (!buttons || typeof buttons.forEach !== "function") return;
    buttons.forEach((btn) => {
      if (!btn?.classList) return;
      btn.classList.toggle("active", getButtonDuration(btn) === duration);
    });
  }

  function clearActiveDurationButtons(buttons) {
    if (!buttons || typeof buttons.forEach !== "function") return;
    buttons.forEach((btn) => {
      if (!btn?.classList) return;
      btn.classList.remove("active");
    });
  }

  function createSessionDurationButtonsUtils() {
    return {
      toDurationSeconds,
      getButtonDuration,
      setActiveDurationButtons,
      clearActiveDurationButtons,
    };
  }

  sharedRoot.createSessionDurationButtonsUtils = createSessionDurationButtonsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-time-input-utils.js ===== */
(function initPoseChronoSharedSessionTimeInputUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
  }

  function clampInt(value, min, max, fallback = 0) {
    const num = toInt(value, fallback);
    const lower = Number.isFinite(Number(min)) ? Number(min) : 0;
    const upper = Number.isFinite(Number(max)) ? Number(max) : lower;
    const safeMin = Math.min(lower, upper);
    const safeMax = Math.max(lower, upper);
    return Math.min(safeMax, Math.max(safeMin, num));
  }

  function readInputBound(input, attrName, fallback = 0) {
    if (!input || typeof input.getAttribute !== "function") return fallback;
    if (!input.hasAttribute(attrName)) return fallback;
    return toInt(input.getAttribute(attrName), fallback);
  }

  function hmsToSeconds(hours, minutes, seconds) {
    const h = toInt(hours, 0);
    const m = toInt(minutes, 0);
    const s = toInt(seconds, 0);
    return h * 3600 + m * 60 + s;
  }

  function msToSeconds(minutes, seconds) {
    const m = toInt(minutes, 0);
    const s = toInt(seconds, 0);
    return m * 60 + s;
  }

  function secondsToHms(totalSeconds) {
    const safe = Math.max(0, toInt(totalSeconds, 0));
    return {
      hours: Math.floor(safe / 3600),
      minutes: Math.floor((safe % 3600) / 60),
      seconds: safe % 60,
      totalSeconds: safe,
    };
  }

  function readHmsInputs(hoursInput, minutesInput, secondsInput) {
    const hours = toInt(hoursInput?.value, 0);
    const minutes = toInt(minutesInput?.value, 0);
    const seconds = toInt(secondsInput?.value, 0);
    return {
      hours,
      minutes,
      seconds,
      totalSeconds: hmsToSeconds(hours, minutes, seconds),
    };
  }

  function readMinutesSecondsInputs(minutesInput, secondsInput) {
    const minutes = toInt(minutesInput?.value, 0);
    const seconds = toInt(secondsInput?.value, 0);
    return {
      minutes,
      seconds,
      totalSeconds: msToSeconds(minutes, seconds),
    };
  }

  function createSessionTimeInputUtils() {
    return {
      toInt,
      clampInt,
      readInputBound,
      hmsToSeconds,
      msToSeconds,
      secondsToHms,
      readHmsInputs,
      readMinutesSecondsInputs,
    };
  }

  sharedRoot.createSessionTimeInputUtils = createSessionTimeInputUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/hotkeys-utils.js ===== */
(function initPoseChronoSharedHotkeysUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSchemaVersion(value, fallback = 1) {
    const num = Number(value);
    return Number.isFinite(num) ? Math.max(1, Math.round(num)) : fallback;
  }

  function toSet(input) {
    if (input instanceof Set) return new Set(input);
    if (Array.isArray(input)) return new Set(input);
    return new Set();
  }

  function createHotkeysUtils(options = {}) {
    const schemaVersion = toSchemaVersion(options.schemaVersion, 1);
    const defaultBindings =
      options.defaultBindings && typeof options.defaultBindings === "object"
        ? options.defaultBindings
        : {};
    const nonCustomizableKeys = toSet(options.nonCustomizableKeys);

    function normalizeHotkeysPayload(raw) {
      const sourceBindings =
        raw &&
        typeof raw === "object" &&
        raw.bindings &&
        typeof raw.bindings === "object"
          ? raw.bindings
          : raw && typeof raw === "object"
            ? raw
            : {};

      let repaired = false;
      const bindings = {};

      Object.keys(defaultBindings).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(sourceBindings, key)) return;

        const rawValue = sourceBindings[key];
        if (typeof rawValue !== "string") {
          repaired = true;
          return;
        }
        const value = rawValue.trim();
        if (value.length === 0) {
          repaired = true;
          return;
        }
        if (value.length > 48) {
          repaired = true;
          bindings[key] = value.slice(0, 48);
          return;
        }
        bindings[key] = value;
      });

      const payload = {
        schemaVersion,
        bindings,
      };

      if (
        !raw ||
        typeof raw !== "object" ||
        raw.schemaVersion !== schemaVersion ||
        !raw.bindings
      ) {
        repaired = true;
      }

      return { payload, bindings, repaired };
    }

    function collectCustomBindings(currentBindings) {
      const source =
        currentBindings && typeof currentBindings === "object"
          ? currentBindings
          : {};
      const out = {};

      Object.keys(defaultBindings).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(source, key)) return;
        if (source[key] === defaultBindings[key]) return;
        out[key] = source[key];
      });

      return out;
    }

    function countCustomBindings(currentBindings) {
      return Object.keys(collectCustomBindings(currentBindings)).length;
    }

    function normalizeForConflictCompare(value) {
      if (!value) return "";
      const text = String(value);
      if (text.includes("+")) return text;
      return text.toLowerCase();
    }

    function findHotkeyConflict(
      currentBindings,
      hotkeyName,
      newValue,
      options = {},
    ) {
      if (!newValue) return null;
      const source =
        currentBindings && typeof currentBindings === "object"
          ? currentBindings
          : {};
      const drawingPrefix = String(options.drawingPrefix || "DRAWING_");
      const isDrawingKey = String(hotkeyName || "").startsWith(drawingPrefix);
      const normalizedNew = normalizeForConflictCompare(newValue);

      for (const [key, value] of Object.entries(source)) {
        if (key === hotkeyName) continue;
        if (!value) continue;
        const normalizedExisting = normalizeForConflictCompare(value);
        if (normalizedExisting !== normalizedNew) continue;
        const isOtherDrawing = key.startsWith(drawingPrefix);
        if (isDrawingKey === isOtherDrawing) {
          return key;
        }
      }
      return null;
    }

    function formatHotkeyDisplay(hotkeyName, value, optionsArg = {}) {
      if (!value) return "";
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const implicitModifiers =
        options.implicitModifiers && typeof options.implicitModifiers === "object"
          ? options.implicitModifiers
          : {};
      const raw = String(value);

      if (raw.includes("+")) {
        return raw.split("+").join(" + ");
      }

      const parts = [];
      const implicitMod = implicitModifiers[hotkeyName];
      if (implicitMod) {
        parts.push(String(implicitMod));
      }

      if (
        !implicitMod &&
        raw.length === 1 &&
        raw >= "A" &&
        raw <= "Z"
      ) {
        parts.push("Shift");
      }

      parts.push(raw.length === 1 ? raw.toUpperCase() : raw);
      return parts.join(" + ");
    }

    function resetBindingsToDefaults(targetBindings) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      Object.keys(defaultBindings).forEach((key) => {
        targetBindings[key] = defaultBindings[key];
      });
      return targetBindings;
    }

    function enforceNonCustomizableBindings(targetBindings) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      nonCustomizableKeys.forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(defaultBindings, key)) return;
        targetBindings[key] = defaultBindings[key];
      });
      return targetBindings;
    }

    function applyCustomBindings(targetBindings, customBindings, optionsArg = {}) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const resetFirst = !!options.resetToDefaults;
      const enforceAfter =
        options.enforceNonCustomizable === undefined
          ? true
          : !!options.enforceNonCustomizable;
      const requireTargetKey =
        options.requireTargetKey === undefined ? true : !!options.requireTargetKey;
      const source =
        customBindings && typeof customBindings === "object" ? customBindings : {};

      if (resetFirst) {
        resetBindingsToDefaults(targetBindings);
      }

      Object.keys(source).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(defaultBindings, key)) return;
        if (
          requireTargetKey &&
          !Object.prototype.hasOwnProperty.call(targetBindings, key)
        ) {
          return;
        }
        targetBindings[key] = source[key];
      });

      if (enforceAfter) {
        enforceNonCustomizableBindings(targetBindings);
      }
      return targetBindings;
    }

    return {
      normalizeHotkeysPayload,
      collectCustomBindings,
      countCustomBindings,
      normalizeForConflictCompare,
      findHotkeyConflict,
      formatHotkeyDisplay,
      resetBindingsToDefaults,
      enforceNonCustomizableBindings,
      applyCustomBindings,
    };
  }

  sharedRoot.createHotkeysUtils = createHotkeysUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/storage-diagnostics-utils.js ===== */
(function initPoseChronoSharedStorageDiagnosticsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function safeCall(fn, fallback) {
    try {
      if (typeof fn === "function") return fn();
    } catch (_) {}
    return fallback;
  }

  function extractTimelineStatsFromData(data) {
    const source =
      data &&
      typeof data === "object" &&
      data.data &&
      typeof data.data === "object"
        ? data.data
        : data;
    const daysObj =
      source && typeof source === "object" && source.days ? source.days : {};
    const daysEntries =
      daysObj && typeof daysObj === "object" ? Object.values(daysObj) : [];
    const days = daysEntries.length;
    const sessions = daysEntries.reduce(
      (sum, day) =>
        sum + (Array.isArray(day && day.sessions) ? day.sessions.length : 0),
      0,
    );
    return { days, sessions };
  }

  async function collectStorageDiagnostics(input = {}) {
    const diagnostics = {
      timelineDays: 0,
      timelineSessions: 0,
      plansCount: 0,
      customHotkeysCount: 0,
    };

    const hotkeysCount =
      typeof input.customHotkeysCount === "number"
        ? input.customHotkeysCount
        : safeCall(input.getCustomHotkeysCount, 0);
    diagnostics.customHotkeysCount = Math.max(
      0,
      Number.isFinite(hotkeysCount) ? Math.round(hotkeysCount) : 0,
    );

    try {
      let timelineSource = undefined;
      if (typeof input.getTimelineData === "function") {
        timelineSource = await input.getTimelineData();
      }
      if (
        timelineSource === undefined &&
        typeof input.loadTimelinePayload === "function"
      ) {
        timelineSource = await input.loadTimelinePayload();
      }
      if (timelineSource !== undefined) {
        const timelineStats = extractTimelineStatsFromData(timelineSource);
        diagnostics.timelineDays = timelineStats.days;
        diagnostics.timelineSessions = timelineStats.sessions;
      }
    } catch (_) {}

    try {
      let plansPayload = undefined;
      if (typeof input.loadPlansPayload === "function") {
        plansPayload = await input.loadPlansPayload();
      }
      if (
        plansPayload === undefined &&
        typeof input.loadLegacyPlansPayload === "function"
      ) {
        plansPayload = await input.loadLegacyPlansPayload();
      }

      if (plansPayload !== undefined && plansPayload !== null) {
        if (typeof input.normalizeSessionPlansPayload === "function") {
          const normalized = input.normalizeSessionPlansPayload(plansPayload);
          const count = normalized && normalized.plans && normalized.plans.length;
          diagnostics.plansCount = Math.max(
            0,
            Number.isFinite(count) ? Math.round(count) : 0,
          );
        } else if (Array.isArray(plansPayload)) {
          diagnostics.plansCount = plansPayload.length;
        } else if (plansPayload && Array.isArray(plansPayload.plans)) {
          diagnostics.plansCount = plansPayload.plans.length;
        }
      }
    } catch (_) {}

    return diagnostics;
  }

  function createStorageDiagnosticsUtils() {
    return {
      extractTimelineStatsFromData,
      collectStorageDiagnostics,
    };
  }

  sharedRoot.createStorageDiagnosticsUtils = createStorageDiagnosticsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-sanitizer-utils.js ===== */
(function initPoseChronoSharedTimelineSanitizerUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? Math.round(num) : fallback;
  }

  function clamp(value, min, max, fallback = min) {
    const num = toInt(value, fallback);
    return Math.max(min, Math.min(max, num));
  }

  function createTimelineSanitizerUtils(options = {}) {
    const schemaVersion = Math.max(1, toInt(options.schemaVersion, 1));
    const minPoses = Math.max(0, toInt(options.minPoses, 1));
    const minTimeSeconds = Math.max(0, toInt(options.minTimeSeconds, 0));
    const maxTimePerSession = Math.max(
      minTimeSeconds,
      toInt(options.maxTimePerSession, 86400),
    );
    const nowIso =
      typeof options.nowIso === "function"
        ? options.nowIso
        : () => new Date().toISOString();

    function getDefaultData() {
      return {
        days: {},
        stats: {
          totalPoses: 0,
          totalTime: 0,
          currentStreak: 0,
          bestStreak: 0,
          lastSessionDate: null,
        },
      };
    }

    function sanitizeSessionImageEntry(image) {
      if (typeof image === "string") {
        const value = image.trim();
        if (!value) return null;
        return value.slice(0, 4096);
      }

      if (!image || typeof image !== "object") return null;

      const out = {};

      if (
        image.id !== undefined &&
        image.id !== null &&
        (typeof image.id === "string" || typeof image.id === "number")
      ) {
        out.id = image.id;
      }

      const copyString = (key, maxLen = 4096) => {
        if (typeof image[key] !== "string") return;
        const value = image[key].trim();
        if (!value) return;
        out[key] = value.slice(0, maxLen);
      };

      copyString("filePath");
      copyString("path");
      copyString("file");
      copyString("thumbnailURL");
      copyString("thumbnail");
      copyString("url");
      copyString("name", 256);
      copyString("ext", 32);

      if (Object.keys(out).length === 0) return null;
      return out;
    }

    function sanitizeSessionEntry(session) {
      if (!session || typeof session !== "object") return null;
      const poses = Math.max(0, toInt(session.poses, 0));
      const time = clamp(session.time, 0, maxTimePerSession, 0);
      if (poses < minPoses || time < minTimeSeconds) {
        return null;
      }
      const hour = clamp(session.hour, 0, 23, 0);
      const minute = clamp(session.minute, 0, 59, 0);
      const timestamp =
        typeof session.timestamp === "string" &&
        !Number.isNaN(Date.parse(session.timestamp))
          ? session.timestamp
          : nowIso();
      const mode =
        typeof session.mode === "string" ? session.mode.slice(0, 32) : "classique";
      const memoryType =
        session.memoryType === "flash" || session.memoryType === "progressive"
          ? session.memoryType
          : null;
      const customQueue = Array.isArray(session.customQueue) ? session.customQueue : null;
      const images = Array.isArray(session.images)
        ? session.images
            .map((img) => sanitizeSessionImageEntry(img))
            .filter(Boolean)
            .slice(0, 1000)
        : [];

      const isOnline = session.isOnline === true;

      return {
        timestamp,
        hour,
        minute,
        poses,
        time,
        mode,
        memoryType,
        customQueue,
        images,
        ...(isOnline ? { isOnline: true } : {}),
      };
    }

    function validateSessionValues(poses, time) {
      const validPoses = Math.max(0, toInt(poses, 0));
      const validTime = clamp(time, 0, maxTimePerSession, 0);
      const isValid = validPoses >= minPoses && validTime >= minTimeSeconds;
      return { poses: validPoses, time: validTime, isValid };
    }

    function sanitizeData(candidate) {
      const base = getDefaultData();
      const raw = candidate && typeof candidate === "object" ? candidate : {};
      let repaired = false;

      const rawDays = raw.days && typeof raw.days === "object" ? raw.days : {};
      if (!raw.days || typeof raw.days !== "object") repaired = true;

      for (const [dateKey, dayValue] of Object.entries(rawDays)) {
        if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
          repaired = true;
          continue;
        }
        const day = dayValue && typeof dayValue === "object" ? dayValue : {};
        if (!dayValue || typeof dayValue !== "object") repaired = true;

        const sessionsRaw = Array.isArray(day.sessions) ? day.sessions : [];
        if (!Array.isArray(day.sessions)) repaired = true;
        const sessions = sessionsRaw
          .map((s) => sanitizeSessionEntry(s))
          .filter(Boolean)
          .slice(-50);
        if (sessions.length !== sessionsRaw.length) repaired = true;

        const posesFromSessions = sessions.reduce((sum, s) => sum + (s.poses || 0), 0);
        const timeFromSessions = sessions.reduce((sum, s) => sum + (s.time || 0), 0);
        const posesRaw = Math.max(0, toInt(day.poses, 0));
        const timeRaw = Math.max(0, toInt(day.time, 0));
        const poses = sessions.length > 0 ? posesFromSessions : posesRaw;
        const time = sessions.length > 0 ? timeFromSessions : timeRaw;

        if (poses !== posesRaw || time !== timeRaw) repaired = true;

        base.days[dateKey] = { poses, time, sessions };
      }

      base.stats = {
        totalPoses: Math.max(0, toInt(raw.stats?.totalPoses, 0)),
        totalTime: Math.max(0, toInt(raw.stats?.totalTime, 0)),
        currentStreak: Math.max(0, toInt(raw.stats?.currentStreak, 0)),
        bestStreak: Math.max(0, toInt(raw.stats?.bestStreak, 0)),
        lastSessionDate:
          typeof raw.stats?.lastSessionDate === "string" &&
          /^\d{4}-\d{2}-\d{2}$/.test(raw.stats.lastSessionDate)
            ? raw.stats.lastSessionDate
            : null,
      };

      const computedPoses = Object.values(base.days).reduce(
        (sum, day) => sum + (day.poses || 0),
        0,
      );
      const computedTime = Object.values(base.days).reduce(
        (sum, day) => sum + (day.time || 0),
        0,
      );

      if (base.stats.totalPoses !== computedPoses || base.stats.totalTime !== computedTime) {
        repaired = true;
        base.stats.totalPoses = computedPoses;
        base.stats.totalTime = computedTime;
      }

      return { data: base, repaired };
    }

    function normalizePayload(rawPayload) {
      if (!rawPayload || typeof rawPayload !== "object") {
        const sanitized = sanitizeData(null);
        return {
          payload: {
            schemaVersion,
            data: sanitized.data,
          },
          data: sanitized.data,
          repaired: true,
        };
      }

      const sourceData =
        rawPayload.schemaVersion === schemaVersion && rawPayload.data
          ? rawPayload.data
          : rawPayload;
      const sanitized = sanitizeData(sourceData);
      const payload = {
        schemaVersion,
        data: sanitized.data,
      };

      const repaired =
        sanitized.repaired ||
        rawPayload.schemaVersion !== schemaVersion ||
        !rawPayload.data;

      return { payload, data: sanitized.data, repaired };
    }

    function mergeDayEntries(existingDay, incomingDay) {
      const base = existingDay && typeof existingDay === "object" ? existingDay : {};
      const next = incomingDay && typeof incomingDay === "object" ? incomingDay : {};

      const existingSessions = Array.isArray(base.sessions) ? base.sessions : [];
      const incomingSessions = Array.isArray(next.sessions) ? next.sessions : [];
      const mergedSessions = [];
      const seen = new Set();

      [...existingSessions, ...incomingSessions].forEach((session) => {
        if (!session || typeof session !== "object") return;
        const signature = [
          session.timestamp || "",
          session.hour ?? "",
          session.minute ?? "",
          session.poses ?? "",
          session.time ?? "",
          session.mode || "",
          session.memoryType || "",
          Array.isArray(session.images) ? session.images.length : 0,
        ].join("|");
        if (seen.has(signature)) return;
        seen.add(signature);
        mergedSessions.push(session);
      });

      mergedSessions.sort((a, b) => {
        const at = Date.parse(a?.timestamp || "") || 0;
        const bt = Date.parse(b?.timestamp || "") || 0;
        return at - bt;
      });

      const limitedSessions = mergedSessions.slice(-50);
      const posesFromSessions = limitedSessions.reduce(
        (sum, s) => sum + (Number(s?.poses) || 0),
        0,
      );
      const timeFromSessions = limitedSessions.reduce(
        (sum, s) => sum + (Number(s?.time) || 0),
        0,
      );

      return {
        poses:
          limitedSessions.length > 0
            ? posesFromSessions
            : Math.max(Number(base.poses) || 0, Number(next.poses) || 0),
        time:
          limitedSessions.length > 0
            ? timeFromSessions
            : Math.max(Number(base.time) || 0, Number(next.time) || 0),
        sessions: limitedSessions,
      };
    }

    function mergeTimelineDatas(datasets) {
      const merged = getDefaultData();
      const sources = Array.isArray(datasets) ? datasets : [];
      sources.forEach((data) => {
        if (!data || typeof data !== "object" || !data.days) return;
        Object.entries(data.days).forEach(([dateKey, day]) => {
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) return;
          if (!merged.days[dateKey]) {
            merged.days[dateKey] = mergeDayEntries(null, day);
            return;
          }
          merged.days[dateKey] = mergeDayEntries(merged.days[dateKey], day);
        });
      });
      return merged;
    }

    function listLocalCandidateKeys(storage, optionsArg = {}) {
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const baseKeys = Array.isArray(options.baseKeys) ? options.baseKeys : [];
      const backupPrefixes = Array.isArray(options.backupPrefixes)
        ? options.backupPrefixes
        : [];
      const includeBackupsIfPrimaryMissing =
        options.includeBackupsIfPrimaryMissing !== false;
      const maxBackupsPerPrefix = Math.max(
        0,
        toInt(options.maxBackupsPerPrefix, 2),
      );
      const keys = new Set(
        baseKeys
          .map((k) => String(k || "").trim())
          .filter(Boolean),
      );

      try {
        if (
          !storage ||
          typeof storage.length !== "number" ||
          typeof storage.key !== "function"
        ) {
          return Array.from(keys);
        }
        const hasPrimaryData = baseKeys.some((baseKey) => {
          const safeKey = String(baseKey || "").trim();
          if (!safeKey || typeof storage.getItem !== "function") return false;
          try {
            return storage.getItem(safeKey) != null;
          } catch (_) {
            return false;
          }
        });
        const shouldIncludeBackups =
          backupPrefixes.length > 0 &&
          (includeBackupsIfPrimaryMissing ? !hasPrimaryData : false);
        const backupBuckets = new Map();

        for (let i = 0; i < storage.length; i++) {
          const key = storage.key(i);
          if (!key) continue;
          if (!shouldIncludeBackups) continue;
          const backupPrefix = backupPrefixes.find((prefix) =>
            String(key).startsWith(prefix),
          );
          if (!backupPrefix) continue;
          if (!backupBuckets.has(backupPrefix)) {
            backupBuckets.set(backupPrefix, []);
          }
          backupBuckets.get(backupPrefix).push(key);
        }

        backupBuckets.forEach((bucketKeys) => {
          const sorted = bucketKeys.slice().sort().reverse();
          const kept =
            maxBackupsPerPrefix > 0
              ? sorted.slice(0, maxBackupsPerPrefix)
              : sorted;
          kept.forEach((backupKey) => keys.add(backupKey));
        });
      } catch (_) {}
      return Array.from(keys);
    }

    function isBackupTimelineKey(storageKey, backupPrefixes = []) {
      const key = String(storageKey || "");
      return backupPrefixes.some((prefix) => key.startsWith(String(prefix)));
    }

    function loadFromLocalStorageKey(
      storage,
      storageKey,
      normalizePayload,
      optionsArg = {},
    ) {
      const options =
        optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const onRepaired =
        typeof options.onRepaired === "function" ? options.onRepaired : null;
      const backupPrefixes = Array.isArray(options.backupPrefixes)
        ? options.backupPrefixes
        : [];
      const reportBackupRepairs = options.reportBackupRepairs === true;
      try {
        if (!storage || typeof storage.getItem !== "function") return null;
        const stored = storage.getItem(storageKey);
        if (!stored) return null;
        const parsed = JSON.parse(stored);
        if (typeof normalizePayload === "function") {
          const normalized = normalizePayload(parsed);
          if (normalized?.repaired && onRepaired) {
            const isBackup = isBackupTimelineKey(storageKey, backupPrefixes);
            if (!isBackup || reportBackupRepairs) {
              try {
                onRepaired(storageKey);
              } catch (_) {}
            }
          }
          return normalized && normalized.data ? normalized.data : null;
        }
        return parsed;
      } catch (_) {}
      return null;
    }

    function writeTimelineBackup(storage, payload, optionsArg = {}) {
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const prefix = String(options.prefix || "posechrono-timeline-backup:");
      const keep = Math.max(1, toInt(options.keep, 3));
      try {
        if (
          !storage ||
          typeof storage.setItem !== "function" ||
          typeof storage.removeItem !== "function" ||
          typeof storage.key !== "function"
        ) {
          return;
        }
        const key = `${prefix}${Date.now()}`;
        storage.setItem(key, JSON.stringify(payload));

        const backupKeys = [];
        for (let i = 0; i < storage.length; i++) {
          const existingKey = storage.key(i);
          if (existingKey && String(existingKey).startsWith(prefix)) {
            backupKeys.push(existingKey);
          }
        }
        backupKeys.sort();
        while (backupKeys.length > keep) {
          const oldest = backupKeys.shift();
          if (oldest) storage.removeItem(oldest);
        }
      } catch (_) {}
    }

    function loadLocalCandidates(
      storage,
      candidateKeys,
      normalizePayload,
      optionsArg = {},
    ) {
      const out = [];
      const keys = Array.isArray(candidateKeys) ? candidateKeys : [];
      const options =
        optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      keys.forEach((key) => {
        const data = loadFromLocalStorageKey(
          storage,
          key,
          normalizePayload,
          options,
        );
        if (!data) return;
        out.push(data);
      });
      return out;
    }

    function resolveLocalTimelineData(candidates, mergeTimelineDatas, getDefaultDataFn) {
      const list = Array.isArray(candidates) ? candidates : [];
      if (list.length === 0) {
        if (typeof getDefaultDataFn === "function") return getDefaultDataFn();
        return getDefaultData();
      }
      if (typeof mergeTimelineDatas === "function") {
        return mergeTimelineDatas(list);
      }
      return list[0] || getDefaultData();
    }

    function cloneData(data) {
      try {
        if (typeof structuredClone === "function") {
          return structuredClone(data);
        }
      } catch (_) {}
      return JSON.parse(JSON.stringify(data));
    }

    return {
      getDefaultData,
      sanitizeSessionImageEntry,
      sanitizeSessionEntry,
      validateSessionValues,
      sanitizeData,
      normalizePayload,
      mergeDayEntries,
      mergeTimelineDatas,
      listLocalCandidateKeys,
      writeTimelineBackup,
      loadFromLocalStorageKey,
      loadLocalCandidates,
      resolveLocalTimelineData,
      cloneData,
    };
  }

  sharedRoot.createTimelineSanitizerUtils = createTimelineSanitizerUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-date-utils.js ===== */
(function initPoseChronoSharedTimelineDateUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createTimelineDateUtils() {
    function toKey(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function getToday() {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return today;
    }

    function isSameDay(d1, d2) {
      return d1.toDateString() === d2.toDateString();
    }

    function isFuture(date, today) {
      return date > today;
    }

    function getMondayBefore(date) {
      const result = new Date(date);
      const dayOfWeek = result.getDay();
      const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
      result.setDate(result.getDate() + diff);
      result.setHours(0, 0, 0, 0);
      return result;
    }

    function getYearStartDate(year) {
      const jan1 = new Date(year, 0, 1);
      return getMondayBefore(jan1);
    }

    function diffInDays(d1, d2) {
      return Math.floor((d1 - d2) / (1000 * 60 * 60 * 24));
    }

    return {
      toKey,
      getToday,
      isSameDay,
      isFuture,
      getMondayBefore,
      getYearStartDate,
      diffInDays,
    };
  }

  sharedRoot.createTimelineDateUtils = createTimelineDateUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-media-utils.js ===== */
(function initPoseChronoSharedTimelineMediaUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toFileUrl(path) {
    if (typeof path !== "string") return "";
    const raw = path.trim();
    if (!raw) return "";
    if (/^(https?:|file:|data:|blob:)/i.test(raw)) return raw;

    const normalized = raw.replace(/\\/g, "/");
    if (/^[a-zA-Z]:\//.test(normalized)) {
      return `file:///${normalized}`;
    }
    if (normalized.startsWith("//")) {
      return `file:${normalized}`;
    }
    if (normalized.startsWith("/")) {
      return `file://${normalized}`;
    }
    return normalized;
  }

  function resolveTimelineImageSrc(image) {
    if (typeof image === "string") {
      return toFileUrl(image);
    }
    if (!image || typeof image !== "object") return "";

    const direct = [image.thumbnailURL, image.thumbnail, image.url].find(
      (v) => typeof v === "string" && v.trim().length > 0,
    );
    if (direct) return toFileUrl(direct);

    const fromPath = [image.filePath, image.path, image.file].find(
      (v) => typeof v === "string" && v.trim().length > 0,
    );
    return toFileUrl(fromPath || "");
  }

  function createTimelineMediaUtils() {
    return {
      toFileUrl,
      resolveTimelineImageSrc,
    };
  }

  sharedRoot.createTimelineMediaUtils = createTimelineMediaUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-display-utils.js ===== */
(function initPoseChronoSharedTimelineDisplayUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function esc(input) {
    const str = String(input ?? "");
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function createTimelineDisplayUtils(deps = {}) {
    const t = typeof deps.t === "function" ? deps.t : null;
    const formatTime =
      typeof deps.formatTime === "function" ? deps.formatTime : (seconds) => String(seconds || 0);

    function translate(key, options, fallback) {
      if (t) {
        return t(key, options || {}, fallback || "");
      }
      return fallback || "";
    }

    function getDayLabels() {
      const result = translate("timeline.dayLabels", { returnObjects: true }, null);
      if (Array.isArray(result)) return result;
      return ["L", "M", "M", "J", "V", "S", "D"];
    }

    function getMonthLabels() {
      const result = translate("timeline.monthLabels", { returnObjects: true }, null);
      if (Array.isArray(result)) return result;
      return [
        "janv.",
        "fvr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "aot",
        "sept.",
        "oct.",
        "nov.",
        "dc.",
      ];
    }

    function getModeLabel(mode, memoryType) {
      const labels = {
        classique: translate("modes.classic.title", {}, "Classique"),
        custom: translate("modes.custom.title", {}, "Personnalis"),
        relax: translate("modes.relax.title", {}, "Tranquille"),
        memory: translate("modes.memory.title", {}, "Mmoire"),
      };

      let label = labels[mode] || mode;
      if (mode === "memory" && memoryType) {
        const memoryTypeLabels = {
          flash: translate("modes.memory.flash", {}, "Flash"),
          progressive: translate("modes.memory.progressive", {}, "Progressif"),
        };
        const typeLabel = memoryTypeLabels[memoryType] || memoryType;
        label += ` (${typeLabel})`;
      }
      return label;
    }

    function formatCustomStructure(customQueue) {
      if (!customQueue || customQueue.length === 0) return "";

      const title = `<div class="custom-structure-title">${translate("timeline.sessionPlan", {}, "Plan de la session")}</div>`;

      const steps = customQueue.map((step) => {
        const timeStr = esc(formatTime(step.duration));
        if (step.type === "pause") {
          return `<div class="custom-step pause">${translate("timeline.pauseStep", {}, "Pause")} ${timeStr}</div>`;
        }
        const poseWord =
          step.count > 1
            ? translate("timeline.poses", {}, "poses")
            : translate("timeline.pose", {}, "pose");
        return `<div class="custom-step pose">${esc(step.count)} ${poseWord} ${translate("timeline.of", {}, "de")} ${timeStr}</div>`;
      });

      return title + steps.join("");
    }

    return {
      getDayLabels,
      getMonthLabels,
      getModeLabel,
      formatCustomStructure,
    };
  }

  sharedRoot.createTimelineDisplayUtils = createTimelineDisplayUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-feedback-utils.js ===== */
(function initPoseChronoSharedTimelineFeedbackUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createTimelineFeedbackUtils(deps = {}) {
    const doc =
      deps.document ||
      (typeof document !== "undefined" ? document : null);
    const raf =
      typeof deps.requestAnimationFrame === "function"
        ? deps.requestAnimationFrame
        : typeof requestAnimationFrame === "function"
          ? requestAnimationFrame
          : (cb) => cb();
    const scheduleTimeout =
      typeof deps.setTimeout === "function" ? deps.setTimeout : setTimeout;
    const cancelTimeout =
      typeof deps.clearTimeout === "function" ? deps.clearTimeout : clearTimeout;

    async function openConfirmDialog(options = {}) {
      const {
        title = "",
        message = "",
        confirmText = "OK",
        cancelText = "Cancel",
        checkboxLabel = "",
      } = options;

      if (typeof deps.showPoseChronoConfirmDialog === "function") {
        return deps.showPoseChronoConfirmDialog({
          title,
          message,
          confirmText,
          cancelText,
          checkboxLabel,
        });
      }

      if (typeof deps.showMessageBox === "function") {
        try {
          const result = await deps.showMessageBox({
            type: "warning",
            title,
            message,
            buttons: [cancelText, confirmText],
            defaultId: 0,
            cancelId: 0,
            ...(checkboxLabel ? { checkboxLabel } : {}),
          });

          return {
            confirmed: result.response === 1,
            checkboxChecked: !!result.checkboxChecked,
          };
        } catch (error) {
          if (typeof deps.logError === "function") {
            deps.logError(error);
          }
        }
      }

      return { confirmed: false, checkboxChecked: false };
    }

    function showToast(type, message, duration = 2500) {
      if (typeof deps.showPoseChronoToast === "function") {
        deps.showPoseChronoToast({ type, message, duration });
        return;
      }

      if (typeof deps.notify === "function") {
        deps.notify({
          title: message,
          body: "",
          mute: false,
          duration,
        });
      }
    }

    function scheduleUndoAction(options = {}) {
      if (typeof deps.schedulePoseChronoUndoAction === "function") {
        deps.schedulePoseChronoUndoAction(options);
        return true;
      }

      const {
        timeoutMs = 10000,
        onUndo,
        message = "Deleted. Undo available for 10 seconds.",
        undoLabel = "Undo",
      } = options;
      if (typeof onUndo !== "function" || !doc || !doc.body) return false;

      let container = doc.getElementById("posechrono-toast-container");
      if (!container) {
        container = doc.createElement("div");
        container.id = "posechrono-toast-container";
        container.className = "pc-toast-container";
        doc.body.appendChild(container);
      }

      const toast = doc.createElement("div");
      toast.className = "pc-toast pc-toast-info";

      const msg = doc.createElement("span");
      msg.className = "pc-toast-message";
      msg.textContent = message;
      toast.appendChild(msg);

      const btn = doc.createElement("button");
      btn.type = "button";
      btn.className = "pc-toast-action";
      btn.textContent = undoLabel;
      let timer = null;
      btn.addEventListener("click", () => {
        if (timer !== null) cancelTimeout(timer);
        try {
          onUndo();
        } catch (_) {}
        toast.classList.remove("visible");
        scheduleTimeout(() => toast.remove(), 180);
      });
      toast.appendChild(btn);

      container.appendChild(toast);
      raf(() => toast.classList.add("visible"));

      timer = scheduleTimeout(() => {
        toast.classList.remove("visible");
        scheduleTimeout(() => toast.remove(), 180);
      }, timeoutMs);

      return true;
    }

    return {
      openConfirmDialog,
      showToast,
      scheduleUndoAction,
    };
  }

  sharedRoot.createTimelineFeedbackUtils = createTimelineFeedbackUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-format-utils.js ===== */
(function initPoseChronoSharedTimelineFormatUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSafeSeconds(value) {
    return Math.max(0, Math.floor(Number(value) || 0));
  }

  function createTimelineFormatUtils(options = {}) {
    const getLocale =
      typeof options.getLocale === "function" ? options.getLocale : () => "en-US";
    const minuteLabel =
      typeof options.minuteLabel === "string" && options.minuteLabel
        ? options.minuteLabel
        : "min";

    function formatNumber(num) {
      try {
        return Number(num || 0).toLocaleString(getLocale());
      } catch (_) {
        return String(Number(num || 0));
      }
    }

    function formatTime(seconds) {
      const safe = toSafeSeconds(seconds);
      if (safe <= 0) return "0s";

      const hours = Math.floor(safe / 3600);
      const minutes = Math.floor((safe % 3600) / 60);
      const secs = safe % 60;
      const parts = [];

      if (hours > 0) parts.push(`${hours}h`);
      if (minutes > 0) parts.push(`${minutes}${minuteLabel}`);
      if (secs > 0 && hours === 0) parts.push(`${secs}s`);

      if (parts.length === 0) return "0s";
      return parts.join(" ");
    }

    function formatDate(date, optionsArg) {
      const options =
        optionsArg || { weekday: "long", day: "numeric", month: "long" };
      try {
        return date.toLocaleDateString(getLocale(), options);
      } catch (_) {
        return String(date);
      }
    }

    return {
      toSafeSeconds,
      formatNumber,
      formatTime,
      formatDate,
    };
  }

  sharedRoot.createTimelineFormatUtils = createTimelineFormatUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

