/* Auto-generated by scripts/build-shared-bundle.js */
/* Sources: 45 files */

/* ===== packages/shared/frame-mode-detection.js ===== */
// Detect frame mode early to show custom title bar when needed.
(async function detectFrameMode() {
  try {
    const response = await fetch("manifest.json");
    const manifest = await response.json();
    if (manifest.main && manifest.main.frame === false) {
      document.body.classList.add("frameless");
    }
  } catch (_) {
    // Keep current fallback behavior: assume frameless if detection fails.
    document.body.classList.add("frameless");
  }
})();

/* ===== packages/shared/preferences-core.js ===== */
(function initPoseChronoSharedPreferencesCore(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const SESSION_MODES = ["classique", "custom", "relax", "memory"];
  const SESSION_MODE_SET = new Set(SESSION_MODES);

  function normalizeSessionModeValue(mode, fallback = "classique") {
    const normalized = String(mode ?? "")
      .trim()
      .toLowerCase();
    const fallbackNormalized = String(fallback ?? "classique")
      .trim()
      .toLowerCase();
    if (SESSION_MODE_SET.has(normalized)) return normalized;
    return SESSION_MODE_SET.has(fallbackNormalized)
      ? fallbackNormalized
      : "classique";
  }

  function normalizeStringArray(input) {
    if (!Array.isArray(input)) return [];
    const seen = new Set();
    const out = [];
    input.forEach((entry) => {
      if (typeof entry !== "string") return;
      const key = entry.trim();
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(key);
    });
    return out;
  }

  function createDefaultSessionModeUtils(options = {}) {
    const normalize =
      typeof options.normalizeSessionModeValue === "function"
        ? options.normalizeSessionModeValue
        : normalizeSessionModeValue;
    const getValue =
      typeof options.getValue === "function" ? options.getValue : () => undefined;
    const setValue =
      typeof options.setValue === "function" ? options.setValue : null;

    function load(fallback = "classique") {
      const safeFallback = normalize(fallback);
      try {
        const value = getValue();
        if (value === undefined || value === null || value === "") {
          return safeFallback;
        }
        return normalize(value, safeFallback);
      } catch (_) {
        return safeFallback;
      }
    }

    function save(mode, persist = true) {
      const next = normalize(mode);
      if (!persist || typeof setValue !== "function") return next;
      try {
        setValue(next);
      } catch (_) {}
      return next;
    }

    return {
      load,
      save,
    };
  }

  sharedRoot.prefs = {
    SESSION_MODES: SESSION_MODES.slice(),
    normalizeSessionModeValue,
    normalizeStringArray,
    createDefaultSessionModeUtils,
  };

  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/ui-preferences.js ===== */
(function initPoseChronoSharedUIPreferences(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createUIPreferences(options = {}) {
    const storage =
      options.storage ||
      (typeof localStorage !== "undefined" ? localStorage : null);

    const storageKey = String(options.storageKey || "posechrono-ui-prefs");
    const schemaVersion = Number(options.schemaVersion || 1);

    const legacyKeys = options.legacyKeys || {};
    const legacyDefaultSessionModeStorageKey = String(
      options.legacyDefaultSessionModeStorageKey || "posechrono-default-session-mode",
    );

    const normalizeSessionModeValue =
      typeof options.normalizeSessionModeValue === "function"
        ? options.normalizeSessionModeValue
        : (value, fallback = "classique") => {
            const modes = new Set(["classique", "custom", "relax", "memory"]);
            const normalized = String(value ?? "")
              .trim()
              .toLowerCase();
            const fallbackNormalized = String(fallback ?? "classique")
              .trim()
              .toLowerCase();
            return modes.has(normalized)
              ? normalized
              : modes.has(fallbackNormalized)
                ? fallbackNormalized
                : "classique";
          };

    const normalizeStringArray =
      typeof options.normalizeStringArray === "function"
        ? options.normalizeStringArray
        : (input) => {
            if (!Array.isArray(input)) return [];
            const seen = new Set();
            const out = [];
            input.forEach((entry) => {
              if (typeof entry !== "string") return;
              const key = entry.trim();
              if (!key || seen.has(key)) return;
              seen.add(key);
              out.push(key);
            });
            return out;
          };

    const defaultsInput = options.defaults || {};
    const BASE_DEFAULT_GRID_ENABLED = !!defaultsInput.backgroundGridEnabled;
    const BASE_DEFAULT_TITLEBAR_ALWAYS_VISIBLE =
      !!defaultsInput.titlebarAlwaysVisible;
    const BASE_DEFAULT_SESSION_MODE = normalizeSessionModeValue(
      defaultsInput.defaultSessionMode,
      "classique",
    );
    const BASE_DEFAULT_REVIEW_DURATIONS_VISIBLE =
      defaultsInput.reviewDurationsVisible !== false;
    const BASE_DEFAULT_HOTKEYS_COLLAPSED = normalizeStringArray(
      defaultsInput.hotkeysCollapsedCategories,
    );
    const BASE_DEFAULT_GLOBAL_SETTINGS_COLLAPSED = normalizeStringArray(
      defaultsInput.globalSettingsCollapsedCategories?.length
        ? defaultsInput.globalSettingsCollapsedCategories
        : ["maintenance"],
    );
    const BASE_DEFAULT_PREFERRED_LANGUAGE =
      typeof defaultsInput.preferredLanguage === "string" &&
      defaultsInput.preferredLanguage.trim()
        ? defaultsInput.preferredLanguage.trim().toLowerCase()
        : "";

    const getDefaultPrefs = () => ({
      schemaVersion,
      backgroundGridEnabled: BASE_DEFAULT_GRID_ENABLED,
      titlebarAlwaysVisible: BASE_DEFAULT_TITLEBAR_ALWAYS_VISIBLE,
      defaultSessionMode: BASE_DEFAULT_SESSION_MODE,
      reviewDurationsVisible: BASE_DEFAULT_REVIEW_DURATIONS_VISIBLE,
      hotkeysCollapsedCategories: BASE_DEFAULT_HOTKEYS_COLLAPSED,
      globalSettingsCollapsedCategories: BASE_DEFAULT_GLOBAL_SETTINGS_COLLAPSED,
      preferredLanguage: BASE_DEFAULT_PREFERRED_LANGUAGE,
    });

    let cache = null;

    const persist = () => {
      if (!cache || !storage) return;
      try {
        storage.setItem(storageKey, JSON.stringify(cache));
      } catch (_) {}
    };

    const load = () => {
      if (cache) return cache;

      const defaults = getDefaultPrefs();
      let parsed = {};
      let changed = false;

      if (storage) {
        try {
          const raw = storage.getItem(storageKey);
          if (raw) {
            const obj = JSON.parse(raw);
            if (obj && typeof obj === "object") {
              parsed = obj;
            }
          }
        } catch (_) {
          changed = true;
        }
      }

      cache = {
        ...defaults,
        ...parsed,
        schemaVersion,
      };

      cache.backgroundGridEnabled = !!cache.backgroundGridEnabled;
      cache.titlebarAlwaysVisible = !!cache.titlebarAlwaysVisible;
      cache.reviewDurationsVisible = cache.reviewDurationsVisible !== false;
      cache.defaultSessionMode = normalizeSessionModeValue(
        cache.defaultSessionMode,
        defaults.defaultSessionMode,
      );
      cache.hotkeysCollapsedCategories = normalizeStringArray(
        cache.hotkeysCollapsedCategories,
      );
      cache.globalSettingsCollapsedCategories = normalizeStringArray(
        cache.globalSettingsCollapsedCategories,
      );
      cache.preferredLanguage =
        typeof cache.preferredLanguage === "string"
          ? cache.preferredLanguage.trim().toLowerCase()
          : "";

      if (
        !Object.prototype.hasOwnProperty.call(parsed, "reviewDurationsVisible")
      ) {
        try {
          if (storage && legacyKeys.REVIEW_DURATIONS_VISIBLE) {
            const raw = storage.getItem(legacyKeys.REVIEW_DURATIONS_VISIBLE);
            if (raw !== null) {
              cache.reviewDurationsVisible = raw !== "0";
              changed = true;
              storage.removeItem(legacyKeys.REVIEW_DURATIONS_VISIBLE);
            }
          }
        } catch (_) {}
      }

      if (
        !Object.prototype.hasOwnProperty.call(
          parsed,
          "globalSettingsCollapsedCategories",
        )
      ) {
        try {
          if (storage && legacyKeys.GLOBAL_SETTINGS_COLLAPSED) {
            const raw = storage.getItem(legacyKeys.GLOBAL_SETTINGS_COLLAPSED);
            if (raw) {
              cache.globalSettingsCollapsedCategories = normalizeStringArray(
                JSON.parse(raw),
              );
              changed = true;
              storage.removeItem(legacyKeys.GLOBAL_SETTINGS_COLLAPSED);
            }
          }
        } catch (_) {}
      }

      if (!Object.prototype.hasOwnProperty.call(parsed, "defaultSessionMode")) {
        try {
          if (storage) {
            const raw = storage.getItem(legacyDefaultSessionModeStorageKey);
            if (raw) {
              cache.defaultSessionMode = normalizeSessionModeValue(
                raw,
                defaults.defaultSessionMode,
              );
              changed = true;
              storage.removeItem(legacyDefaultSessionModeStorageKey);
            }
          }
        } catch (_) {}
      }

      if (changed) persist();
      return cache;
    };

    const sanitizeByKey = (key, value) => {
      switch (key) {
        case "backgroundGridEnabled":
        case "titlebarAlwaysVisible":
        case "reviewDurationsVisible":
          return !!value;
        case "defaultSessionMode":
          return normalizeSessionModeValue(value, BASE_DEFAULT_SESSION_MODE);
        case "hotkeysCollapsedCategories":
        case "globalSettingsCollapsedCategories":
          return normalizeStringArray(value);
        case "preferredLanguage":
          return typeof value === "string" ? value.trim().toLowerCase() : "";
        default:
          return value;
      }
    };

    return {
      init() {
        return load();
      },
      get(key, fallback = undefined) {
        const prefs = load();
        return Object.prototype.hasOwnProperty.call(prefs, key)
          ? prefs[key]
          : fallback;
      },
      set(key, value, optionsArg = {}) {
        const { persist: shouldPersist = true } = optionsArg || {};
        const prefs = load();
        prefs[key] = sanitizeByKey(key, value);
        if (shouldPersist) persist();
        return prefs[key];
      },
      getStringArray(key) {
        return normalizeStringArray(this.get(key, []));
      },
      setStringArray(key, value, optionsArg = {}) {
        return this.set(key, normalizeStringArray(value), optionsArg);
      },
      exportData() {
        const prefs = load();
        return {
          schemaVersion,
          backgroundGridEnabled: !!prefs.backgroundGridEnabled,
          titlebarAlwaysVisible: !!prefs.titlebarAlwaysVisible,
          defaultSessionMode: normalizeSessionModeValue(
            prefs.defaultSessionMode,
            BASE_DEFAULT_SESSION_MODE,
          ),
          reviewDurationsVisible: !!prefs.reviewDurationsVisible,
          hotkeysCollapsedCategories: normalizeStringArray(
            prefs.hotkeysCollapsedCategories,
          ),
          globalSettingsCollapsedCategories: normalizeStringArray(
            prefs.globalSettingsCollapsedCategories,
          ),
          preferredLanguage:
            typeof prefs.preferredLanguage === "string"
              ? prefs.preferredLanguage.trim().toLowerCase()
              : "",
        };
      },
      importData(data, optionsArg = {}) {
        if (!data || typeof data !== "object") return false;
        const { persist: shouldPersist = true } = optionsArg || {};
        const prefs = load();
        const knownKeys = [
          "backgroundGridEnabled",
          "titlebarAlwaysVisible",
          "defaultSessionMode",
          "reviewDurationsVisible",
          "hotkeysCollapsedCategories",
          "globalSettingsCollapsedCategories",
          "preferredLanguage",
        ];
        let changed = false;
        knownKeys.forEach((key) => {
          if (!Object.prototype.hasOwnProperty.call(data, key)) return;
          prefs[key] = sanitizeByKey(key, data[key]);
          changed = true;
        });
        if (changed && shouldPersist) persist();
        return changed;
      },
      resetVisualPrefs() {
        cache = getDefaultPrefs();
        persist();
        return this.exportData();
      },
    };
  }

  sharedRoot.createUIPreferences = createUIPreferences;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/i18n-utils.js ===== */
(function initPoseChronoSharedI18nUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function getLocale(i18nInstance, fallback = "en-US") {
    try {
      const i18n = i18nInstance || (typeof i18next !== "undefined" ? i18next : null);
      if (i18n && typeof i18n.t === "function") {
        const locale = i18n.t("_locale");
        if (locale && locale !== "_locale") return locale;
      }
    } catch (_) {}
    return fallback;
  }

  function t(i18nInstance, key, options = {}, fallback = "") {
    try {
      const i18n = i18nInstance || (typeof i18next !== "undefined" ? i18next : null);
      if (i18n && typeof i18n.t === "function") {
        const result = i18n.t(key, options || {});
        return result !== key ? result : fallback;
      }
    } catch (_) {}
    return fallback;
  }

  function tCountLabel(
    i18nInstance,
    key,
    count,
    fallbackSingular = "",
    fallbackPlural = "",
  ) {
    const safeCount = Number.isFinite(Number(count)) ? Number(count) : 0;
    const fallback = safeCount === 1 ? fallbackSingular : fallbackPlural;
    return t(i18nInstance, key, { count: safeCount, defaultValue: fallback }, fallback);
  }

  sharedRoot.i18n = {
    getLocale,
    t,
    tCountLabel,
  };

  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/i18n-loader-utils.js ===== */
(function initPoseChronoSharedI18nLoaderUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function normalizeLocaleToken(token) {
    if (!token) return "";
    return String(token).trim().replace(/_/g, "-").toLowerCase();
  }

  function resolveLocaleLang(token, localeAliases, localeFileByLang) {
    const normalized = normalizeLocaleToken(token);
    if (!normalized) return null;

    if (localeAliases && localeAliases[normalized]) {
      return localeAliases[normalized];
    }

    const primary = normalized.split("-")[0];
    if (localeFileByLang && localeFileByLang[primary]) {
      return primary;
    }
    return null;
  }

  function createI18nLoaderUtils(options = {}) {
    const i18nextInstance = options.i18nextInstance || null;
    const fetchImpl =
      typeof options.fetchImpl === "function" ? options.fetchImpl : null;
    const windowObj = options.windowObj || null;
    const documentObj = options.documentObj || null;
    const navigatorObj = options.navigatorObj || null;
    const localesPath = String(options.localesPath || "./_locales/");
    const baseLang = String(options.baseLang || "en");
    const localeFileByLang = options.localeFileByLang || {};
    const localeAliases = options.localeAliases || {};
    const localeGetter =
      typeof options.localeGetter === "function" ? options.localeGetter : null;
    const cacheStorage =
      options.cacheStorage ||
      (windowObj && windowObj.localStorage ? windowObj.localStorage : null);
    const cacheEnabled = options.cacheEnabled !== false && !!cacheStorage;
    const cachePrefix = String(options.cachePrefix || "posechrono-i18n-cache");
    const cacheTtlMsRaw = Number(options.cacheTtlMs);
    const cacheTtlMs =
      Number.isFinite(cacheTtlMsRaw) && cacheTtlMsRaw > 0
        ? cacheTtlMsRaw
        : 7 * 24 * 60 * 60 * 1000;
    let cacheVersion =
      options.cacheVersion === null || options.cacheVersion === undefined
        ? ""
        : String(options.cacheVersion);
    const pendingRefreshByLang = new Map();

    function normalizeLanguageToken(token) {
      const lang = resolveLocaleLang(token, localeAliases, localeFileByLang);
      if (!lang) return null;
      if (!Object.prototype.hasOwnProperty.call(localeFileByLang, lang)) return null;
      return lang;
    }

    function buildCacheKey(lang) {
      const versionToken = String(cacheVersion || "").trim();
      if (!versionToken) return `${cachePrefix}:${lang}`;
      return `${cachePrefix}:${versionToken}:${lang}`;
    }

    function readCachedLocale(lang) {
      if (!cacheEnabled || !cacheStorage) return null;
      try {
        const raw = cacheStorage.getItem(buildCacheKey(lang));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const translation = parsed.translation;
        if (!translation || typeof translation !== "object") return null;
        const savedAt = Number(parsed.savedAt) || 0;
        const expired = !savedAt || Date.now() - savedAt > cacheTtlMs;
        return {
          translation,
          expired,
          savedAt,
        };
      } catch (_) {
        return null;
      }
    }

    function writeCachedLocale(lang, translation) {
      if (!cacheEnabled || !cacheStorage) return;
      if (!translation || typeof translation !== "object") return;
      try {
        cacheStorage.setItem(
          buildCacheKey(lang),
          JSON.stringify({
            lang,
            version: String(cacheVersion || ""),
            savedAt: Date.now(),
            translation,
          }),
        );
      } catch (_) {}
    }

    function setCacheVersion(nextVersion) {
      cacheVersion =
        nextVersion === null || nextVersion === undefined
          ? ""
          : String(nextVersion);
      return cacheVersion;
    }

    function getPreferredLocaleLang() {
      const candidates = [];

      if (typeof localeGetter === "function") {
        candidates.push(localeGetter());
      }

      if (i18nextInstance && typeof i18nextInstance.language === "string") {
        candidates.push(i18nextInstance.language);
      }

      if (
        documentObj &&
        documentObj.documentElement &&
        typeof documentObj.documentElement.lang === "string"
      ) {
        candidates.push(documentObj.documentElement.lang);
      }

      if (navigatorObj) {
        if (Array.isArray(navigatorObj.languages)) {
          candidates.push(...navigatorObj.languages);
        }
        if (typeof navigatorObj.language === "string") {
          candidates.push(navigatorObj.language);
        }
      }

      if (windowObj && typeof windowObj.getLocale === "function") {
        candidates.push(windowObj.getLocale());
      }

      for (const candidate of candidates) {
        const lang = resolveLocaleLang(candidate, localeAliases, localeFileByLang);
        if (lang) return lang;
      }

      return baseLang;
    }

    async function fetchLocaleTranslations(fileName) {
      if (!fetchImpl || !fileName) return null;
      try {
        const response = await fetchImpl(`${localesPath}${fileName}`);
        if (!response || !response.ok) return null;
        return await response.json();
      } catch (_) {
        return null;
      }
    }

    async function fetchAndCacheLocale(language) {
      const normalizedLanguage = normalizeLanguageToken(language);
      if (!normalizedLanguage) return null;

      if (pendingRefreshByLang.has(normalizedLanguage)) {
        return pendingRefreshByLang.get(normalizedLanguage);
      }

      const run = (async () => {
        const fileName = localeFileByLang[normalizedLanguage];
        if (!fileName) return null;
        const payload = await fetchLocaleTranslations(fileName);
        if (payload && typeof payload === "object") {
          writeCachedLocale(normalizedLanguage, payload);
          return payload;
        }
        return null;
      })();

      pendingRefreshByLang.set(normalizedLanguage, run);
      try {
        return await run;
      } finally {
        pendingRefreshByLang.delete(normalizedLanguage);
      }
    }

    async function loadTranslationsForLanguage(language) {
      const normalizedLanguage = normalizeLanguageToken(language);
      if (!normalizedLanguage) return null;

      const cached = readCachedLocale(normalizedLanguage);
      if (cached && cached.translation) {
        if (cached.expired) {
          void fetchAndCacheLocale(normalizedLanguage);
        }
        return cached.translation;
      }

      return await fetchAndCacheLocale(normalizedLanguage);
    }

    async function loadTranslations() {
      if (!i18nextInstance) return false;

      const preferredLang = getPreferredLocaleLang();
      const baseFileName = localeFileByLang[baseLang];
      if (!baseFileName) return false;

      const baseTranslations = await loadTranslationsForLanguage(baseLang);
      if (!baseTranslations) return false;

      const resources = {
        [baseLang]: {
          translation: baseTranslations,
        },
      };

      if (
        preferredLang !== baseLang &&
        Object.prototype.hasOwnProperty.call(localeFileByLang, preferredLang)
      ) {
        const preferredTranslations =
          await loadTranslationsForLanguage(preferredLang);
        if (preferredTranslations) {
          resources[preferredLang] = {
            translation: preferredTranslations,
          };
        }
      }

      const activeLang = resources[preferredLang] ? preferredLang : baseLang;
      const canInit = typeof i18nextInstance.init === "function";
      const isInitialized = !!i18nextInstance.isInitialized;

      if (!isInitialized && canInit) {
        await i18nextInstance.init({
          lng: activeLang,
          fallbackLng: baseLang,
          resources,
        });
        return true;
      }

      if (typeof i18nextInstance.addResourceBundle === "function") {
        Object.entries(resources).forEach(([lang, payload]) => {
          i18nextInstance.addResourceBundle(
            lang,
            "translation",
            payload.translation,
            true,
            true,
          );
        });
      }

      if (typeof i18nextInstance.changeLanguage === "function") {
        await i18nextInstance.changeLanguage(activeLang);
        return true;
      }

      if (canInit) {
        await i18nextInstance.init({
          lng: activeLang,
          fallbackLng: baseLang,
          resources,
        });
        return true;
      }

      return false;
    }

    return {
      loadTranslations,
      getPreferredLocaleLang,
      loadTranslationsForLanguage,
      setCacheVersion,
    };
  }

  sharedRoot.createI18nLoaderUtils = createI18nLoaderUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/dom-safety-utils.js ===== */
(function initPoseChronoSharedDomSafetyUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function escapeHtml(input) {
    const str = String(input ?? "");
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function encodeDataToken(input) {
    return encodeURIComponent(String(input ?? ""));
  }

  function decodeDataToken(input) {
    try {
      return decodeURIComponent(String(input ?? ""));
    } catch (_) {
      return String(input ?? "");
    }
  }

  function createDomSafetyUtils() {
    return {
      escapeHtml,
      encodeDataToken,
      decodeDataToken,
    };
  }

  sharedRoot.createDomSafetyUtils = createDomSafetyUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/storage-adapter.js ===== */
(function initPoseChronoSharedStorageAdapter(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createStorageAdapter(options = {}) {
    const DB_NAME = "posechrono-storage";
    const DB_VERSION = 1;
    const STORE_NAME = "kv";
    const FALLBACK_PREFIX = "posechrono-db:";
    const OPEN_TIMEOUT_MS = Math.max(
      200,
      Number(options.openTimeoutMs) || 1200,
    );
    const DISABLED_COOLDOWN_MS = Math.max(
      1000,
      Number(options.disabledCooldownMs) || 12 * 60 * 60 * 1000,
    );
    const DISABLED_UNTIL_KEY = `${FALLBACK_PREFIX}__indexeddb_disabled_until__`;
    const forceFallbackMode =
      options.forceFallbackMode === true ||
      (globalObj.poseChronoDesktop &&
        globalObj.poseChronoDesktop.platform === "desktop");
    let openPromise = null;
    let indexedDbAvailable = !forceFallbackMode;
    let fallbackNotified = false;
    let notify = typeof options.notify === "function" ? options.notify : null;

    function configure(nextOptions = {}) {
      if (typeof nextOptions.notify === "function") {
        notify = nextOptions.notify;
      }
    }

    const i18nText = (key, fallback) => {
      try {
        if (
          typeof i18next !== "undefined" &&
          typeof i18next.t === "function"
        ) {
          return i18next.t(key, { defaultValue: fallback });
        }
      } catch (_) {}
      return fallback;
    };

    const getDesktopStorageApi = () => {
      try {
        const api = globalObj.poseChronoDesktop?.storage;
        if (!api || typeof api !== "object") return null;
        if (
          typeof api.getJson !== "function" ||
          typeof api.setJson !== "function" ||
          typeof api.remove !== "function"
        ) {
          return null;
        }
        return api;
      } catch (_) {
        return null;
      }
    };

    const notifyFallbackMode = () => {
      if (fallbackNotified) return;
      fallbackNotified = true;
      const message = i18nText(
        "storage.fallbackActive",
        "Storage fallback enabled: IndexedDB unavailable, using local storage.",
      );

      if (
        typeof globalObj.showPoseChronoToast === "function"
      ) {
        globalObj.showPoseChronoToast({
          type: "error",
          message,
          duration: 5000,
        });
        return;
      }

      if (typeof notify === "function") {
        notify({
          title: message,
          body: "",
          mute: false,
          duration: 5000,
        });
      }
    };

    const cloneValue = (value) => {
      try {
        if (typeof structuredClone === "function") {
          return structuredClone(value);
        }
      } catch (_) {}
      return JSON.parse(JSON.stringify(value));
    };

    const readDisabledUntil = () => {
      try {
        const raw = localStorage.getItem(DISABLED_UNTIL_KEY);
        const until = Number(raw);
        if (!Number.isFinite(until) || until <= 0) return 0;
        if (until <= Date.now()) {
          localStorage.removeItem(DISABLED_UNTIL_KEY);
          return 0;
        }
        return until;
      } catch (_) {
        return 0;
      }
    };

    const writeDisabledUntil = (durationMs = DISABLED_COOLDOWN_MS) => {
      try {
        const until = Date.now() + Math.max(1000, Number(durationMs) || 0);
        localStorage.setItem(DISABLED_UNTIL_KEY, String(until));
      } catch (_) {}
    };

    const openDb = () => {
      if (!indexedDbAvailable) return Promise.resolve(null);
      if (openPromise) return openPromise;
      const disabledUntil = readDisabledUntil();
      if (disabledUntil > Date.now()) {
        indexedDbAvailable = false;
        notifyFallbackMode();
        return Promise.resolve(null);
      }

      openPromise = new Promise((resolve, reject) => {
        if (typeof indexedDB === "undefined") {
          reject(new Error("IndexedDB unavailable"));
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        let settled = false;
        const settle = (fn, value) => {
          if (settled) return;
          settled = true;
          clearTimeout(timeoutId);
          fn(value);
        };
        const timeoutId = setTimeout(() => {
          settle(
            reject,
            new Error(`IndexedDB open timeout (${OPEN_TIMEOUT_MS}ms)`),
          );
        }, OPEN_TIMEOUT_MS);

        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: "key" });
          }
        };
        request.onsuccess = () => settle(resolve, request.result);
        request.onerror = () =>
          settle(reject, request.error || new Error("open db failed"));
        request.onblocked = () =>
          settle(reject, new Error("IndexedDB open blocked"));
      }).catch((error) => {
        console.warn("[Storage] IndexedDB disabled, fallback localStorage:", error);
        indexedDbAvailable = false;
        writeDisabledUntil(DISABLED_COOLDOWN_MS);
        notifyFallbackMode();
        return null;
      });
      return openPromise;
    };

    const getFallbackKey = (key) => `${FALLBACK_PREFIX}${key}`;

    const withStore = async (mode, fn) => {
      const db = await openDb();
      if (!db) return null;
      return new Promise((resolve, reject) => {
        try {
          const tx = db.transaction(STORE_NAME, mode);
          const store = tx.objectStore(STORE_NAME);
          const req = fn(store);
          tx.oncomplete = () => resolve(req ? req.result : null);
          tx.onabort = () => reject(tx.error || new Error("transaction aborted"));
          tx.onerror = () => reject(tx.error || new Error("transaction error"));
        } catch (e) {
          reject(e);
        }
      });
    };

    const getJson = async (key, fallback = null) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            const response = await desktopStorageApi.getJson(key);
            if (response && response.found === true) {
              return cloneValue(response.value);
            }
            try {
              const legacyRaw = localStorage.getItem(getFallbackKey(key));
              if (legacyRaw === null) return fallback;
              const legacyParsed = JSON.parse(legacyRaw);
              await desktopStorageApi.setJson(key, cloneValue(legacyParsed));
              return legacyParsed;
            } catch (_) {
              return fallback;
            }
          }
          try {
            const raw = localStorage.getItem(getFallbackKey(key));
            if (raw === null) return fallback;
            return JSON.parse(raw);
          } catch (_) {
            return fallback;
          }
        }
        const row = await withStore("readonly", (store) => store.get(key));
        if (!row || row.value === undefined || row.value === null) return fallback;
        return cloneValue(row.value);
      } catch (e) {
        console.warn("[Storage] getJson failed:", key, e);
        return fallback;
      }
    };

    const setJson = async (key, value) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            return !!(await desktopStorageApi.setJson(key, cloneValue(value)));
          }
          localStorage.setItem(
            getFallbackKey(key),
            JSON.stringify(cloneValue(value)),
          );
          return true;
        }
        const payload = {
          key,
          value: cloneValue(value),
          updatedAt: Date.now(),
        };
        await withStore("readwrite", (store) => store.put(payload));
        return true;
      } catch (e) {
        console.warn("[Storage] setJson failed:", key, e);
        return false;
      }
    };

    const remove = async (key) => {
      try {
        const db = await openDb();
        if (!db) {
          const desktopStorageApi = getDesktopStorageApi();
          if (desktopStorageApi) {
            return !!(await desktopStorageApi.remove(key));
          }
          localStorage.removeItem(getFallbackKey(key));
          return true;
        }
        await withStore("readwrite", (store) => store.delete(key));
        return true;
      } catch (e) {
        console.warn("[Storage] remove failed:", key, e);
        return false;
      }
    };

    const migrateFromLocalStorage = async (
      localStorageKey,
      dbKey,
      fallback = null,
    ) => {
      const existing = await getJson(dbKey, undefined);
      if (existing !== undefined) return existing;

      let parsed = fallback;
      try {
        const raw = localStorage.getItem(localStorageKey);
        if (raw) parsed = JSON.parse(raw);
      } catch (e) {
        console.warn("[Storage] migration parse failed:", localStorageKey, e);
      }

      if (parsed !== undefined) {
        const written = await setJson(dbKey, parsed);
        if (written) {
          try {
            localStorage.removeItem(localStorageKey);
          } catch (_) {}
        }
      }
      return parsed;
    };

    return {
      getJson,
      setJson,
      remove,
      migrateFromLocalStorage,
      configure,
      status() {
        return {
          indexedDbAvailable,
          fallbackMode: !indexedDbAvailable,
        };
      },
    };
  }

  sharedRoot.createStorageAdapter = createStorageAdapter;
  globalObj.PoseChronoShared = sharedRoot;

  if (!globalObj.PoseChronoStorage) {
    globalObj.PoseChronoStorage = createStorageAdapter({
      forceFallbackMode:
        !!globalObj.poseChronoDesktop &&
        globalObj.poseChronoDesktop.platform === "desktop",
    });
  }
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/runtime-mode-utils.js ===== */
(function initPoseChronoSharedRuntimeModeUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createRuntimeModeUtils(options = {}) {
    const desktopPlatformValue = String(options.desktopPlatformValue || "desktop");

    function isDesktopStandaloneRuntime() {
      try {
        return (
          typeof window !== "undefined" &&
          !!window.poseChronoDesktop &&
          window.poseChronoDesktop.platform === desktopPlatformValue
        );
      } catch (_) {
        return false;
      }
    }

    function getRevealActionI18nKey() {
      return isDesktopStandaloneRuntime()
        ? "drawing.revealInExplorer"
        : "drawing.openInEagle";
    }

    function getAppSubtitleI18nKey() {
      return isDesktopStandaloneRuntime() ? "app.subtitleDesktop" : "app.subtitle";
    }

    function getMediaSourceAnalyzedI18nKey(useFallbackSource = false) {
      if (isDesktopStandaloneRuntime()) {
        return "settings.mediaFoldersAnalyzed";
      }
      return useFallbackSource
        ? "settings.allLibraryAnalyzed"
        : "settings.imagesAnalyzed";
    }

    function isCapabilityEnabled(platform, capabilityKey, fallback = false) {
      const key = String(capabilityKey || "").trim();
      if (!key) return !!fallback;
      const capabilities = platform?.capabilities;
      if (
        capabilities &&
        Object.prototype.hasOwnProperty.call(capabilities, key)
      ) {
        return !!capabilities[key];
      }
      return !!fallback;
    }

    function isTagsFeatureAvailable(platform) {
      return isCapabilityEnabled(
        platform,
        "tags",
        !isDesktopStandaloneRuntime(),
      );
    }

    return {
      isDesktopStandaloneRuntime,
      getRevealActionI18nKey,
      getAppSubtitleI18nKey,
      getMediaSourceAnalyzedI18nKey,
      isCapabilityEnabled,
      isTagsFeatureAvailable,
    };
  }

  sharedRoot.createRuntimeModeUtils = createRuntimeModeUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/preferences-transfer-utils.js ===== */
(function initPoseChronoSharedPreferencesTransferUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPreferencesTransferUtils(options = {}) {
    const doc = options.document || (typeof document !== "undefined" ? document : null);
    const urlApi = options.URL || (typeof URL !== "undefined" ? URL : null);
    const BlobCtor = options.Blob || (typeof Blob !== "undefined" ? Blob : null);
    const FileReaderCtor =
      options.FileReader || (typeof FileReader !== "undefined" ? FileReader : null);
    const scheduleTimeout =
      typeof options.setTimeout === "function" ? options.setTimeout : setTimeout;
    const logError =
      typeof options.logError === "function" ? options.logError : () => {};

    function createBackupFilename(nowDate = null) {
      const now = nowDate instanceof Date ? nowDate : new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, "0");
      const dd = String(now.getDate()).padStart(2, "0");
      const hh = String(now.getHours()).padStart(2, "0");
      const min = String(now.getMinutes()).padStart(2, "0");
      const ss = String(now.getSeconds()).padStart(2, "0");
      return `posechrono-backup-${yyyy}${mm}${dd}-${hh}${min}${ss}.json`;
    }

    function downloadJsonPayload(filename, payload) {
      if (!doc || !doc.body || !urlApi || !BlobCtor) return false;
      try {
        const content = JSON.stringify(payload, null, 2);
        const blob = new BlobCtor([content], {
          type: "application/json;charset=utf-8",
        });
        const objectUrl = urlApi.createObjectURL(blob);
        const anchor = doc.createElement("a");
        anchor.href = objectUrl;
        anchor.download = filename;
        doc.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        scheduleTimeout(() => urlApi.revokeObjectURL(objectUrl), 0);
        return true;
      } catch (error) {
        logError(error);
        return false;
      }
    }

    function pickJsonFileText() {
      return new Promise((resolve) => {
        if (!doc || !doc.body || !FileReaderCtor) {
          resolve(null);
          return;
        }
        const input = doc.createElement("input");
        input.type = "file";
        input.accept = ".json,application/json";
        input.style.display = "none";
        doc.body.appendChild(input);

        const cleanup = () => {
          input.remove();
        };

        input.addEventListener(
          "change",
          () => {
            const file = input.files && input.files[0];
            if (!file) {
              cleanup();
              resolve(null);
              return;
            }
            const reader = new FileReaderCtor();
            reader.onload = () => {
              cleanup();
              resolve(typeof reader.result === "string" ? reader.result : null);
            };
            reader.onerror = () => {
              cleanup();
              resolve(null);
            };
            reader.readAsText(file, "utf-8");
          },
          { once: true },
        );

        input.click();
      });
    }

    function hasAnySectionSelected(selections) {
      if (!selections || typeof selections !== "object") return false;
      return Object.values(selections).some(Boolean);
    }

    function getAvailableSectionsFromPackage(parsed) {
      const sections =
        parsed && typeof parsed === "object" && parsed.sections
          ? parsed.sections
          : {};
      return {
        ui: !!sections.ui,
        hotkeys: !!sections.hotkeys,
        plans: !!sections.plans,
        timeline: !!sections.timeline,
      };
    }

    function isValidPreferencesPackage(parsed) {
      return !!(
        parsed &&
        typeof parsed === "object" &&
        parsed.sections &&
        typeof parsed.sections === "object"
      );
    }

    return {
      createBackupFilename,
      downloadJsonPayload,
      pickJsonFileText,
      hasAnySectionSelected,
      getAvailableSectionsFromPackage,
      isValidPreferencesPackage,
    };
  }

  sharedRoot.createPreferencesTransferUtils = createPreferencesTransferUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-access-utils.js ===== */
(function initPoseChronoSharedPlatformAccessUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPlatformAccessUtils(options = {}) {
    const getterName = String(options.getterName || "getPoseChronoPlatform");

    function getPlatform() {
      try {
        if (
          typeof window !== "undefined" &&
          typeof window[getterName] === "function"
        ) {
          return window[getterName]();
        }
      } catch (_) {}
      return null;
    }

    return {
      getPlatform,
    };
  }

  sharedRoot.createPlatformAccessUtils = createPlatformAccessUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-capability-utils.js ===== */
(function initPoseChronoSharedPlatformCapabilityUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createCapabilityWarner(options = {}) {
    const warned = new Set();
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const logger =
      typeof options.logger === "function" ? options.logger : console.warn;
    const prefix = String(options.prefix || "[Platform]");

    return function warnMissingCapability(capabilityKey, operationLabel) {
      const capability = String(capabilityKey || "").trim();
      if (!capability) return;
      if (warned.has(capability)) return;

      const platform = getPlatform();
      const hasPlatformCapabilities =
        !!platform &&
        !!platform.capabilities &&
        Object.prototype.hasOwnProperty.call(platform.capabilities, capability);

      if (!hasPlatformCapabilities || platform.capabilities[capability]) return;

      warned.add(capability);
      logger(
        `${prefix} Missing capability "${capability}" for "${operationLabel}".`,
      );
    };
  }

  sharedRoot.createCapabilityWarner = createCapabilityWarner;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-ops-utils.js ===== */
(function initPoseChronoSharedPlatformOpsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function resolvePath(target, path) {
    const parts = String(path || "")
      .split(".")
      .map((part) => part.trim())
      .filter(Boolean);
    if (!target || parts.length === 0) return null;
    let node = target;
    for (const part of parts) {
      if (!node || typeof node !== "object") return null;
      node = node[part];
    }
    return node;
  }

  function createPlatformOpsUtils(options = {}) {
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const warnMissingCapability =
      typeof options.warnMissingCapability === "function"
        ? options.warnMissingCapability
        : () => {};

    function call(path, args = [], config = {}) {
      const platform = getPlatform();
      const fn = resolvePath(platform, path);
      const safeArgs = Array.isArray(args) ? args : [args];
      if (typeof fn === "function") {
        try {
          fn(...safeArgs);
          return true;
        } catch (_) {}
      }
      if (config.capability && config.operationLabel) {
        warnMissingCapability(config.capability, config.operationLabel);
      }
      return false;
    }

    async function callAsync(path, args = [], config = {}) {
      const platform = getPlatform();
      const fn = resolvePath(platform, path);
      const safeArgs = Array.isArray(args) ? args : [args];
      if (typeof fn === "function") {
        try {
          return await fn(...safeArgs);
        } catch (_) {}
      }
      if (config.capability && config.operationLabel) {
        warnMissingCapability(config.capability, config.operationLabel);
      }
      return config.fallback;
    }

    async function callBoolean(path, args = [], config = {}) {
      const failToken = Symbol("platform-op-fail");
      const result = await callAsync(path, args, {
        capability: config.capability,
        operationLabel: config.operationLabel,
        fallback: failToken,
      });
      return result !== failToken;
    }

    async function callArray(path, args = [], config = {}) {
      const result = await callAsync(path, args, {
        capability: config.capability,
        operationLabel: config.operationLabel,
        fallback: [],
      });
      return Array.isArray(result) ? result : [];
    }

    return {
      call,
      callAsync,
      callBoolean,
      callArray,
    };
  }

  sharedRoot.createPlatformOpsUtils = createPlatformOpsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/platform-window-utils.js ===== */
(function initPoseChronoSharedPlatformWindowUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createPlatformWindowUtils(options = {}) {
    const getPlatform =
      typeof options.getPlatform === "function" ? options.getPlatform : () => null;
    const warnMissingCapability =
      typeof options.warnMissingCapability === "function"
        ? options.warnMissingCapability
        : () => {};

    async function toggleMaximize() {
      const platform = getPlatform();
      try {
        if (platform?.window) {
          const isMaximized = await (platform.window.isMaximized?.() || false);
          if (isMaximized && platform.window.unmaximize) {
            await platform.window.unmaximize();
            return;
          }
          if (!isMaximized && platform.window.maximize) {
            await platform.window.maximize();
            return;
          }
        }
      } catch (_) {}
      warnMissingCapability("windowControls", "window.toggleMaximize");
    }

    async function toggleAlwaysOnTop() {
      const platform = getPlatform();
      try {
        if (platform?.window) {
          const isOnTop = await (platform.window.isAlwaysOnTop?.() || false);
          if (platform.window.setAlwaysOnTop) {
            await platform.window.setAlwaysOnTop(!isOnTop);
          }
          return !isOnTop;
        }
      } catch (_) {}
      warnMissingCapability("windowControls", "window.toggleAlwaysOnTop");
      return false;
    }

    return {
      toggleMaximize,
      toggleAlwaysOnTop,
    };
  }

  sharedRoot.createPlatformWindowUtils = createPlatformWindowUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/image-context-menu-bindings-utils.js ===== */
(function initPoseChronoSharedImageContextMenuBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindImageContextMenus(input = {}) {
    const targets = Array.isArray(input.targets) ? input.targets : [];
    const onOpenMenu =
      typeof input.onOpenMenu === "function" ? input.onOpenMenu : null;
    if (!targets.length || !onOpenMenu) return false;

    let boundCount = 0;
    targets.forEach((target) => {
      if (!target || typeof target.addEventListener !== "function") return;
      target.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onOpenMenu(event.clientX, event.clientY, event);
      });
      boundCount += 1;
    });

    return boundCount > 0;
  }

  function createImageContextMenuBindingsUtils() {
    return {
      bindImageContextMenus,
    };
  }

  sharedRoot.createImageContextMenuBindingsUtils =
    createImageContextMenuBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/action-buttons-bindings-utils.js ===== */
(function initPoseChronoSharedActionButtonsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindActionButtons(input = {}) {
    const deleteBtn = input.deleteBtn;
    const revealBtn = input.revealBtn;
    const onDelete = typeof input.onDelete === "function" ? input.onDelete : null;
    const onReveal = typeof input.onReveal === "function" ? input.onReveal : null;
    const onRevealContextMenu =
      typeof input.onRevealContextMenu === "function"
        ? input.onRevealContextMenu
        : null;

    let hasAnyBinding = false;

    if (deleteBtn && onDelete && typeof deleteBtn.addEventListener === "function") {
      deleteBtn.addEventListener("click", onDelete);
      hasAnyBinding = true;
    }

    if (revealBtn && typeof revealBtn.addEventListener === "function") {
      if (onReveal) {
        revealBtn.addEventListener("click", onReveal);
        hasAnyBinding = true;
      }
      if (onRevealContextMenu) {
        revealBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onRevealContextMenu(event.clientX, event.clientY, event);
        });
        hasAnyBinding = true;
      }
    }

    return hasAnyBinding;
  }

  function createActionButtonsBindingsUtils() {
    return {
      bindActionButtons,
    };
  }

  sharedRoot.createActionButtonsBindingsUtils = createActionButtonsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-plan-utils.js ===== */
(function initPoseChronoSharedSessionPlanUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSessionPlanUtils(options = {}) {
    const schemaVersion = Number(options.schemaVersion || 1);
    const now =
      typeof options.now === "function"
        ? options.now
        : () => Date.now();

    function clampInt(value, min, max, fallback = min) {
      const num = Number(value);
      if (!Number.isFinite(num)) return fallback;
      return Math.max(min, Math.min(max, Math.round(num)));
    }

    function normalizeCustomStep(step) {
      if (!step || typeof step !== "object") return null;
      const type =
        step.type === "pause" ? "pause" : step.type === "pose" ? "pose" : null;
      if (!type) return null;

      const duration = clampInt(step.duration, 1, 86400, 60);
      const count = type === "pause" ? 1 : clampInt(step.count, 1, 10000, 1);
      const idCandidate = Number(step.id);
      const id = Number.isFinite(idCandidate)
        ? idCandidate
        : now() + Math.floor(Math.random() * 10000);

      return { type, count, duration, id };
    }

    function normalizeSessionPlansPayload(raw) {
      const source =
        raw && typeof raw === "object" && Array.isArray(raw.plans)
          ? raw.plans
          : Array.isArray(raw)
            ? raw
            : [];

      let repaired = false;
      const plans = [];

      source.forEach((plan, index) => {
        if (!plan || typeof plan !== "object") {
          repaired = true;
          return;
        }
        const nameRaw = String(plan.name ?? "").trim();
        const name =
          nameRaw.length > 0 ? nameRaw.slice(0, 120) : `Plan ${index + 1}`;
        if (name !== nameRaw) repaired = true;

        const date = clampInt(plan.date, 0, 4102444800000, now());
        const rawSteps = Array.isArray(plan.steps) ? plan.steps : [];
        if (!Array.isArray(plan.steps)) repaired = true;
        const steps = rawSteps
          .map((step) => normalizeCustomStep(step))
          .filter(Boolean);
        if (steps.length !== rawSteps.length) repaired = true;
        if (steps.length === 0) {
          repaired = true;
          return;
        }

        plans.push({
          name,
          steps,
          date,
        });
      });

      const payload = {
        schemaVersion,
        plans,
      };
      if (
        !raw ||
        typeof raw !== "object" ||
        raw.schemaVersion !== schemaVersion ||
        !Array.isArray(raw.plans)
      ) {
        repaired = true;
      }
      return { payload, plans, repaired };
    }

    function renderPlansListHtml(plans, options = {}) {
      const safePlans = Array.isArray(plans) ? plans : [];
      if (safePlans.length === 0) return "";

      const escapeHtml =
        typeof options.escapeHtml === "function"
          ? options.escapeHtml
          : (value) => String(value ?? "");
      const formatDuration =
        typeof options.formatDuration === "function"
          ? options.formatDuration
          : () => "0s";
      const calculatePlanDuration =
        typeof options.calculatePlanDuration === "function"
          ? options.calculatePlanDuration
          : () => 0;
      const calculatePlanPoses =
        typeof options.calculatePlanPoses === "function"
          ? options.calculatePlanPoses
          : () => 0;
      const getPlanWord =
        typeof options.getPlanWord === "function"
          ? options.getPlanWord
          : () => "";
      const loadLabel = String(options.loadLabel || "Load");
      const deleteButtonIcon = String(options.deleteButtonIcon || "");

      return safePlans
        .map((plan, index) => {
          const totalDuration = calculatePlanDuration(plan.steps);
          const totalPoses = calculatePlanPoses(plan.steps);
          const totalSteps = (plan.steps || []).length;
          const durationText = formatDuration(totalDuration);
          const posesLabel = getPlanWord("pose", totalPoses);
          const stepsLabel = getPlanWord("step", totalSteps);
          return `
      <div class="plan-item">
        <div class="plan-info">
          <div class="plan-name" data-index="${index}" contenteditable="false" style="cursor: pointer;">${escapeHtml(plan.name)}</div>
          <div class="plan-meta">${durationText} - ${totalPoses} ${posesLabel} - ${totalSteps} ${stepsLabel}</div>
        </div>
        <div class="plan-actions">
          <button type="button" class="plan-btn plan-load-btn" data-index="${index}">${loadLabel}</button>
          <button type="button" class="plan-btn plan-delete-btn" data-index="${index}">${deleteButtonIcon}</button>
        </div>
      </div>
    `;
        })
        .join("");
    }

    function formatPlanDeleteSummary(plan, options = {}) {
      const safePlan = plan && typeof plan === "object" ? plan : { steps: [] };
      const formatDuration =
        typeof options.formatDuration === "function"
          ? options.formatDuration
          : () => "0s";
      const calculatePlanDuration =
        typeof options.calculatePlanDuration === "function"
          ? options.calculatePlanDuration
          : () => 0;
      const calculatePlanPoses =
        typeof options.calculatePlanPoses === "function"
          ? options.calculatePlanPoses
          : () => 0;
      const getPlanWord =
        typeof options.getPlanWord === "function"
          ? options.getPlanWord
          : () => "";

      const totalDuration = formatDuration(calculatePlanDuration(safePlan.steps));
      const totalPoses = calculatePlanPoses(safePlan.steps);
      const stepsCount = (safePlan.steps || []).length;
      const posesLabel = getPlanWord("pose", totalPoses);
      const stepsLabel = getPlanWord("step", stepsCount);

      return {
        totalDuration,
        totalPoses,
        stepsCount,
        posesLabel,
        stepsLabel,
        summary: `${safePlan.name} (${totalDuration} - ${totalPoses} ${posesLabel}, ${stepsCount} ${stepsLabel})`,
      };
    }

    function getPlanSaveValidation(input = {}) {
      const name = String(input.name || "").trim();
      const queueLength = Number(input.queueLength || 0);
      if (!name) {
        return { ok: false, reason: "empty-name" };
      }
      if (queueLength <= 0) {
        return { ok: false, reason: "empty-queue" };
      }
      return { ok: true, reason: "" };
    }

    function createPlanEntry(input = {}) {
      const name = String(input.name || "").trim();
      const queue = Array.isArray(input.queue) ? input.queue : [];
      const date =
        Number.isFinite(Number(input.date)) && Number(input.date) > 0
          ? Number(input.date)
          : now();
      return {
        name,
        steps: JSON.parse(JSON.stringify(queue)),
        date,
      };
    }

    return {
      clampInt,
      normalizeCustomStep,
      normalizeSessionPlansPayload,
      renderPlansListHtml,
      formatPlanDeleteSummary,
      getPlanSaveValidation,
      createPlanEntry,
    };
  }

  sharedRoot.createSessionPlanUtils = createSessionPlanUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-metrics.js ===== */
(function initPoseChronoSharedSessionMetrics(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createSessionMetricsUtils() {
    function toFiniteNumber(value, fallback = 0) {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    }

    function calculatePlanDuration(steps) {
      if (!Array.isArray(steps)) return 0;
      return steps.reduce((total, step) => {
        if (!step || typeof step !== "object") return total;
        const duration = Math.max(0, toFiniteNumber(step.duration, 0));
        if (step.type === "pause") return total + duration;
        const count = Math.max(0, toFiniteNumber(step.count, 0));
        return total + count * duration;
      }, 0);
    }

    function calculatePlanPoses(steps) {
      if (!Array.isArray(steps)) return 0;
      return steps.reduce((total, step) => {
        if (!step || typeof step !== "object" || step.type === "pause") {
          return total;
        }
        return total + Math.max(0, toFiniteNumber(step.count, 0));
      }, 0);
    }

    function clampMemoryPosesCount(requestedCount, imagesCount, fallback = 1) {
      const min = 1;
      const images = Math.max(min, Math.round(toFiniteNumber(imagesCount, min)));
      const desired = Math.round(toFiniteNumber(requestedCount, fallback));
      return Math.max(min, Math.min(desired, images));
    }

    function calculateMemoryTotalSeconds(posesCount, drawingTime, displayTime) {
      const poses = Math.max(0, toFiniteNumber(posesCount, 0));
      const drawing = Math.max(0, toFiniteNumber(drawingTime, 0));
      const display = Math.max(0, toFiniteNumber(displayTime, 0));
      return poses * (drawing + display);
    }

    return {
      calculatePlanDuration,
      calculatePlanPoses,
      clampMemoryPosesCount,
      calculateMemoryTotalSeconds,
    };
  }

  sharedRoot.createSessionMetricsUtils = createSessionMetricsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-controls-bindings-utils.js ===== */
(function initPoseChronoSharedSessionControlsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindMemoryOverlayButtons(input = {}) {
    const memoryOverlay = input.memoryOverlay || null;
    const memoryPeekBtn = input.memoryPeekBtn || null;
    const memoryRevealBtn = input.memoryRevealBtn || null;
    const getRevealLabel =
      typeof input.getRevealLabel === "function" ? input.getRevealLabel : null;

    let bound = false;

    if (memoryPeekBtn && typeof memoryPeekBtn.addEventListener === "function") {
      memoryPeekBtn.addEventListener("mousedown", (event) => {
        event.stopPropagation();
        if (memoryOverlay && !memoryPeekBtn.disabled) {
          memoryOverlay.classList.add("peek-active");
          memoryOverlay.classList.add("peek-content-hidden");
        }
      });

      memoryPeekBtn.addEventListener("mouseup", (event) => {
        event.stopPropagation();
        if (memoryOverlay) {
          memoryOverlay.classList.remove("peek-active");
          memoryOverlay.classList.remove("peek-content-hidden");
        }
      });

      memoryPeekBtn.addEventListener("mouseleave", () => {
        if (memoryOverlay) {
          memoryOverlay.classList.remove("peek-active");
          memoryOverlay.classList.remove("peek-content-hidden");
        }
      });

      bound = true;
    }

    if (memoryRevealBtn && typeof memoryRevealBtn.addEventListener === "function") {
      memoryRevealBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!memoryOverlay) return;
        const isRevealed = memoryOverlay.classList.toggle("revealed");
        if (getRevealLabel) {
          memoryRevealBtn.textContent = getRevealLabel(isRevealed);
        }
        if (memoryPeekBtn) {
          memoryPeekBtn.disabled = isRevealed;
        }
      });
      bound = true;
    }

    return bound;
  }

  function bindShuffleAndAutoFlipButtons(input = {}) {
    const randomShuffleBtn = input.randomShuffleBtn || null;
    const autoFlipBtn = input.autoFlipBtn || null;
    const state = input.state || null;
    const onShuffleToggle =
      typeof input.onShuffleToggle === "function" ? input.onShuffleToggle : null;
    const onAutoFlipContextMenu =
      typeof input.onAutoFlipContextMenu === "function"
        ? input.onAutoFlipContextMenu
        : null;

    let bound = false;

    if (randomShuffleBtn && state && typeof randomShuffleBtn.addEventListener === "function") {
      randomShuffleBtn.classList.toggle("active", !!state.randomShuffle);
      randomShuffleBtn.addEventListener("click", () => {
        state.randomShuffle = !state.randomShuffle;
        randomShuffleBtn.classList.toggle("active", !!state.randomShuffle);
        if (onShuffleToggle) {
          onShuffleToggle(!!state.randomShuffle);
        }
      });
      bound = true;
    }

    if (autoFlipBtn && state && typeof autoFlipBtn.addEventListener === "function") {
      autoFlipBtn.classList.toggle("active", !!state.autoFlip);
      autoFlipBtn.addEventListener("click", () => {
        state.autoFlip = !state.autoFlip;
        autoFlipBtn.classList.toggle("active", !!state.autoFlip);
      });

      if (onAutoFlipContextMenu) {
        autoFlipBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onAutoFlipContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindTimerControlsAndProgress(input = {}) {
    const soundBtn = input.soundBtn || null;
    const toggleTimerBtn = input.toggleTimerBtn || null;
    const timerDisplay = input.timerDisplay || null;
    const progressBar = input.progressBar || null;
    const pauseCentralBlock = input.pauseCentralBlock || null;
    const state = input.state || {};
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);

    const onToggleSound =
      typeof input.onToggleSound === "function" ? input.onToggleSound : null;
    const onToggleTimer =
      typeof input.onToggleTimer === "function" ? input.onToggleTimer : null;
    const onShowProgressBarContextMenu =
      typeof input.onShowProgressBarContextMenu === "function"
        ? input.onShowProgressBarContextMenu
        : null;
    const onShowTimerContextMenu =
      typeof input.onShowTimerContextMenu === "function"
        ? input.onShowTimerContextMenu
        : null;
    const onShowPauseCircleContextMenu =
      typeof input.onShowPauseCircleContextMenu === "function"
        ? input.onShowPauseCircleContextMenu
        : null;
    const onUpdateTimerDisplay =
      typeof input.onUpdateTimerDisplay === "function"
        ? input.onUpdateTimerDisplay
        : null;

    let bound = false;
    let isDraggingProgress = false;

    if (soundBtn && onToggleSound && typeof soundBtn.addEventListener === "function") {
      soundBtn.addEventListener("click", onToggleSound);
      bound = true;
    }

    if (toggleTimerBtn && typeof toggleTimerBtn.addEventListener === "function") {
      if (onToggleTimer) {
        toggleTimerBtn.addEventListener("click", onToggleTimer);
      }
      if (onShowProgressBarContextMenu) {
        toggleTimerBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressBarContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (
      timerDisplay &&
      onShowTimerContextMenu &&
      typeof timerDisplay.addEventListener === "function"
    ) {
      timerDisplay.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onShowTimerContextMenu(event.clientX, event.clientY, event);
      });
      bound = true;
    }

    if (progressBar && typeof progressBar.addEventListener === "function") {
      progressBar.addEventListener("click", (event) => {
        if (!state.isPlaying && state.selectedDuration > 0) return;
        const rect = progressBar.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        state.timeRemaining = Math.round(percent * state.selectedDuration);
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
      });

      progressBar.addEventListener("mousedown", (event) => {
        if (state.selectedDuration <= 0) return;
        isDraggingProgress = true;
        const rect = progressBar.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        state.timeRemaining = Math.max(
          0,
          Math.min(
            state.selectedDuration,
            Math.round(percent * state.selectedDuration),
          ),
        );
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
        progressBar.style.cursor = "grabbing";
      });
      bound = true;
    }

    if (documentRef && progressBar && typeof documentRef.addEventListener === "function") {
      documentRef.addEventListener("mousemove", (event) => {
        if (!isDraggingProgress) return;
        const rect = progressBar.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(1, (event.clientX - rect.left) / rect.width),
        );
        state.timeRemaining = Math.round(percent * state.selectedDuration);
        if (onUpdateTimerDisplay) {
          onUpdateTimerDisplay();
        }
      });

      documentRef.addEventListener("mouseup", () => {
        if (!isDraggingProgress) return;
        isDraggingProgress = false;
        progressBar.style.cursor = "pointer";
      });
      bound = true;
    }

    if (
      pauseCentralBlock &&
      onShowPauseCircleContextMenu &&
      typeof pauseCentralBlock.addEventListener === "function"
    ) {
      pauseCentralBlock.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        onShowPauseCircleContextMenu(event.clientX, event.clientY, event);
      });
      bound = true;
    }

    return bound;
  }

  function bindVideoScrubbing(input = {}) {
    const currentVideo = input.currentVideo || null;
    const state = input.state || {};
    const frameStepState = input.frameStepState || {};
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const performanceRef =
      input.performanceRef ||
      (typeof performance !== "undefined" ? performance : null);
    const requestAnimationFrameRef =
      input.requestAnimationFrameRef ||
      (typeof requestAnimationFrame === "function"
        ? requestAnimationFrame
        : null);
    const cancelAnimationFrameRef =
      input.cancelAnimationFrameRef ||
      (typeof cancelAnimationFrame === "function" ? cancelAnimationFrame : null);
    const onUpdateVideoTimeDisplay =
      typeof input.onUpdateVideoTimeDisplay === "function"
        ? input.onUpdateVideoTimeDisplay
        : null;

    if (
      !currentVideo ||
      !documentRef ||
      !performanceRef ||
      !requestAnimationFrameRef
    ) {
      return false;
    }

    let isScrubbingVideo = false;
    let scrubStartX = 0;
    let scrubStartTime = 0;
    let scrubTargetTime = 0;
    let scrubRafId = null;
    let scrubLastSeekTime = 0;
    const SCRUB_MIN_INTERVAL = 1000 / 30;

    function performScrubSeek() {
      scrubRafId = null;

      if (!isScrubbingVideo || !currentVideo.duration) return;

      const now = performanceRef.now();
      if (now - scrubLastSeekTime < SCRUB_MIN_INTERVAL) {
        scrubRafId = requestAnimationFrameRef(performScrubSeek);
        return;
      }

      scrubLastSeekTime = now;

      if (
        frameStepState.vfcSupported &&
        typeof currentVideo.requestVideoFrameCallback === "function"
      ) {
        currentVideo.currentTime = scrubTargetTime;
        currentVideo.requestVideoFrameCallback(() => {
          if (onUpdateVideoTimeDisplay) {
            onUpdateVideoTimeDisplay();
          }
          if (isScrubbingVideo && scrubTargetTime !== currentVideo.currentTime) {
            scrubRafId = requestAnimationFrameRef(performScrubSeek);
          }
        });
      } else {
        currentVideo.currentTime = scrubTargetTime;
        if (onUpdateVideoTimeDisplay) {
          onUpdateVideoTimeDisplay();
        }
      }
    }

    currentVideo.addEventListener("keydown", (event) => {
      if (event.key !== " ") return;
      event.preventDefault();
      event.stopPropagation();
    });

    currentVideo.addEventListener("mousedown", (event) => {
      if (!state.isVideoFile || !currentVideo.duration) return;
      isScrubbingVideo = true;
      scrubStartX = event.clientX;
      scrubStartTime = currentVideo.currentTime;
      scrubTargetTime = scrubStartTime;
      currentVideo.style.cursor = "ew-resize";
      event.preventDefault();
    });

    documentRef.addEventListener("mousemove", (event) => {
      if (!isScrubbingVideo || !currentVideo.duration) return;

      const deltaX = event.clientX - scrubStartX;
      const videoWidth = currentVideo.offsetWidth || 800;
      let sensitivity = currentVideo.duration / videoWidth;

      if (event.shiftKey) {
        sensitivity *= 0.1;
      }

      scrubTargetTime = Math.max(
        0,
        Math.min(currentVideo.duration, scrubStartTime + deltaX * sensitivity),
      );

      if (!scrubRafId) {
        scrubRafId = requestAnimationFrameRef(performScrubSeek);
      }
    });

    documentRef.addEventListener("mouseup", () => {
      if (!isScrubbingVideo) return;
      isScrubbingVideo = false;
      currentVideo.style.cursor = "";
      if (scrubRafId && cancelAnimationFrameRef) {
        cancelAnimationFrameRef(scrubRafId);
        scrubRafId = null;
      }
      if (currentVideo.currentTime !== scrubTargetTime) {
        currentVideo.currentTime = scrubTargetTime;
        if (onUpdateVideoTimeDisplay) {
          onUpdateVideoTimeDisplay();
        }
      }
    });

    return true;
  }

  function bindVideoControls(input = {}) {
    const videoPlayBtn = input.videoPlayBtn || null;
    const videoSlowerBtn = input.videoSlowerBtn || null;
    const videoFasterBtn = input.videoFasterBtn || null;
    const videoPrevFrameBtn = input.videoPrevFrameBtn || null;
    const videoNextFrameBtn = input.videoNextFrameBtn || null;
    const videoLoopBtn = input.videoLoopBtn || null;
    const videoConfigBtn = input.videoConfigBtn || null;
    const videoSpeedDisplay = input.videoSpeedDisplay || null;
    const videoTimeline = input.videoTimeline || null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const state = input.state || {};
    const frameStepState = input.frameStepState || {};
    const icons = input.icons || {};
    const t = typeof input.translate === "function" ? input.translate : null;

    const onToggleVideoPlayPause =
      typeof input.onToggleVideoPlayPause === "function"
        ? input.onToggleVideoPlayPause
        : null;
    const onChangeVideoSpeed =
      typeof input.onChangeVideoSpeed === "function"
        ? input.onChangeVideoSpeed
        : null;
    const onStepFrame =
      typeof input.onStepFrame === "function" ? input.onStepFrame : null;
    const onProcessFrameStepLoop =
      typeof input.onProcessFrameStepLoop === "function"
        ? input.onProcessFrameStepLoop
        : null;
    const onStopFrameSteppingFromButton =
      typeof input.onStopFrameSteppingFromButton === "function"
        ? input.onStopFrameSteppingFromButton
        : null;
    const onToggleVideoLoop =
      typeof input.onToggleVideoLoop === "function" ? input.onToggleVideoLoop : null;
    const onShowVideoConfig =
      typeof input.onShowVideoConfig === "function" ? input.onShowVideoConfig : null;
    const onShowSpeedPopup =
      typeof input.onShowSpeedPopup === "function" ? input.onShowSpeedPopup : null;
    const onSeekVideo =
      typeof input.onSeekVideo === "function" ? input.onSeekVideo : null;

    let bound = false;

    if (videoPlayBtn && typeof videoPlayBtn.addEventListener === "function") {
      if (icons.VIDEO_PLAY) {
        videoPlayBtn.innerHTML = icons.VIDEO_PLAY;
      }
      if (onToggleVideoPlayPause) {
        videoPlayBtn.addEventListener("click", onToggleVideoPlayPause);
      }
      bound = true;
    }

    if (videoSlowerBtn && typeof videoSlowerBtn.addEventListener === "function") {
      if (icons.VIDEO_SLOWER) {
        videoSlowerBtn.innerHTML = icons.VIDEO_SLOWER;
      }
      if (onChangeVideoSpeed) {
        videoSlowerBtn.addEventListener("click", () => onChangeVideoSpeed(-1));
      }
      bound = true;
    }

    if (videoFasterBtn && typeof videoFasterBtn.addEventListener === "function") {
      if (icons.VIDEO_FASTER) {
        videoFasterBtn.innerHTML = icons.VIDEO_FASTER;
      }
      if (onChangeVideoSpeed) {
        videoFasterBtn.addEventListener("click", () => onChangeVideoSpeed(1));
      }
      bound = true;
    }

    if (videoPrevFrameBtn && typeof videoPrevFrameBtn.addEventListener === "function") {
      if (icons.VIDEO_PREV_FRAME) {
        videoPrevFrameBtn.innerHTML = icons.VIDEO_PREV_FRAME;
      }
      if (onStepFrame && onProcessFrameStepLoop) {
        videoPrevFrameBtn.addEventListener("mousedown", (event) => {
          event.preventDefault();
          onStepFrame(-1, false);
          frameStepState.buttonHoldTimeout = setTimeout(() => {
            frameStepState.isHoldingKey = true;
            frameStepState.pendingDirection = -1;
            onProcessFrameStepLoop();
          }, 200);
        });
      }
      if (onStopFrameSteppingFromButton) {
        videoPrevFrameBtn.addEventListener("mouseup", onStopFrameSteppingFromButton);
        videoPrevFrameBtn.addEventListener(
          "mouseleave",
          onStopFrameSteppingFromButton,
        );
      }
      bound = true;
    }

    if (videoNextFrameBtn && typeof videoNextFrameBtn.addEventListener === "function") {
      if (icons.VIDEO_NEXT_FRAME) {
        videoNextFrameBtn.innerHTML = icons.VIDEO_NEXT_FRAME;
      }
      if (onStepFrame && onProcessFrameStepLoop) {
        videoNextFrameBtn.addEventListener("mousedown", (event) => {
          event.preventDefault();
          onStepFrame(1, false);
          frameStepState.buttonHoldTimeout = setTimeout(() => {
            frameStepState.isHoldingKey = true;
            frameStepState.pendingDirection = 1;
            onProcessFrameStepLoop();
          }, 200);
        });
      }
      if (onStopFrameSteppingFromButton) {
        videoNextFrameBtn.addEventListener("mouseup", onStopFrameSteppingFromButton);
        videoNextFrameBtn.addEventListener(
          "mouseleave",
          onStopFrameSteppingFromButton,
        );
      }
      bound = true;
    }

    if (videoLoopBtn && typeof videoLoopBtn.addEventListener === "function") {
      if (state.videoLoop) {
        videoLoopBtn.innerHTML = icons.VIDEO_LOOP_ON || "";
      } else {
        videoLoopBtn.innerHTML = icons.VIDEO_LOOP_OFF || "";
      }
      if (onToggleVideoLoop) {
        videoLoopBtn.addEventListener("click", onToggleVideoLoop);
      }
      if (onShowVideoConfig) {
        videoLoopBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowVideoConfig();
        });
      }
      bound = true;
    }

    if (videoConfigBtn && typeof videoConfigBtn.addEventListener === "function") {
      if (icons.VIDEO_CONFIG) {
        videoConfigBtn.innerHTML = icons.VIDEO_CONFIG;
      }
      if (onShowVideoConfig) {
        videoConfigBtn.addEventListener("click", onShowVideoConfig);
      }
      bound = true;
    }

    if (videoSpeedDisplay && typeof videoSpeedDisplay.addEventListener === "function") {
      const speedIndicator = videoSpeedDisplay.parentElement;
      if (speedIndicator) {
        speedIndicator.style.cursor = "pointer";
        if (onShowSpeedPopup) {
          speedIndicator.addEventListener("click", onShowSpeedPopup);
        }
        if (t) {
          speedIndicator.setAttribute("data-tooltip", t("video.clickToAdjustSpeed"));
        }
      }
      bound = true;
    }

    if (videoTimeline && onSeekVideo && typeof videoTimeline.addEventListener === "function") {
      let isDraggingTimeline = false;

      videoTimeline.addEventListener("click", onSeekVideo);
      videoTimeline.addEventListener("mousedown", (event) => {
        isDraggingTimeline = true;
        onSeekVideo(event);
      });

      if (documentRef && typeof documentRef.addEventListener === "function") {
        documentRef.addEventListener("mousemove", (event) => {
          if (!isDraggingTimeline) return;
          onSeekVideo(event);
        });

        documentRef.addEventListener("mouseup", () => {
          isDraggingTimeline = false;
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindPrimarySessionButtons(input = {}) {
    const playPauseBtn = input.playPauseBtn || null;
    const prevBtn = input.prevBtn || null;
    const nextBtn = input.nextBtn || null;
    const settingsBtn = input.settingsBtn || null;
    const flipHorizontalBtn = input.flipHorizontalBtn || null;
    const flipVerticalBtn = input.flipVerticalBtn || null;
    const grayscaleBtn = input.grayscaleBtn || null;
    const blurBtn = input.blurBtn || null;
    const annotateBtn = input.annotateBtn || null;
    const progressiveBlurBtn = input.progressiveBlurBtn || null;
    const homeProgressiveBlurBtn = input.homeProgressiveBlurBtn || null;

    const onTogglePlayPause =
      typeof input.onTogglePlayPause === "function"
        ? input.onTogglePlayPause
        : null;
    const onPreviousImage =
      typeof input.onPreviousImage === "function" ? input.onPreviousImage : null;
    const onShowPrevImageMenu =
      typeof input.onShowPrevImageMenu === "function"
        ? input.onShowPrevImageMenu
        : null;
    const onNextImage =
      typeof input.onNextImage === "function" ? input.onNextImage : null;
    const onShowNextImageMenu =
      typeof input.onShowNextImageMenu === "function"
        ? input.onShowNextImageMenu
        : null;
    const onSettingsClick =
      typeof input.onSettingsClick === "function" ? input.onSettingsClick : null;
    const onSettingsContextMenu =
      typeof input.onSettingsContextMenu === "function"
        ? input.onSettingsContextMenu
        : null;
    const onToggleFlipHorizontal =
      typeof input.onToggleFlipHorizontal === "function"
        ? input.onToggleFlipHorizontal
        : null;
    const onToggleFlipVertical =
      typeof input.onToggleFlipVertical === "function"
        ? input.onToggleFlipVertical
        : null;
    const onToggleGrayscale =
      typeof input.onToggleGrayscale === "function"
        ? input.onToggleGrayscale
        : null;
    const onToggleBlur =
      typeof input.onToggleBlur === "function" ? input.onToggleBlur : null;
    const onShowBlurMenu =
      typeof input.onShowBlurMenu === "function" ? input.onShowBlurMenu : null;
    const onToggleAnnotate =
      typeof input.onToggleAnnotate === "function"
        ? input.onToggleAnnotate
        : null;
    const onToggleProgressiveBlur =
      typeof input.onToggleProgressiveBlur === "function"
        ? input.onToggleProgressiveBlur
        : null;
    const onShowProgressiveBlurMenu =
      typeof input.onShowProgressiveBlurMenu === "function"
        ? input.onShowProgressiveBlurMenu
        : null;

    let bound = false;

    if (playPauseBtn && onTogglePlayPause) {
      playPauseBtn.addEventListener("click", onTogglePlayPause);
      bound = true;
    }

    if (prevBtn) {
      if (onPreviousImage) {
        prevBtn.addEventListener("click", onPreviousImage);
      }
      if (onShowPrevImageMenu) {
        prevBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowPrevImageMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (nextBtn) {
      if (onNextImage) {
        nextBtn.addEventListener("click", onNextImage);
      }
      if (onShowNextImageMenu) {
        nextBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowNextImageMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (settingsBtn) {
      if (onSettingsClick) {
        settingsBtn.addEventListener("click", () => {
          void onSettingsClick();
        });
      }
      if (onSettingsContextMenu) {
        settingsBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onSettingsContextMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (flipHorizontalBtn && onToggleFlipHorizontal) {
      flipHorizontalBtn.addEventListener("click", onToggleFlipHorizontal);
      bound = true;
    }
    if (flipVerticalBtn && onToggleFlipVertical) {
      flipVerticalBtn.addEventListener("click", onToggleFlipVertical);
      bound = true;
    }
    if (grayscaleBtn && onToggleGrayscale) {
      grayscaleBtn.addEventListener("click", onToggleGrayscale);
      bound = true;
    }

    if (blurBtn) {
      if (onToggleBlur) {
        blurBtn.addEventListener("click", onToggleBlur);
      }
      if (onShowBlurMenu) {
        blurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (annotateBtn && onToggleAnnotate) {
      annotateBtn.addEventListener("click", onToggleAnnotate);
      bound = true;
    }

    if (progressiveBlurBtn) {
      if (onToggleProgressiveBlur) {
        progressiveBlurBtn.addEventListener("click", onToggleProgressiveBlur);
      }
      if (onShowProgressiveBlurMenu) {
        progressiveBlurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressiveBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    if (homeProgressiveBlurBtn) {
      if (onToggleProgressiveBlur) {
        homeProgressiveBlurBtn.addEventListener("click", onToggleProgressiveBlur);
      }
      if (onShowProgressiveBlurMenu) {
        homeProgressiveBlurBtn.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          onShowProgressiveBlurMenu(event.clientX, event.clientY, event);
        });
      }
      bound = true;
    }

    return bound;
  }

  function bindSessionEntryAndModeControls(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const startBtn = input.startBtn || null;
    const chooseMediaFolderBtn = input.chooseMediaFolderBtn || null;
    const stopBtn = input.stopBtn || null;
    const closeReviewBtn = input.closeReviewBtn || null;
    const customAddBtn = input.customAddBtn || null;
    const addPauseBtn = input.addPauseBtn || null;
    const customInputs = Array.isArray(input.customInputs) ? input.customInputs : [];

    const onStartSession =
      typeof input.onStartSession === "function" ? input.onStartSession : null;
    const onChooseMediaFolder =
      typeof input.onChooseMediaFolder === "function"
        ? input.onChooseMediaFolder
        : null;
    const onShowReview =
      typeof input.onShowReview === "function" ? input.onShowReview : null;
    const onCloseReview =
      typeof input.onCloseReview === "function" ? input.onCloseReview : null;
    const onSwitchMode =
      typeof input.onSwitchMode === "function" ? input.onSwitchMode : null;
    const onAddCustomStep =
      typeof input.onAddCustomStep === "function" ? input.onAddCustomStep : null;
    const onAddCustomPause =
      typeof input.onAddCustomPause === "function" ? input.onAddCustomPause : null;

    let bound = false;

    if (startBtn && onStartSession) {
      startBtn.addEventListener("click", onStartSession);
      bound = true;
    }

    if (chooseMediaFolderBtn && onChooseMediaFolder) {
      chooseMediaFolderBtn.addEventListener("click", () => {
        void onChooseMediaFolder();
      });
      bound = true;
    }

    if (stopBtn && onShowReview) {
      stopBtn.addEventListener("click", onShowReview);
      bound = true;
    }

    if (closeReviewBtn && onCloseReview) {
      closeReviewBtn.addEventListener("click", onCloseReview);
      bound = true;
    }

    if (documentRef && onSwitchMode) {
      documentRef.querySelectorAll(".mode-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          onSwitchMode(btn.dataset.mode);
        });
      });
      bound = true;
    }

    if (customAddBtn && onAddCustomStep) {
      customAddBtn.onclick = (event) => {
        event.preventDefault();
        onAddCustomStep();
      };
      bound = true;
    }

    if (addPauseBtn && onAddCustomPause) {
      addPauseBtn.onclick = (event) => {
        event.preventDefault();
        onAddCustomPause();
      };
      bound = true;
    }

    if (onAddCustomStep) {
      customInputs.forEach((inputEl) => {
        if (!inputEl || typeof inputEl.addEventListener !== "function") return;
        inputEl.addEventListener("keydown", (event) => {
          if (event.key !== "Enter") return;
          event.preventDefault();
          onAddCustomStep();
        });
      });
      bound = bound || customInputs.length > 0;
    }

    return bound;
  }

  function bindGlobalSettingsControls(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const globalSettingsModal = input.globalSettingsModal || null;
    const closeGlobalSettingsModalBtn = input.closeGlobalSettingsModalBtn || null;
    const globalSettingsToggleGridBtn = input.globalSettingsToggleGridBtn || null;
    const globalSettingsToggleThemeBtn = input.globalSettingsToggleThemeBtn || null;
    const globalSettingsOpenHotkeysBtn = input.globalSettingsOpenHotkeysBtn || null;
    const globalSettingsTitlebarAlwaysVisibleInput =
      input.globalSettingsTitlebarAlwaysVisibleInput || null;
    const globalSettingsLanguageSelect = input.globalSettingsLanguageSelect || null;
    const globalSettingsDefaultModeGroup = input.globalSettingsDefaultModeGroup || null;

    const onCloseGlobalSettingsModal =
      typeof input.onCloseGlobalSettingsModal === "function"
        ? input.onCloseGlobalSettingsModal
        : null;
    const onToggleGrid =
      typeof input.onToggleGrid === "function" ? input.onToggleGrid : null;
    const onToggleTheme =
      typeof input.onToggleTheme === "function" ? input.onToggleTheme : null;
    const onOpenHotkeys =
      typeof input.onOpenHotkeys === "function" ? input.onOpenHotkeys : null;
    const onTitlebarAlwaysVisibleChanged =
      typeof input.onTitlebarAlwaysVisibleChanged === "function"
        ? input.onTitlebarAlwaysVisibleChanged
        : null;
    const onLanguageSelected =
      typeof input.onLanguageSelected === "function"
        ? input.onLanguageSelected
        : null;
    const onDefaultModeSelected =
      typeof input.onDefaultModeSelected === "function"
        ? input.onDefaultModeSelected
        : null;

    let bound = false;

    if (closeGlobalSettingsModalBtn && onCloseGlobalSettingsModal) {
      closeGlobalSettingsModalBtn.addEventListener("click", () => {
        onCloseGlobalSettingsModal();
      });
      bound = true;
    }

    if (globalSettingsModal && onCloseGlobalSettingsModal) {
      globalSettingsModal.addEventListener("click", (event) => {
        if (event.target !== globalSettingsModal) return;
        onCloseGlobalSettingsModal();
      });
      bound = true;
    }

    if (globalSettingsToggleGridBtn && onToggleGrid) {
      const isCheckboxControl =
        globalSettingsToggleGridBtn.tagName === "INPUT" &&
        String(globalSettingsToggleGridBtn.type || "").toLowerCase() ===
          "checkbox";
      const eventName = isCheckboxControl ? "change" : "click";
      globalSettingsToggleGridBtn.addEventListener(eventName, () => {
        onToggleGrid({
          isCheckboxControl,
          checked: !!globalSettingsToggleGridBtn.checked,
        });
      });
      bound = true;
    }

    if (globalSettingsToggleThemeBtn && onToggleTheme) {
      globalSettingsToggleThemeBtn.addEventListener("click", onToggleTheme);
      bound = true;
    }

    if (globalSettingsOpenHotkeysBtn && onOpenHotkeys) {
      globalSettingsOpenHotkeysBtn.addEventListener("click", onOpenHotkeys);
      bound = true;
    }

    if (
      globalSettingsTitlebarAlwaysVisibleInput &&
      onTitlebarAlwaysVisibleChanged
    ) {
      globalSettingsTitlebarAlwaysVisibleInput.addEventListener("change", () => {
        onTitlebarAlwaysVisibleChanged(
          !!globalSettingsTitlebarAlwaysVisibleInput.checked,
        );
      });
      bound = true;
    }

    if (globalSettingsLanguageSelect && onLanguageSelected) {
      const isNativeSelect =
        globalSettingsLanguageSelect.tagName === "SELECT" &&
        typeof globalSettingsLanguageSelect.addEventListener === "function";

      if (isNativeSelect) {
        globalSettingsLanguageSelect.addEventListener("change", () => {
          onLanguageSelected(globalSettingsLanguageSelect.value);
        });
        bound = true;
      } else {
        const languageTrigger = globalSettingsLanguageSelect.querySelector(
          ".global-settings-language-trigger",
        );
        const languageMenu = globalSettingsLanguageSelect.querySelector(
          ".global-settings-language-menu",
        );
        const languageOptions = Array.from(
          globalSettingsLanguageSelect.querySelectorAll(
            ".global-settings-language-option[data-lang]",
          ),
        );

        const closeLanguageMenu = () => {
          if (!languageMenu) return;
          languageMenu.hidden = true;
          globalSettingsLanguageSelect.classList.remove("is-open");
          if (languageTrigger) {
            languageTrigger.setAttribute("aria-expanded", "false");
          }
        };

        const openLanguageMenu = () => {
          if (!languageMenu || languageOptions.length === 0) return;
          languageMenu.hidden = false;
          globalSettingsLanguageSelect.classList.add("is-open");
          if (languageTrigger) {
            languageTrigger.setAttribute("aria-expanded", "true");
          }
        };

        const toggleLanguageMenu = () => {
          if (!languageMenu) return;
          if (languageMenu.hidden) {
            openLanguageMenu();
          } else {
            closeLanguageMenu();
          }
        };

        if (languageTrigger) {
          languageTrigger.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleLanguageMenu();
          });
          languageTrigger.addEventListener("keydown", (event) => {
            if (
              event.key === "Enter" ||
              event.key === " " ||
              event.key === "ArrowDown"
            ) {
              event.preventDefault();
              openLanguageMenu();
            }
          });
          bound = true;
        }

        languageOptions.forEach((optionEl) => {
          optionEl.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            const nextLanguage = String(optionEl.dataset.lang || "").trim();
            if (!nextLanguage) return;
            globalSettingsLanguageSelect.dataset.value = nextLanguage;
            closeLanguageMenu();
            onLanguageSelected(nextLanguage);
          });
          optionEl.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              event.preventDefault();
              closeLanguageMenu();
              if (languageTrigger && typeof languageTrigger.focus === "function") {
                languageTrigger.focus();
              }
              return;
            }
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              const nextLanguage = String(optionEl.dataset.lang || "").trim();
              if (!nextLanguage) return;
              globalSettingsLanguageSelect.dataset.value = nextLanguage;
              closeLanguageMenu();
              onLanguageSelected(nextLanguage);
            }
          });
        });
        bound = bound || languageOptions.length > 0;

        if (documentRef && typeof documentRef.addEventListener === "function") {
          documentRef.addEventListener("click", (event) => {
            if (!globalSettingsLanguageSelect.contains(event.target)) {
              closeLanguageMenu();
            }
          });
          documentRef.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
              closeLanguageMenu();
            }
          });
          bound = true;
        }
      }
    }

    if (globalSettingsDefaultModeGroup && onDefaultModeSelected) {
      globalSettingsDefaultModeGroup.addEventListener("click", (event) => {
        const modeBtn = event.target.closest(".search-toggle-btn[data-mode]");
        if (!modeBtn || !globalSettingsDefaultModeGroup.contains(modeBtn)) return;
        onDefaultModeSelected(modeBtn.dataset.mode);
      });
      bound = true;
    }

    return bound;
  }

  function bindGlobalSettingsActionButtons(input = {}) {
    const globalResetSettingsBtn = input.globalResetSettingsBtn || null;
    const globalSettingsExportPrefsBtn = input.globalSettingsExportPrefsBtn || null;
    const globalSettingsImportPrefsBtn = input.globalSettingsImportPrefsBtn || null;
    const globalSettingsRepairStorageBtn = input.globalSettingsRepairStorageBtn || null;

    const onResetSettings =
      typeof input.onResetSettings === "function" ? input.onResetSettings : null;
    const onExportPreferences =
      typeof input.onExportPreferences === "function"
        ? input.onExportPreferences
        : null;
    const onImportPreferences =
      typeof input.onImportPreferences === "function"
        ? input.onImportPreferences
        : null;
    const onRepairStorage =
      typeof input.onRepairStorage === "function" ? input.onRepairStorage : null;

    let bound = false;

    if (globalResetSettingsBtn && onResetSettings) {
      globalResetSettingsBtn.addEventListener("click", async () => {
        await onResetSettings();
      });
      bound = true;
    }

    if (globalSettingsExportPrefsBtn && onExportPreferences) {
      globalSettingsExportPrefsBtn.addEventListener("click", async () => {
        await onExportPreferences();
      });
      bound = true;
    }

    if (globalSettingsImportPrefsBtn && onImportPreferences) {
      globalSettingsImportPrefsBtn.addEventListener("click", async () => {
        await onImportPreferences();
      });
      bound = true;
    }

    if (globalSettingsRepairStorageBtn && onRepairStorage) {
      globalSettingsRepairStorageBtn.addEventListener("click", async () => {
        await onRepairStorage();
      });
      bound = true;
    }

    return bound;
  }

  function bindClassicDurationButtons(input = {}) {
    const durationBtns = Array.isArray(input.durationBtns) ? input.durationBtns : [];
    const hoursInput = input.hoursInput || null;
    const minutesInput = input.minutesInput || null;
    const secondsInput = input.secondsInput || null;
    const domInputGroups = Array.isArray(input.domInputGroups)
      ? input.domInputGroups
      : [];
    const state = input.state || {};
    const getDurationFromButton =
      typeof input.getDurationFromButton === "function"
        ? input.getDurationFromButton
        : null;
    const onToggleDurationButtonsForValue =
      typeof input.onToggleDurationButtonsForValue === "function"
        ? input.onToggleDurationButtonsForValue
        : null;

    if (
      durationBtns.length === 0 ||
      !getDurationFromButton ||
      !onToggleDurationButtonsForValue
    ) {
      return false;
    }

    durationBtns.forEach((btn) => {
      if (!btn || typeof btn.addEventListener !== "function") return;
      btn.addEventListener("click", () => {
        const durationValue = getDurationFromButton(btn);
        onToggleDurationButtonsForValue(durationBtns, durationValue);
        state.selectedDuration = durationValue;
        if (hoursInput) hoursInput.value = 0;
        if (minutesInput) minutesInput.value = 0;
        if (secondsInput) secondsInput.value = 0;
        domInputGroups.forEach((group) => {
          if (group && group.classList) {
            group.classList.remove("active");
          }
        });
      });
    });

    return true;
  }

  function bindMemoryTypeSwitchButtons(input = {}) {
    const memoryTypeBtns = Array.isArray(input.memoryTypeBtns)
      ? input.memoryTypeBtns
      : [];
    const memoryFlashSettings = input.memoryFlashSettings || null;
    const memoryProgressiveSettings = input.memoryProgressiveSettings || null;
    const state = input.state || {};

    if (memoryTypeBtns.length === 0) return false;

    memoryTypeBtns.forEach((btn) => {
      if (!btn || typeof btn.addEventListener !== "function") return;
      btn.addEventListener("click", () => {
        const memoryType = btn.dataset.memoryType;
        state.memoryType = memoryType;

        memoryTypeBtns.forEach((item) => item.classList.remove("active"));
        btn.classList.add("active");

        if (!memoryFlashSettings || !memoryProgressiveSettings) return;
        if (memoryType === "flash") {
          memoryFlashSettings.style.display = "block";
          memoryProgressiveSettings.style.display = "none";
        } else {
          memoryFlashSettings.style.display = "none";
          memoryProgressiveSettings.style.display = "block";
        }
      });
    });

    return true;
  }

  function bindMemoryDurationControls(input = {}) {
    const memoryFlashBtns = Array.isArray(input.memoryFlashBtns)
      ? input.memoryFlashBtns
      : [];
    const memoryProgressiveBtns = Array.isArray(input.memoryProgressiveBtns)
      ? input.memoryProgressiveBtns
      : [];
    const memoryProgressiveMinutes = input.memoryProgressiveMinutes || null;
    const memoryProgressiveSeconds = input.memoryProgressiveSeconds || null;
    const memoryProgressiveCustomTime = input.memoryProgressiveCustomTime || null;
    const memoryFlashMinutes = input.memoryFlashMinutes || null;
    const memoryFlashSeconds = input.memoryFlashSeconds || null;
    const memoryCustomTime = input.memoryCustomTime || null;
    const memoryDrawingTimeInput = input.memoryDrawingTimeInput || null;
    const state = input.state || {};

    const getDurationFromButton =
      typeof input.getDurationFromButton === "function"
        ? input.getDurationFromButton
        : null;
    const onToggleDurationButtonsForValue =
      typeof input.onToggleDurationButtonsForValue === "function"
        ? input.onToggleDurationButtonsForValue
        : null;
    const onClearDurationButtonsActive =
      typeof input.onClearDurationButtonsActive === "function"
        ? input.onClearDurationButtonsActive
        : null;
    const onReadMinutesSecondsInputValues =
      typeof input.onReadMinutesSecondsInputValues === "function"
        ? input.onReadMinutesSecondsInputValues
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;

    let bound = false;

    if (
      memoryFlashBtns.length > 0 &&
      getDurationFromButton &&
      onToggleDurationButtonsForValue
    ) {
      memoryFlashBtns.forEach((btn) => {
        if (!btn || typeof btn.addEventListener !== "function") return;
        btn.addEventListener("click", () => {
          const durationValue = getDurationFromButton(btn);
          onToggleDurationButtonsForValue(memoryFlashBtns, durationValue);
          state.memoryDuration = durationValue;

          if (memoryCustomTime) {
            memoryCustomTime.classList.remove("active");
          }
          if (memoryFlashMinutes) memoryFlashMinutes.value = 0;
          if (memoryFlashSeconds) memoryFlashSeconds.value = 0;
          if (onUpdateMemoryTotalDuration) {
            onUpdateMemoryTotalDuration();
          }
          if (state.memoryDrawingTime > 0 && memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.add("active");
          }
        });
      });
      bound = true;
    }

    if (
      memoryProgressiveBtns.length > 0 &&
      getDurationFromButton &&
      onToggleDurationButtonsForValue
    ) {
      memoryProgressiveBtns.forEach((btn) => {
        if (!btn || typeof btn.addEventListener !== "function") return;
        btn.addEventListener("click", () => {
          const durationValue = getDurationFromButton(btn);
          onToggleDurationButtonsForValue(memoryProgressiveBtns, durationValue);
          state.selectedDuration = durationValue;
          if (memoryProgressiveCustomTime) {
            memoryProgressiveCustomTime.classList.remove("active");
          }
          if (memoryProgressiveMinutes) memoryProgressiveMinutes.value = 0;
          if (memoryProgressiveSeconds) memoryProgressiveSeconds.value = 0;
        });
      });
      bound = true;
    }

    if (
      memoryProgressiveMinutes &&
      memoryProgressiveSeconds &&
      onReadMinutesSecondsInputValues
    ) {
      const updateMemoryProgressiveDuration = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryProgressiveMinutes,
          memoryProgressiveSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (onClearDurationButtonsActive) {
            onClearDurationButtonsActive(memoryProgressiveBtns);
          }
          if (memoryProgressiveCustomTime) {
            memoryProgressiveCustomTime.classList.add("active");
          }
          state.selectedDuration = totalSeconds;
        } else if (memoryProgressiveCustomTime) {
          memoryProgressiveCustomTime.classList.remove("active");
        }
      };

      memoryProgressiveMinutes.addEventListener(
        "input",
        updateMemoryProgressiveDuration,
      );
      memoryProgressiveSeconds.addEventListener(
        "input",
        updateMemoryProgressiveDuration,
      );
      bound = true;
    }

    if (memoryFlashMinutes && memoryFlashSeconds && onReadMinutesSecondsInputValues) {
      const updateMemoryDuration = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryFlashMinutes,
          memoryFlashSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (onClearDurationButtonsActive) {
            onClearDurationButtonsActive(memoryFlashBtns);
          }
          if (memoryCustomTime) {
            memoryCustomTime.classList.add("active");
          }
          state.memoryDuration = totalSeconds;
        } else if (memoryCustomTime) {
          memoryCustomTime.classList.remove("active");
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      };

      memoryFlashMinutes.addEventListener("input", updateMemoryDuration);
      memoryFlashSeconds.addEventListener("input", updateMemoryDuration);
      bound = true;
    }

    return bound;
  }

  function bindMemoryDrawingTimeControls(input = {}) {
    const memoryDrawingMinutes = input.memoryDrawingMinutes || null;
    const memoryDrawingSeconds = input.memoryDrawingSeconds || null;
    const memoryDrawingTimeInput = input.memoryDrawingTimeInput || null;
    const noPressureBtn = input.noPressureBtn || null;
    const state = input.state || {};

    const onReadMinutesSecondsInputValues =
      typeof input.onReadMinutesSecondsInputValues === "function"
        ? input.onReadMinutesSecondsInputValues
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;

    let bound = false;

    if (
      memoryDrawingMinutes &&
      memoryDrawingSeconds &&
      onReadMinutesSecondsInputValues
    ) {
      const updateMemoryDrawingTime = () => {
        const result = onReadMinutesSecondsInputValues(
          memoryDrawingMinutes,
          memoryDrawingSeconds,
        );
        const totalSeconds = Number(result?.totalSeconds || 0);

        if (totalSeconds > 0) {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.add("active");
          }
          if (noPressureBtn) {
            noPressureBtn.classList.remove("active");
          }
          state.memoryDrawingTime = totalSeconds;
          state.memoryNoPressure = false;
        } else {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.remove("active");
          }
          state.memoryDrawingTime = 0;
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      };

      memoryDrawingMinutes.addEventListener("input", updateMemoryDrawingTime);
      memoryDrawingSeconds.addEventListener("input", updateMemoryDrawingTime);
      bound = true;
    }

    if (noPressureBtn) {
      noPressureBtn.addEventListener("click", () => {
        const isActive = noPressureBtn.classList.toggle("active");
        if (isActive) {
          if (memoryDrawingTimeInput) {
            memoryDrawingTimeInput.classList.remove("active");
          }
          if (memoryDrawingMinutes) memoryDrawingMinutes.value = 0;
          if (memoryDrawingSeconds) memoryDrawingSeconds.value = 0;
          state.memoryDrawingTime = 0;
          state.memoryNoPressure = true;
        } else {
          state.memoryNoPressure = false;
        }

        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      });
      bound = true;
    }

    return bound;
  }

  function makeEditableNumericValue(input = {}) {
    const valueElement = input.valueElement || null;
    const sliderElement = input.sliderElement || null;
    const onUpdate =
      typeof input.onUpdate === "function" ? input.onUpdate : null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    if (!valueElement || !sliderElement || !documentRef) return false;

    const currentValue = parseInt(valueElement.textContent, 10);
    const min = parseInt(sliderElement.min, 10);
    const max = parseInt(sliderElement.max, 10);

    const editInput = documentRef.createElement("input");
    editInput.type = "number";
    editInput.min = min;
    editInput.max = max;
    editInput.value = Number.isFinite(currentValue) ? currentValue : min;
    editInput.style.cssText = `
      width: 50px;
      padding: 2px 4px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--color-primary);
      border-radius: 4px;
      color: var(--color-primary);
      font-weight: bold;
      font-size: inherit;
      text-align: center;
    `;

    const validateAndRestore = () => {
      let newValue = parseInt(editInput.value, 10);
      if (Number.isNaN(newValue) || newValue < min) {
        newValue = min;
      } else if (newValue > max) {
        newValue = max;
      }
      sliderElement.value = newValue;
      valueElement.textContent = newValue;
      valueElement.style.display = "";
      if (onUpdate) {
        onUpdate(newValue);
      }
      editInput.remove();
    };

    valueElement.style.display = "none";
    valueElement.parentElement.appendChild(editInput);
    editInput.focus();
    editInput.select();

    editInput.addEventListener("blur", validateAndRestore);
    editInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        validateAndRestore();
      } else if (event.key === "Escape") {
        event.preventDefault();
        valueElement.style.display = "";
        editInput.remove();
      }
    });

    return true;
  }

  function bindMemoryPoseSliders(input = {}) {
    const memoryPosesSlider = input.memoryPosesSlider || null;
    const memoryPosesValue = input.memoryPosesValue || null;
    const memoryProgressivePosesSlider = input.memoryProgressivePosesSlider || null;
    const memoryProgressivePosesValue = input.memoryProgressivePosesValue || null;
    const state = input.state || {};
    const clickToEnterLabel = input.clickToEnterLabel || "";

    const onInitSliderWithGradient =
      typeof input.onInitSliderWithGradient === "function"
        ? input.onInitSliderWithGradient
        : null;
    const onUpdateSliderGradient =
      typeof input.onUpdateSliderGradient === "function"
        ? input.onUpdateSliderGradient
        : null;
    const onUpdateMemoryTotalDuration =
      typeof input.onUpdateMemoryTotalDuration === "function"
        ? input.onUpdateMemoryTotalDuration
        : null;
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);

    let bound = false;

    if (memoryPosesSlider && memoryPosesValue) {
      if (onInitSliderWithGradient) {
        onInitSliderWithGradient(memoryPosesSlider);
      }

      memoryPosesSlider.addEventListener("input", (event) => {
        const value = parseInt(event.target.value, 10);
        state.memoryPosesCount = value;
        memoryPosesValue.textContent = value;
        if (onUpdateSliderGradient) {
          onUpdateSliderGradient(memoryPosesSlider);
        }
        if (onUpdateMemoryTotalDuration) {
          onUpdateMemoryTotalDuration();
        }
      });

      memoryPosesValue.style.cursor = "pointer";
      if (clickToEnterLabel) {
        memoryPosesValue.title = clickToEnterLabel;
      }
      memoryPosesValue.addEventListener("click", () => {
        makeEditableNumericValue({
          valueElement: memoryPosesValue,
          sliderElement: memoryPosesSlider,
          documentRef,
          onUpdate: (newValue) => {
            state.memoryPosesCount = newValue;
            if (onUpdateSliderGradient) {
              onUpdateSliderGradient(memoryPosesSlider);
            }
            if (onUpdateMemoryTotalDuration) {
              onUpdateMemoryTotalDuration();
            }
          },
        });
      });
      bound = true;
    }

    if (memoryProgressivePosesSlider && memoryProgressivePosesValue) {
      if (onInitSliderWithGradient) {
        onInitSliderWithGradient(memoryProgressivePosesSlider);
      }

      memoryProgressivePosesSlider.addEventListener("input", (event) => {
        const value = parseInt(event.target.value, 10);
        state.memoryPosesCount = value;
        memoryProgressivePosesValue.textContent = value;
        if (onUpdateSliderGradient) {
          onUpdateSliderGradient(memoryProgressivePosesSlider);
        }
      });

      memoryProgressivePosesValue.style.cursor = "pointer";
      if (clickToEnterLabel) {
        memoryProgressivePosesValue.title = clickToEnterLabel;
      }
      memoryProgressivePosesValue.addEventListener("click", () => {
        makeEditableNumericValue({
          valueElement: memoryProgressivePosesValue,
          sliderElement: memoryProgressivePosesSlider,
          documentRef,
          onUpdate: (newValue) => {
            state.memoryPosesCount = newValue;
            if (onUpdateSliderGradient) {
              onUpdateSliderGradient(memoryProgressivePosesSlider);
            }
          },
        });
      });
      bound = true;
    }

    return bound;
  }

  function bindCustomHmsTimerInputs(input = {}) {
    const inputs = Array.isArray(input.inputs) ? input.inputs : [];
    const state = input.state || {};
    const domDurationButtons = Array.isArray(input.domDurationButtons)
      ? input.domDurationButtons
      : [];
    const domInputGroups = Array.isArray(input.domInputGroups)
      ? input.domInputGroups
      : [];

    const onReadHmsInputValues =
      typeof input.onReadHmsInputValues === "function"
        ? input.onReadHmsInputValues
        : null;
    const onClearDurationButtonsActive =
      typeof input.onClearDurationButtonsActive === "function"
        ? input.onClearDurationButtonsActive
        : null;
    const onUpdateTimerDisplay =
      typeof input.onUpdateTimerDisplay === "function"
        ? input.onUpdateTimerDisplay
        : null;
    const createDebounce =
      typeof input.createDebounce === "function" ? input.createDebounce : null;
    const debounceMs = Number(input.debounceMs || 50);

    if (!onReadHmsInputValues || inputs.length === 0) return false;

    const handler = () => {
      const result = onReadHmsInputValues();
      const totalCustom = Number(result?.totalSeconds || 0);
      if (totalCustom > 0) {
        if (onClearDurationButtonsActive) {
          onClearDurationButtonsActive(domDurationButtons);
        }
        domInputGroups.forEach((group) => {
          if (group && group.classList) {
            group.classList.add("active");
          }
        });
        state.selectedDuration = totalCustom;
      }
      state.timeRemaining = state.selectedDuration;
      if (onUpdateTimerDisplay) {
        onUpdateTimerDisplay();
      }
    };

    const debouncedHandler = createDebounce
      ? createDebounce(handler, debounceMs)
      : handler;

    inputs.forEach((inputEl) => {
      if (!inputEl || typeof inputEl.addEventListener !== "function") return;
      inputEl.addEventListener("input", debouncedHandler);
    });

    return true;
  }

  function bindSessionPlansModalBasics(input = {}) {
    const documentRef =
      input.documentRef || (typeof document !== "undefined" ? document : null);
    const managePlansBtn = input.managePlansBtn || null;
    const closePlansModal = input.closePlansModal || null;
    const sessionPlansModal = input.sessionPlansModal || null;
    const onOpen = typeof input.onOpen === "function" ? input.onOpen : null;
    const onClose = typeof input.onClose === "function" ? input.onClose : null;

    if (!sessionPlansModal) return false;

    const escapeHandler = (event) => {
      if (
        event.key === "Escape" &&
        !sessionPlansModal.classList.contains("hidden")
      ) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (onClose) {
          onClose("escape");
        }
        if (documentRef) {
          documentRef.removeEventListener("keydown", escapeHandler, true);
        }
      }
    };

    if (managePlansBtn) {
      managePlansBtn.addEventListener("click", async () => {
        if (onOpen) {
          await onOpen();
        }
        if (documentRef) {
          documentRef.addEventListener("keydown", escapeHandler, true);
        }
      });
    }

    if (closePlansModal) {
      closePlansModal.addEventListener("click", () => {
        if (onClose) {
          onClose("button");
        }
        if (documentRef) {
          documentRef.removeEventListener("keydown", escapeHandler, true);
        }
      });
    }

    sessionPlansModal.addEventListener("click", (event) => {
      if (event.target !== sessionPlansModal) return;
      if (onClose) {
        onClose("overlay");
      }
    });

    return true;
  }

  function bindSessionPlansCrudControls(input = {}) {
    const savePlanBtn = input.savePlanBtn || null;
    const savedPlansList = input.savedPlansList || null;
    const onSavePlan =
      typeof input.onSavePlan === "function" ? input.onSavePlan : null;
    const onSavedPlansClick =
      typeof input.onSavedPlansClick === "function"
        ? input.onSavedPlansClick
        : null;

    let bound = false;

    if (savePlanBtn && onSavePlan) {
      savePlanBtn.addEventListener("click", async () => {
        await onSavePlan();
      });
      bound = true;
    }

    if (savedPlansList && onSavedPlansClick) {
      savedPlansList.addEventListener("click", async (event) => {
        await onSavedPlansClick(event);
      });
      bound = true;
    }

    return bound;
  }

  function resolveMemoryTotalDurationDisplay(input = {}) {
    const state = input.state || {};
    const calculateTotalSeconds =
      typeof input.calculateTotalSeconds === "function"
        ? input.calculateTotalSeconds
        : null;

    if (state.memoryNoPressure) {
      return { visible: false, text: "" };
    }

    if (!state.memoryDrawingTime || state.memoryDrawingTime === 0) {
      return { visible: false, text: "" };
    }

    if (!calculateTotalSeconds) {
      return { visible: false, text: "" };
    }

    const posesCount = state.memoryPosesCount || 10;
    const drawingTime = state.memoryDrawingTime || 0;
    const displayTime = state.memoryDuration || 0;
    const totalSeconds = Number(
      calculateTotalSeconds(posesCount, drawingTime, displayTime),
    );

    const safeSeconds = Number.isFinite(totalSeconds)
      ? Math.max(0, Math.floor(totalSeconds))
      : 0;
    const hours = Math.floor(safeSeconds / 3600);
    const minutes = Math.floor((safeSeconds % 3600) / 60);
    const seconds = safeSeconds % 60;

    let formattedTime = "";
    if (hours > 0) {
      formattedTime += `${hours}h `;
    }
    if (minutes > 0 || hours > 0) {
      formattedTime += `${minutes}min `;
    }
    formattedTime += `${seconds}s`;

    return {
      visible: true,
      text: formattedTime.trim(),
      totalSeconds: safeSeconds,
    };
  }

  function createSessionControlsBindingsUtils() {
    return {
      bindMemoryOverlayButtons,
      bindShuffleAndAutoFlipButtons,
      bindTimerControlsAndProgress,
      bindVideoScrubbing,
      bindVideoControls,
      bindPrimarySessionButtons,
      bindSessionEntryAndModeControls,
      bindGlobalSettingsControls,
      bindGlobalSettingsActionButtons,
      bindClassicDurationButtons,
      bindMemoryTypeSwitchButtons,
      bindMemoryDurationControls,
      bindMemoryDrawingTimeControls,
      makeEditableNumericValue,
      bindMemoryPoseSliders,
      bindCustomHmsTimerInputs,
      bindSessionPlansModalBasics,
      bindSessionPlansCrudControls,
      resolveMemoryTotalDurationDisplay,
    };
  }

  sharedRoot.createSessionControlsBindingsUtils = createSessionControlsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-surface-interactions-bindings-utils.js ===== */
(function initPoseChronoSharedSessionSurfaceInteractionsBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindSessionSurfaceInteractions(input = {}) {
    const documentRef = input.documentRef || null;
    const currentImage = input.currentImage || null;
    const memoryOverlay = input.memoryOverlay || null;
    const state = input.state || null;
    const onToggleSidebar =
      typeof input.onToggleSidebar === "function" ? input.onToggleSidebar : null;
    const onNextImage =
      typeof input.onNextImage === "function" ? input.onNextImage : null;

    let bound = false;

    if (currentImage && typeof currentImage.addEventListener === "function" && onToggleSidebar) {
      currentImage.addEventListener("click", () => {
        if (!documentRef) {
          onToggleSidebar();
          return;
        }
        const gridPopup = documentRef.getElementById("grid-config-popup");
        const silhouettePopup = documentRef.getElementById(
          "silhouette-config-popup",
        );
        if (gridPopup || silhouettePopup) return;
        onToggleSidebar();
      });
      bound = true;
    }

    if (memoryOverlay && typeof memoryOverlay.addEventListener === "function" && state && onNextImage) {
      memoryOverlay.addEventListener("click", (event) => {
        if (event?.target && typeof event.target.closest === "function") {
          if (event.target.closest(".memory-overlay-btn")) return;
        }
        if (
          state.sessionMode === "memory" &&
          state.memoryHidden &&
          state.memoryNoPressure
        ) {
          onNextImage();
        }
      });
      bound = true;
    }

    return bound;
  }

  function createSessionSurfaceInteractionsBindingsUtils() {
    return {
      bindSessionSurfaceInteractions,
    };
  }

  sharedRoot.createSessionSurfaceInteractionsBindingsUtils =
    createSessionSurfaceInteractionsBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/custom-session-utils.js ===== */
(function initPoseChronoSharedCustomSessionUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function toPositiveInt(value, fallback = 0) {
    return Math.max(0, toInt(value, fallback));
  }

  function isPoseStep(step) {
    return !!step && typeof step === "object" && step.type === "pose";
  }

  function findNextPoseStepIndex(queue, fromIndex) {
    if (!Array.isArray(queue)) return -1;
    const start = Math.max(-1, toInt(fromIndex, -1));
    for (let i = start + 1; i < queue.length; i++) {
      if (isPoseStep(queue[i])) return i;
    }
    return -1;
  }

  function findPrevPoseStepIndex(queue, fromIndex) {
    if (!Array.isArray(queue)) return -1;
    const start = Math.min(queue.length, toInt(fromIndex, queue.length));
    for (let i = start - 1; i >= 0; i--) {
      if (isPoseStep(queue[i])) return i;
    }
    return -1;
  }

  function findNextPoseStep(queue, fromIndex) {
    const idx = findNextPoseStepIndex(queue, fromIndex);
    return idx >= 0 ? queue[idx] : null;
  }

  function hasNextPoseGroup(queue, fromIndex) {
    return findNextPoseStepIndex(queue, fromIndex) >= 0;
  }

  function hasPrevPoseGroup(queue, fromIndex) {
    return findPrevPoseStepIndex(queue, fromIndex) >= 0;
  }

  function getCustomPoseSessionProgress(queue, currentStepIndex, currentPoseInStep) {
    if (!Array.isArray(queue) || queue.length === 0) {
      return {
        totalPoses: 0,
        globalPoseIndex: 0,
        poseGroupCount: 0,
        showGlobal: false,
      };
    }

    const stepIndex = toInt(currentStepIndex, 0);
    const poseInStep = Math.max(1, toInt(currentPoseInStep, 1));
    let totalPoses = 0;
    let poseGroupCount = 0;
    let globalPoseIndex = 0;

    for (let i = 0; i < queue.length; i++) {
      const step = queue[i];
      if (!isPoseStep(step)) continue;
      const count = Math.max(1, toInt(step.count, 1));
      poseGroupCount += 1;
      totalPoses += count;
      if (i < stepIndex) {
        globalPoseIndex += count;
      }
    }

    const current = queue[stepIndex];
    if (isPoseStep(current)) {
      const currentCount = Math.max(1, toInt(current.count, 1));
      globalPoseIndex += Math.min(currentCount, Math.max(1, poseInStep));
    } else if (totalPoses > 0 && globalPoseIndex <= 0) {
      globalPoseIndex = 1;
    }

    return {
      totalPoses,
      globalPoseIndex: Math.min(Math.max(globalPoseIndex, 0), totalPoses),
      poseGroupCount,
      showGlobal: poseGroupCount > 1,
    };
  }

  function calculateCustomTotalRemainingSeconds(
    queue,
    currentStepIndex,
    currentPoseInStep,
    timeRemaining,
  ) {
    const totalNow = toPositiveInt(timeRemaining, 0);
    if (!Array.isArray(queue) || queue.length === 0) return totalNow;

    const stepIndex = toInt(currentStepIndex, 0);
    const poseInStep = Math.max(1, toInt(currentPoseInStep, 1));
    let total = totalNow;

    for (let i = stepIndex + 1; i < queue.length; i++) {
      const step = queue[i];
      if (!step || typeof step !== "object") continue;
      const duration = toPositiveInt(step.duration, 0);
      if (step.type === "pause") {
        total += duration;
      } else {
        const count = Math.max(1, toInt(step.count, 1));
        total += duration * count;
      }
    }

    const current = queue[stepIndex];
    if (isPoseStep(current)) {
      const duration = toPositiveInt(current.duration, 0);
      const count = Math.max(1, toInt(current.count, 1));
      const posesRemaining = Math.max(0, count - poseInStep);
      total += posesRemaining * duration;
    }

    return total;
  }

  function getStepTotalSeconds(step) {
    if (!step || typeof step !== "object") return 0;
    const duration = toPositiveInt(step.duration, 0);
    if (step.type === "pause") return duration;
    const count = Math.max(1, toInt(step.count, 1));
    return duration * count;
  }

  function calculateQueueTotalSeconds(queue) {
    if (!Array.isArray(queue) || queue.length === 0) return 0;
    return queue.reduce((total, step) => total + getStepTotalSeconds(step), 0);
  }

  function stepDurationToHms(duration) {
    const safe = Math.max(0, toInt(duration, 0));
    return {
      hours: Math.floor(safe / 3600),
      minutes: Math.floor((safe % 3600) / 60),
      seconds: safe % 60,
    };
  }

  function updateStepDurationFromUnit(step, type, value, minDuration = 1) {
    if (!step || typeof step !== "object") {
      return { updated: false, duration: 0 };
    }
    const safeType = String(type || "").toLowerCase();
    if (safeType !== "h" && safeType !== "m" && safeType !== "s") {
      return { updated: false, duration: toPositiveInt(step.duration, 0) };
    }

    const parts = stepDurationToHms(step.duration);
    const nextValue = Math.max(0, toInt(value, 0));

    if (safeType === "h") parts.hours = nextValue;
    if (safeType === "m") parts.minutes = nextValue;
    if (safeType === "s") parts.seconds = nextValue;

    const rawDuration =
      parts.hours * 3600 + parts.minutes * 60 + parts.seconds;
    const boundedDuration = Math.max(
      Math.max(0, toInt(minDuration, 1)),
      rawDuration,
    );
    step.duration = boundedDuration;
    return {
      updated: true,
      duration: boundedDuration,
      parts: {
        hours: parts.hours,
        minutes: parts.minutes,
        seconds: parts.seconds,
      },
    };
  }

  function updateStepPositiveIntField(step, field, value, minValue = 1) {
    if (!step || typeof step !== "object") {
      return { updated: false, value: 0 };
    }
    const safeField = String(field || "").trim();
    if (!safeField) {
      return { updated: false, value: 0 };
    }

    const min = Math.max(0, toInt(minValue, 1));
    const nextValue = toInt(value, NaN);
    if (!Number.isFinite(nextValue) || nextValue < min) {
      return { updated: false, value: toPositiveInt(step[safeField], 0) };
    }

    step[safeField] = nextValue;
    return {
      updated: true,
      value: nextValue,
      field: safeField,
    };
  }

  function getStepDisplayModel(step) {
    const safeStep = step && typeof step === "object" ? step : {};
    const isPause = safeStep.type === "pause";
    const duration = toPositiveInt(safeStep.duration, 0);
    const count = isPause ? 1 : Math.max(1, toInt(safeStep.count, 1));
    const hms = stepDurationToHms(duration);
    return {
      isPause,
      count,
      duration,
      groupTotalSeconds: duration * count,
      hours: hms.hours,
      minutes: hms.minutes,
      seconds: hms.seconds,
    };
  }

  function createQueueStep(input = {}) {
    const isPause = !!input.isPause;
    const duration = toPositiveInt(input.duration, 0);
    if (duration <= 0) return null;

    const count = isPause ? 1 : Math.max(1, toInt(input.count, 5));
    const idValue = input.id;
    const id =
      idValue !== undefined && idValue !== null
        ? idValue
        : typeof input.now === "function"
          ? input.now()
          : Date.now();

    return {
      type: isPause ? "pause" : "pose",
      count,
      duration,
      id,
    };
  }

  function resolveDropInsertIndex(sourceIndex, targetIndex, isBelow) {
    const sIdx = toInt(sourceIndex, -1);
    const tIdx = toInt(targetIndex, -1);
    if (sIdx < 0 || tIdx < 0) return -1;
    return isBelow ? tIdx + 1 : tIdx;
  }

  function applyQueueDropOperation(
    queue,
    sourceIndex,
    targetIndex,
    isBelow,
    isDuplicate,
    cloneItem,
  ) {
    if (!Array.isArray(queue) || queue.length === 0) {
      return { changed: false, finalIndex: -1 };
    }

    const sIdx = toInt(sourceIndex, -1);
    const tIdx = toInt(targetIndex, -1);
    if (
      sIdx < 0 ||
      tIdx < 0 ||
      sIdx >= queue.length ||
      tIdx >= queue.length
    ) {
      return { changed: false, finalIndex: -1 };
    }

    let finalIndex = resolveDropInsertIndex(sIdx, tIdx, !!isBelow);
    if (finalIndex < 0) return { changed: false, finalIndex: -1 };

    if (sIdx < finalIndex) {
      finalIndex -= 1;
    }

    if (isDuplicate) {
      const sourceItem = queue[sIdx];
      if (!sourceItem || typeof sourceItem !== "object") {
        return { changed: false, finalIndex };
      }
      const duplicate =
        typeof cloneItem === "function"
          ? cloneItem(sourceItem)
          : { ...sourceItem };
      queue.splice(finalIndex, 0, duplicate);
      return { changed: true, finalIndex, duplicate: true };
    }

    if (sIdx === finalIndex) {
      return { changed: false, finalIndex };
    }

    const moved = queue.splice(sIdx, 1)[0];
    queue.splice(finalIndex, 0, moved);
    return { changed: true, finalIndex, duplicate: false };
  }

  function createCustomSessionUtils() {
    return {
      findNextPoseStepIndex,
      findPrevPoseStepIndex,
      findNextPoseStep,
      hasNextPoseGroup,
      hasPrevPoseGroup,
      getCustomPoseSessionProgress,
      calculateCustomTotalRemainingSeconds,
      getStepTotalSeconds,
      calculateQueueTotalSeconds,
      stepDurationToHms,
      updateStepDurationFromUnit,
      updateStepPositiveIntField,
      getStepDisplayModel,
      createQueueStep,
      resolveDropInsertIndex,
      applyQueueDropOperation,
    };
  }

  sharedRoot.createCustomSessionUtils = createCustomSessionUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-flow-utils.js ===== */
(function initPoseChronoSharedSessionFlowUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function toPositiveInt(value, fallback = 0) {
    return Math.max(0, toInt(value, fallback));
  }

  function resolveClassicDuration(
    hours,
    minutes,
    seconds,
    activeButtonDuration,
    fallbackSelectedDuration,
  ) {
    const h = Math.max(0, toInt(hours, 0));
    const m = Math.max(0, toInt(minutes, 0));
    const s = Math.max(0, toInt(seconds, 0));
    const manualTotal = h * 3600 + m * 60 + s;
    if (manualTotal > 0) return manualTotal;
    const fromButton = toPositiveInt(activeButtonDuration, 0);
    if (fromButton > 0) return fromButton;
    return toPositiveInt(fallbackSelectedDuration, 60);
  }

  function resolveSessionStartState(input = {}) {
    const mode = String(input.sessionMode || "classique").toLowerCase();
    const selectedDuration = toPositiveInt(input.selectedDuration, 60);
    const queue = Array.isArray(input.customQueue) ? input.customQueue : [];
    const memoryType = String(input.memoryType || "flash").toLowerCase();
    const imagesLength = Math.max(1, toInt(input.imagesLength, 1));
    const memoryPosesCountRaw = toInt(input.memoryPosesCount, 1);
    const clampMemoryPosesCount =
      typeof input.clampMemoryPosesCount === "function"
        ? input.clampMemoryPosesCount
        : (count, len, fallback = 1) =>
            Math.max(1, Math.min(toInt(count, fallback), Math.max(1, len)));

    const out = {
      isValid: true,
      selectedDuration,
      timeRemaining: selectedDuration,
      currentStepIndex: 0,
      currentPoseInStep: 1,
      memoryPosesCount: clampMemoryPosesCount(memoryPosesCountRaw, imagesLength, 1),
      memoryHidden: false,
    };

    if (mode === "custom") {
      if (queue.length === 0) {
        out.isValid = false;
        return out;
      }
      const firstStep = queue[0] || {};
      const firstDuration = toPositiveInt(firstStep.duration, selectedDuration);
      out.currentStepIndex = 0;
      out.currentPoseInStep = 1;
      out.selectedDuration = firstDuration;
      out.timeRemaining = firstDuration;
      return out;
    }

    if (mode === "memory") {
      if (memoryType === "flash") {
        const duration = toPositiveInt(input.memoryDuration, selectedDuration);
        out.selectedDuration = duration;
        out.timeRemaining = duration;
      } else {
        out.timeRemaining = selectedDuration;
      }
      return out;
    }

    if (mode === "relax") {
      out.timeRemaining = 0;
      return out;
    }

    out.timeRemaining = selectedDuration;
    return out;
  }

  function advanceCustomCursor(queue, currentStepIndex, currentPoseInStep) {
    const safeQueue = Array.isArray(queue) ? queue : [];
    let stepIndex = toInt(currentStepIndex, 0);
    let poseInStep = Math.max(1, toInt(currentPoseInStep, 1));

    const current = safeQueue[stepIndex];
    if (!current || typeof current !== "object") {
      return {
        finished: true,
        currentStepIndex: stepIndex,
        currentPoseInStep: poseInStep,
        nextStep: null,
        enteredNewStep: false,
        soundCue: null,
      };
    }

    const count = Math.max(1, toInt(current.count, 1));
    let enteredNewStep = false;
    if (poseInStep < count) {
      poseInStep += 1;
    } else {
      stepIndex += 1;
      poseInStep = 1;
      enteredNewStep = true;
    }

    if (stepIndex >= safeQueue.length) {
      return {
        finished: true,
        currentStepIndex: stepIndex,
        currentPoseInStep: poseInStep,
        nextStep: null,
        enteredNewStep,
        soundCue: null,
      };
    }

    const nextStep = safeQueue[stepIndex];
    const soundCue = enteredNewStep
      ? nextStep?.type === "pause"
        ? "pause"
        : "group"
      : null;

    return {
      finished: false,
      currentStepIndex: stepIndex,
      currentPoseInStep: poseInStep,
      nextStep,
      enteredNewStep,
      soundCue,
    };
  }

  function shouldEndMemorySession(currentIndex, memoryPosesCount) {
    const idx = Math.max(0, toInt(currentIndex, 0));
    const limit = Math.max(1, toInt(memoryPosesCount, 1));
    return idx + 1 >= limit;
  }

  function nextCyclicIndex(index, length) {
    const total = Math.max(1, toInt(length, 1));
    const current = Math.max(0, toInt(index, 0));
    return (current + 1) % total;
  }

  function createSessionFlowUtils() {
    return {
      resolveClassicDuration,
      resolveSessionStartState,
      advanceCustomCursor,
      shouldEndMemorySession,
      nextCyclicIndex,
    };
  }

  sharedRoot.createSessionFlowUtils = createSessionFlowUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timer-tick-utils.js ===== */
(function initPoseChronoSharedTimerTickUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function isCustomPauseStep(sessionMode, customQueue, currentStepIndex) {
    if (String(sessionMode) !== "custom") return false;
    const queue = Array.isArray(customQueue) ? customQueue : [];
    const index = Math.max(0, Math.round(toNumber(currentStepIndex, 0)));
    return queue[index]?.type === "pause";
  }

  function shouldEnterMemoryHiddenPhase(state) {
    return (
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash" &&
      toNumber(state?.timeRemaining, 0) < 0 &&
      !state?.memoryHidden
    );
  }

  function shouldAdvanceFromMemoryHiddenPhase(state) {
    return (
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash" &&
      !!state?.memoryHidden &&
      toNumber(state?.timeRemaining, 0) < 0
    );
  }

  function getTickSoundDecision(state) {
    if (!state?.soundEnabled) {
      return { playTick: false, volume: 0 };
    }
    const timeRemaining = toNumber(state.timeRemaining, 0);
    const selectedDuration = Math.max(0, toNumber(state.selectedDuration, 0));
    const isCustomPause = !!state.isCustomPause;
    const threshold = selectedDuration * 0.2;
    if (
      !isCustomPause &&
      threshold > 0 &&
      timeRemaining <= threshold &&
      timeRemaining > 0
    ) {
      return {
        playTick: true,
        volume: (threshold - timeRemaining) / threshold,
      };
    }
    return { playTick: false, volume: 0 };
  }

  function shouldPlayEndSound(state) {
    if (!state?.soundEnabled) return false;
    const isMemoryFlash =
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash";
    return toNumber(state?.timeRemaining, 0) === 0 && !isMemoryFlash;
  }

  function shouldAutoAdvanceOnTimerEnd(state) {
    const isMemoryFlash =
      String(state?.sessionMode) === "memory" &&
      String(state?.memoryType) === "flash";
    return toNumber(state?.timeRemaining, 0) <= 0 && !isMemoryFlash;
  }

  function createTimerTickUtils() {
    return {
      isCustomPauseStep,
      shouldEnterMemoryHiddenPhase,
      shouldAdvanceFromMemoryHiddenPhase,
      getTickSoundDecision,
      shouldPlayEndSound,
      shouldAutoAdvanceOnTimerEnd,
    };
  }

  sharedRoot.createTimerTickUtils = createTimerTickUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-session-utils.js ===== */
(function initPoseChronoSharedReviewSessionUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return Math.round(num);
  }

  function sanitizeCustomQueue(queue) {
    if (!Array.isArray(queue)) return null;
    return queue
      .filter((step) => step && typeof step === "object")
      .map((step) => ({
        type: step.type,
        count: toInt(step.count, 0),
        duration: toInt(step.duration, 0),
      }));
  }

  function mapSessionImages(images) {
    if (!Array.isArray(images)) return [];
    return images
      .filter((img) => img && typeof img === "object")
      .map((img) => ({
        id: img.id,
        filePath: img.filePath,
        path: img.path || img.filePath,
        file: img.file || img.filePath,
        ext: img.ext,
        thumbnailURL: img.thumbnailURL || img.thumbnail || "",
        thumbnail: img.thumbnail || img.thumbnailURL || "",
        url: img.url,
        name: img.name,
      }));
  }

  function buildSessionDetails(input = {}) {
    const mode = String(input.sessionMode || "classique");
    const images = mapSessionImages(input.imagesSeen);
    return {
      mode,
      memoryType: mode === "memory" ? input.memoryType || null : null,
      customQueue: mode === "custom" ? sanitizeCustomQueue(input.customQueue) : null,
      images,
    };
  }

  function computeReviewSummary(imagesSeen, totalSessionTime) {
    const poses = Array.isArray(imagesSeen) ? imagesSeen.length : 0;
    const sessionTime = Math.max(0, toInt(totalSessionTime, 0));
    const mins = Math.floor(sessionTime / 60);
    const secs = sessionTime % 60;
    return {
      sessionPoses: poses,
      sessionTime,
      mins,
      secs,
      shouldRecord: poses > 0 && sessionTime > 0,
    };
  }

  function createReviewSessionUtils() {
    return {
      sanitizeCustomQueue,
      mapSessionImages,
      buildSessionDetails,
      computeReviewSummary,
    };
  }

  sharedRoot.createReviewSessionUtils = createReviewSessionUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-grid-utils.js ===== */
(function initPoseChronoSharedReviewGridUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function defaultIsVideoFile() {
    return false;
  }

  function defaultGetDurationSeconds() {
    return 0;
  }

  function defaultIsAnnotated() {
    return false;
  }

  function defaultFormatDuration(seconds) {
    const safe = Math.max(0, Math.floor(Number(seconds) || 0));
    const m = Math.floor(safe / 60);
    const s = safe % 60;
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function buildReviewGridItems(imagesSeen, options = {}) {
    const images = Array.isArray(imagesSeen) ? imagesSeen : [];
    const isVideoFile =
      typeof options.isVideoFile === "function"
        ? options.isVideoFile
        : defaultIsVideoFile;
    const getDurationSeconds =
      typeof options.getDurationSeconds === "function"
        ? options.getDurationSeconds
        : defaultGetDurationSeconds;
    const isAnnotated =
      typeof options.isAnnotated === "function"
        ? options.isAnnotated
        : defaultIsAnnotated;
    const formatDuration =
      typeof options.formatDuration === "function"
        ? options.formatDuration
        : defaultFormatDuration;
    const includeDurations = options.includeDurations !== false;

    return images.map((image, index) => {
      const isVideo = !!isVideoFile(image);
      const thumbnailSrc = image?.thumbnailURL || image?.thumbnail || "";
      const fallbackSrc = image?.filePath ? `file:///${image.filePath}` : "";
      const durationSeconds = includeDurations ? getDurationSeconds(image) : 0;
      const durationText = includeDurations
        ? formatDuration(durationSeconds)
        : null;
      const annotated = !!isAnnotated(image);
      const hasMetaBadge = !!durationText || annotated;

      return {
        index,
        image,
        isVideo,
        src: thumbnailSrc || fallbackSrc,
        durationText,
        annotated,
        hasMetaBadge,
      };
    });
  }

  function createReviewGridUtils() {
    return {
      buildReviewGridItems,
    };
  }

  sharedRoot.createReviewGridUtils = createReviewGridUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/review-interactions-utils.js ===== */
(function initPoseChronoSharedReviewInteractionsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function getDurationToggleCopy(isVisible) {
    return isVisible
      ? {
          i18nKey: "drawing.hideDurations",
          defaultValue: "Hide durations",
        }
      : {
          i18nKey: "drawing.showDurations",
          defaultValue: "Show durations",
        };
  }

  function getDurationToggleTransition(isVisible) {
    if (isVisible) {
      return {
        nextVisible: false,
        animateHide: true,
        renderBeforeShow: false,
        animateShow: false,
      };
    }
    return {
      nextVisible: true,
      animateHide: false,
      renderBeforeShow: true,
      animateShow: true,
    };
  }

  function normalizeReviewIndex(index, length) {
    const total = Math.max(0, Math.floor(Number(length) || 0));
    if (total === 0) return 0;
    const idx = Math.floor(Number(index) || 0);
    return Math.max(0, Math.min(idx, total - 1));
  }

  function createReviewInteractionsUtils() {
    return {
      getDurationToggleCopy,
      getDurationToggleTransition,
      normalizeReviewIndex,
    };
  }

  sharedRoot.createReviewInteractionsUtils = createReviewInteractionsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/screen-context-menu-bindings-utils.js ===== */
(function initPoseChronoSharedScreenContextMenuBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindScreenBackgroundContextMenu(input = {}) {
    const screenElement = input.screenElement;
    const containerSelector = input.containerSelector;
    const onOpenMenu =
      typeof input.onOpenMenu === "function" ? input.onOpenMenu : null;

    if (
      !screenElement ||
      typeof screenElement.addEventListener !== "function" ||
      !containerSelector ||
      !onOpenMenu
    ) {
      return false;
    }

    screenElement.addEventListener("contextmenu", (event) => {
      const target = event.target;
      const isInsideContainer =
        target && typeof target.closest === "function"
          ? target.closest(containerSelector)
          : null;
      if (isInsideContainer) return;
      event.preventDefault();
      onOpenMenu(event.clientX, event.clientY, event);
    });
    return true;
  }

  function bindMultipleScreenBackgroundContextMenus(input = {}) {
    const bindings = Array.isArray(input.bindings) ? input.bindings : [];
    let boundCount = 0;
    bindings.forEach((binding) => {
      if (bindScreenBackgroundContextMenu(binding)) {
        boundCount += 1;
      }
    });
    return boundCount;
  }

  function createScreenContextMenuBindingsUtils() {
    return {
      bindScreenBackgroundContextMenu,
      bindMultipleScreenBackgroundContextMenus,
    };
  }

  sharedRoot.createScreenContextMenuBindingsUtils =
    createScreenContextMenuBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-replay-utils.js ===== */
(function initPoseChronoSharedSessionReplayUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const VALID_MODES = new Set(["classique", "custom", "relax", "memory"]);
  const VALID_MEMORY_TYPES = new Set(["flash", "progressive"]);

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function normalizeMode(mode, fallback = "classique") {
    const normalized = String(mode || "").trim().toLowerCase();
    if (VALID_MODES.has(normalized)) return normalized;
    const fb = String(fallback || "classique").trim().toLowerCase();
    return VALID_MODES.has(fb) ? fb : "classique";
  }

  function normalizeMemoryType(memoryType, mode = "classique") {
    if (normalizeMode(mode) !== "memory") return null;
    const normalized = String(memoryType || "").trim().toLowerCase();
    if (VALID_MEMORY_TYPES.has(normalized)) return normalized;
    return "flash";
  }

  function sanitizeCustomQueue(customQueue) {
    if (!Array.isArray(customQueue)) return [];
    return customQueue
      .filter((step) => step && typeof step === "object")
      .map((step) => ({
        type: step.type === "pause" ? "pause" : "pose",
        count: Math.max(1, Math.round(toNumber(step.count, 1))),
        duration: Math.max(1, Math.round(toNumber(step.duration, 60))),
      }));
  }

  function extractImageIdsFromSession(session) {
    const images = Array.isArray(session?.images) ? session.images : [];
    const out = [];
    const seen = new Set();
    images.forEach((img) => {
      const id = typeof img === "object" && img !== null ? img.id : null;
      if (id === undefined || id === null) return;
      const key = String(id);
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(id);
    });
    return out;
  }

  function computeReplayDuration(session) {
    const poses = Math.max(0, toNumber(session?.poses, 0));
    const time = Math.max(0, toNumber(session?.time, 0));
    if (poses <= 0 || time <= 0) return null;
    return time / poses;
  }

  function buildReplayOptionsFromSession(session) {
    const mode = normalizeMode(session?.mode);
    const duration = computeReplayDuration(session);
    const customQueue = mode === "custom" ? sanitizeCustomQueue(session?.customQueue) : [];
    const memoryType = normalizeMemoryType(session?.memoryType, mode);
    return {
      mode,
      duration,
      customQueue,
      memoryType,
    };
  }

  function normalizeLoadSessionOptions(options) {
    const mode = normalizeMode(options?.mode);
    const durationRaw = toNumber(options?.duration, 0);
    const duration = durationRaw > 0 ? Math.round(durationRaw) : null;
    const customQueue = mode === "custom" ? sanitizeCustomQueue(options?.customQueue) : [];
    const memoryType = normalizeMemoryType(options?.memoryType, mode);
    return {
      mode,
      duration,
      customQueue,
      memoryType,
    };
  }

  function createSessionReplayUtils() {
    return {
      normalizeMode,
      normalizeMemoryType,
      sanitizeCustomQueue,
      extractImageIdsFromSession,
      computeReplayDuration,
      buildReplayOptionsFromSession,
      normalizeLoadSessionOptions,
    };
  }

  sharedRoot.createSessionReplayUtils = createSessionReplayUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-media-utils.js ===== */
(function initPoseChronoSharedSessionMediaUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function normalizeExt(ext) {
    return String(ext || "").trim().toLowerCase();
  }

  function toExtSet(extensions) {
    const set = new Set();
    if (!Array.isArray(extensions)) return set;
    extensions.forEach((ext) => {
      const key = normalizeExt(ext);
      if (key) set.add(key);
    });
    return set;
  }

  function filterByExtensions(items, extensions) {
    const source = Array.isArray(items) ? items : [];
    const extSet = toExtSet(extensions);
    if (extSet.size === 0) return [];
    return source.filter((item) => {
      if (!item || typeof item !== "object") return false;
      return extSet.has(normalizeExt(item.ext));
    });
  }

  function shuffleArray(items, randomFn = Math.random) {
    const arr = Array.isArray(items) ? [...items] : [];
    for (let i = arr.length - 1; i > 0; i--) {
      const r = Number(randomFn());
      const ratio = Number.isFinite(r) ? Math.max(0, Math.min(1, r)) : 0;
      const j = Math.floor(ratio * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function countByExtensions(items, imageExtensions, videoExtensions) {
    const source = Array.isArray(items) ? items : [];
    const imageSet = toExtSet(imageExtensions);
    const videoSet = toExtSet(videoExtensions);
    let imageCount = 0;
    let videoCount = 0;

    source.forEach((item) => {
      const ext = normalizeExt(item?.ext);
      if (!ext) return;
      if (imageSet.has(ext)) {
        imageCount += 1;
        return;
      }
      if (videoSet.has(ext)) {
        videoCount += 1;
      }
    });

    return {
      imageCount,
      videoCount,
      totalCount: imageCount + videoCount,
    };
  }

  function isVideoFile(item, videoExtensions) {
    if (!item || typeof item !== "object") return false;
    const ext = normalizeExt(item.ext);
    if (!ext) return false;
    const videoSet = toExtSet(videoExtensions);
    return videoSet.has(ext);
  }

  function isGifFile(item) {
    if (!item || typeof item !== "object") return false;
    return normalizeExt(item.ext) === "gif";
  }

  async function resolveMediaSelection(operations = {}) {
    const getSelectedItems =
      typeof operations.getSelectedItems === "function"
        ? operations.getSelectedItems
        : async () => [];
    const getSelectedFolders =
      typeof operations.getSelectedFolders === "function"
        ? operations.getSelectedFolders
        : async () => [];
    const queryItems =
      typeof operations.queryItems === "function"
        ? operations.queryItems
        : async () => [];
    const toFolderIds =
      typeof operations.toFolderIds === "function"
        ? operations.toFolderIds
        : (folders) =>
            (Array.isArray(folders) ? folders : [])
              .map((folder) => folder?.id)
              .filter((id) => id !== undefined && id !== null && id !== "");

    const selectedItems = await getSelectedItems();
    if (Array.isArray(selectedItems) && selectedItems.length > 0) {
      return { items: selectedItems, source: "selected-items" };
    }

    const selectedFolders = await getSelectedFolders();
    const folderIds = toFolderIds(selectedFolders);
    if (folderIds.length > 0) {
      const folderItems = await queryItems({ folders: folderIds });
      if (Array.isArray(folderItems) && folderItems.length > 0) {
        return { items: folderItems, source: "selected-folders" };
      }
    }

    const allItems = await queryItems({});
    return {
      items: Array.isArray(allItems) ? allItems : [],
      source: "all-items",
    };
  }

  function formatLoadedMediaCount(mediaCounts, translate, options = {}) {
    const counts = mediaCounts && typeof mediaCounts === "object" ? mediaCounts : {};
    const imageCount = Number.isFinite(Number(counts.imageCount))
      ? Number(counts.imageCount)
      : 0;
    const videoCount = Number.isFinite(Number(counts.videoCount))
      ? Number(counts.videoCount)
      : 0;
    const t =
      typeof translate === "function" ? translate : (key, fallback) => fallback || key;

    const imageSingularKey = options.imageSingularKey || "settings.imageLoaded";
    const imagePluralKey = options.imagePluralKey || "settings.imagesLoaded";
    const videoSingularKey = options.videoSingularKey || "settings.videoLoaded";
    const videoPluralKey = options.videoPluralKey || "settings.videosLoaded";
    const andKey = options.andKey || "misc.and";

    const parts = [];
    if (imageCount > 0) {
      parts.push(
        `${imageCount} ${t(
          imageCount === 1 ? imageSingularKey : imagePluralKey,
          imageCount === 1 ? "image loaded" : "images loaded",
        )}`,
      );
    }
    if (videoCount > 0) {
      parts.push(
        `${videoCount} ${t(
          videoCount === 1 ? videoSingularKey : videoPluralKey,
          videoCount === 1 ? "video loaded" : "videos loaded",
        )}`,
      );
    }

    if (parts.length === 0) return "";
    if (parts.length === 1) return parts[0];
    return `${parts[0]} ${t(andKey, "and")} ${parts[1]}`;
  }

  function createSessionMediaUtils() {
    return {
      normalizeExt,
      filterByExtensions,
      shuffleArray,
      countByExtensions,
      isVideoFile,
      isGifFile,
      resolveMediaSelection,
      formatLoadedMediaCount,
    };
  }

  sharedRoot.createSessionMediaUtils = createSessionMediaUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-mode-ui-utils.js ===== */
(function initPoseChronoSharedSessionModeUiUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  const MODE_CLASSIQUE = "classique";
  const MODE_CUSTOM = "custom";
  const MODE_RELAX = "relax";
  const MODE_MEMORY = "memory";
  const VALID_MODES = new Set([
    MODE_CLASSIQUE,
    MODE_CUSTOM,
    MODE_RELAX,
    MODE_MEMORY,
  ]);
  const MODE_DESCRIPTION_KEY_BY_MODE = Object.freeze({
    [MODE_CLASSIQUE]: "modes.classic.description",
    [MODE_CUSTOM]: "modes.custom.description",
    [MODE_RELAX]: "modes.relax.description",
    [MODE_MEMORY]: "modes.memory.description",
  });

  function normalizeMode(mode, fallback = MODE_CLASSIQUE) {
    const normalized = String(mode ?? "")
      .trim()
      .toLowerCase();
    if (VALID_MODES.has(normalized)) return normalized;

    const fallbackNormalized = String(fallback ?? MODE_CLASSIQUE)
      .trim()
      .toLowerCase();
    return VALID_MODES.has(fallbackNormalized) ? fallbackNormalized : MODE_CLASSIQUE;
  }

  function resolveIncomingPanelKey(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    if (
      normalizedMode === MODE_CLASSIQUE ||
      normalizedMode === MODE_CUSTOM ||
      normalizedMode === MODE_MEMORY
    ) {
      return normalizedMode;
    }
    return null;
  }

  function resolveOutgoingPanelKey(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    if (
      previousMode === MODE_CLASSIQUE ||
      previousMode === MODE_CUSTOM ||
      previousMode === MODE_MEMORY
    ) {
      return previousMode;
    }
    return null;
  }

  function shouldHideAllPanelsFirst(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    return previousMode === "" || previousMode === MODE_RELAX;
  }

  function resolveRelaxFrozenPanelKey(previousModeRaw) {
    const previousMode = String(previousModeRaw ?? "")
      .trim()
      .toLowerCase();
    if (previousMode === MODE_MEMORY) return MODE_MEMORY;
    if (previousMode === MODE_CUSTOM) return MODE_CUSTOM;
    return MODE_CLASSIQUE;
  }

  function resolveMemoryDurationTarget(input = {}) {
    const memoryType = String(input.memoryType || "flash")
      .trim()
      .toLowerCase();
    const targetType = memoryType === "progressive" ? "progressive" : "flash";
    const duration =
      targetType === "flash"
        ? Math.max(0, Number(input.memoryDuration) || 0)
        : Math.max(0, Number(input.selectedDuration) || 0);

    return {
      memoryType: targetType,
      duration,
    };
  }

  function shouldDisableProgressiveBlurForMode(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    return normalizedMode === MODE_MEMORY || normalizedMode === MODE_RELAX;
  }

  function resolveStartButtonDisabled(input = {}) {
    const mode = normalizeMode(input.sessionMode, MODE_CLASSIQUE);
    if (mode === MODE_CUSTOM) {
      const customQueueLength = Math.max(0, Number(input.customQueueLength) || 0);
      return customQueueLength === 0;
    }
    if (mode === MODE_RELAX) return false;
    return (Number(input.selectedDuration) || 0) <= 0;
  }

  function resolveStartButtonUiState(input = {}) {
    const disabled = resolveStartButtonDisabled(input);
    return {
      disabled,
      opacity: disabled ? "0.5" : "1",
    };
  }

  function resolveHomeProgressiveBlurState(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    const isRelax = normalizedMode === MODE_RELAX;
    return {
      disabled: isRelax,
      opacity: isRelax ? "0.5" : "1",
      classDisabled: isRelax,
    };
  }

  function resolveProgressiveBlurControlState(input = {}) {
    const disabled = !!input.disabled;
    const keepActive = !!input.keepActive;
    return {
      disabled,
      opacity: disabled ? "0.3" : "1",
      pointerEvents: disabled ? "none" : "all",
      shouldClearActive: disabled && !keepActive,
    };
  }

  function resolveModeTransition(mode, previousModeRaw) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    const isRelax = normalizedMode === MODE_RELAX;
    return {
      mode: normalizedMode,
      isRelax,
      incomingPanelKey: isRelax ? null : resolveIncomingPanelKey(normalizedMode),
      outgoingPanelKey: resolveOutgoingPanelKey(previousModeRaw),
      hideAllPanelsFirst: !isRelax && shouldHideAllPanelsFirst(previousModeRaw),
      relaxFrozenPanelKey: isRelax
        ? resolveRelaxFrozenPanelKey(previousModeRaw)
        : null,
      disableProgressiveBlur: shouldDisableProgressiveBlurForMode(normalizedMode),
    };
  }

  function getModeDescriptionI18nKey(mode) {
    const normalizedMode = normalizeMode(mode, MODE_CLASSIQUE);
    return (
      MODE_DESCRIPTION_KEY_BY_MODE[normalizedMode] ||
      MODE_DESCRIPTION_KEY_BY_MODE[MODE_CLASSIQUE]
    );
  }

  function resolveModeDescription(mode, translate, options = {}) {
    const t =
      typeof translate === "function" ? translate : (key, fallback) => fallback || key;
    const key = getModeDescriptionI18nKey(mode);
    const translated = t(key, "");

    if (translated && translated !== key) {
      return translated;
    }

    const fallbackKey = String(
      options.fallbackKey || "settings.sessionDescription",
    );
    const fallbackText = String(
      options.fallbackText || "Choose a session type",
    );
    return t(fallbackKey, fallbackText);
  }

  function createSessionModeUiUtils() {
    return {
      normalizeMode,
      resolveIncomingPanelKey,
      resolveOutgoingPanelKey,
      shouldHideAllPanelsFirst,
      resolveRelaxFrozenPanelKey,
      resolveMemoryDurationTarget,
      shouldDisableProgressiveBlurForMode,
      resolveStartButtonDisabled,
      resolveStartButtonUiState,
      resolveHomeProgressiveBlurState,
      resolveProgressiveBlurControlState,
      resolveModeTransition,
      getModeDescriptionI18nKey,
      resolveModeDescription,
    };
  }

  sharedRoot.createSessionModeUiUtils = createSessionModeUiUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/sidebar-tooltips-utils.js ===== */
(function initPoseChronoSharedSidebarTooltipsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function safeSetTooltip(element, value) {
    if (!element || typeof element.setAttribute !== "function") return;
    element.setAttribute("data-tooltip", String(value || ""));
  }

  function updateSidebarTooltips(input = {}) {
    const buttons = input.buttons || {};
    const hotkeys = input.hotkeys || {};
    const t =
      typeof input.translate === "function"
        ? input.translate
        : (key, options = {}) => {
            if (options && typeof options.defaultValue === "string") {
              return options.defaultValue;
            }
            return key;
          };

    safeSetTooltip(
      buttons.flipHorizontalBtn,
      `${t("drawing.flipHorizontal")} (${hotkeys.FLIP_H || ""})`,
    );
    safeSetTooltip(buttons.flipVerticalBtn, t("drawing.flipVertical"));
    safeSetTooltip(
      buttons.grayscaleBtn,
      `${t("filters.grayscale")} (${String(hotkeys.GRAYSCALE || "").toUpperCase()})`,
    );
    safeSetTooltip(
      buttons.blurBtn,
      t("filters.blurTooltip", {
        hotkey: String(hotkeys.BLUR || "").toUpperCase(),
      }),
    );
    safeSetTooltip(buttons.progressiveBlurBtn, t("filters.progressiveBlur"));
  }

  function createSidebarTooltipsUtils() {
    return {
      updateSidebarTooltips,
    };
  }

  sharedRoot.createSidebarTooltipsUtils = createSidebarTooltipsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/keyboard-listener-bindings-utils.js ===== */
(function initPoseChronoSharedKeyboardListenerBindingsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function bindCoreKeyboardShortcuts(input = {}) {
    const documentRef = input.documentRef;
    if (!documentRef || typeof documentRef.addEventListener !== "function") {
      return false;
    }

    if (typeof input.onMainKeydown === "function") {
      documentRef.addEventListener("keydown", input.onMainKeydown);
    }
    if (typeof input.onSettingsKeydown === "function") {
      documentRef.addEventListener("keydown", input.onSettingsKeydown);
    }
    if (typeof input.onFrameSteppingKeyup === "function") {
      documentRef.addEventListener("keyup", input.onFrameSteppingKeyup);
    }
    if (typeof input.onThemeKeydown === "function") {
      documentRef.addEventListener("keydown", input.onThemeKeydown);
    }
    if (typeof input.onPinKeydown === "function") {
      documentRef.addEventListener("keydown", input.onPinKeydown);
    }
    if (typeof input.onGlobalSettingsKeydown === "function") {
      documentRef.addEventListener("keydown", input.onGlobalSettingsKeydown);
    }

    return true;
  }

  function createKeyboardListenerBindingsUtils() {
    return {
      bindCoreKeyboardShortcuts,
    };
  }

  sharedRoot.createKeyboardListenerBindingsUtils =
    createKeyboardListenerBindingsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/global-keyboard-shortcuts-utils.js ===== */
(function initPoseChronoSharedGlobalKeyboardShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || !!target.isContentEditable;
  }

  function shouldStopFrameSteppingOnKeyup(input = {}) {
    const event = input.event;
    const hotkeys = input.hotkeys || {};
    if (!event) return false;
    const key = event.key;
    return (
      key === "'" ||
      key === "PageDown" ||
      key === hotkeys.VIDEO_PREV_FRAME ||
      key === "(" ||
      key === "PageUp" ||
      key === hotkeys.VIDEO_NEXT_FRAME
    );
  }

  function handleThemeShortcut(input = {}) {
    const event = input.event;
    const themeHotkey = input.themeHotkey;
    const onToggleTheme =
      typeof input.onToggleTheme === "function" ? input.onToggleTheme : null;
    if (!event || !themeHotkey || !onToggleTheme) return false;
    if (event.key !== themeHotkey) return false;
    event.preventDefault();
    onToggleTheme();
    return true;
  }

  function isPinShortcutEvent(event) {
    return !!event && event.shiftKey && event.code === "KeyT";
  }

  async function handlePinShortcut(input = {}) {
    const event = input.event;
    const onToggleAlwaysOnTop =
      typeof input.onToggleAlwaysOnTop === "function"
        ? input.onToggleAlwaysOnTop
        : null;
    const onApplyState =
      typeof input.onApplyState === "function" ? input.onApplyState : null;

    if (!isPinShortcutEvent(event) || !onToggleAlwaysOnTop) return false;

    event.preventDefault();
    const isOnTop = await onToggleAlwaysOnTop();
    if (onApplyState) {
      onApplyState(!!isOnTop);
    }
    return true;
  }

  function handleGlobalSettingsShortcut(input = {}) {
    const event = input.event;
    const onOpenGlobalSettings =
      typeof input.onOpenGlobalSettings === "function"
        ? input.onOpenGlobalSettings
        : null;
    if (!event || !onOpenGlobalSettings) return false;

    const isModifier = event.ctrlKey || event.metaKey;
    const isGlobalSettingsKey =
      isModifier &&
      !event.shiftKey &&
      !event.altKey &&
      String(event.key || "").toLowerCase() === "k";
    if (!isGlobalSettingsKey || isTypingTarget(event.target)) return false;

    event.preventDefault();
    onOpenGlobalSettings();
    return true;
  }

  function createGlobalKeyboardShortcutsUtils() {
    return {
      shouldStopFrameSteppingOnKeyup,
      handleThemeShortcut,
      isPinShortcutEvent,
      handlePinShortcut,
      handleGlobalSettingsShortcut,
    };
  }

  sharedRoot.createGlobalKeyboardShortcutsUtils = createGlobalKeyboardShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/main-keyboard-shortcuts-utils.js ===== */
(function initPoseChronoSharedMainKeyboardShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA";
  }

  function callIfFn(fn, ...args) {
    if (typeof fn === "function") {
      return fn(...args);
    }
    return undefined;
  }

  function handleMainKeyboardShortcuts(input = {}) {
    const e = input.event;
    if (!e) return false;

    const drawingScreen = input.drawingScreen;
    if (!drawingScreen || drawingScreen.classList.contains("hidden")) return true;
    if (isTypingTarget(e.target)) return true;
    if (input.isDrawingModeActive) return true;

    const doc = input.documentRef || (typeof document !== "undefined" ? document : null);
    const win = input.windowRef || (typeof window !== "undefined" ? window : null);
    const state = input.state || {};
    const blurBtn = input.blurBtn || null;
    const config = input.config || {};
    const hk = config.HOTKEYS || {};

    if (!doc) return true;

    const key = e.key;
    const keyLow = String(key || "").toLowerCase();

    const tagsModal = doc.getElementById("tags-modal");
    const sessionPlansModal = doc.getElementById("session-plans-modal");
    const globalSettingsModal = doc.getElementById("global-settings-modal");

    const isAnyModalOpen =
      (tagsModal && !tagsModal.classList.contains("hidden")) ||
      (sessionPlansModal && !sessionPlansModal.classList.contains("hidden")) ||
      (globalSettingsModal && !globalSettingsModal.classList.contains("hidden"));

    if (isAnyModalOpen && key === "Escape") {
      e.preventDefault();

      if (tagsModal && !tagsModal.classList.contains("hidden")) {
        tagsModal.classList.add("hidden");
        if (state.wasPlayingBeforeModal) {
          callIfFn(input.startTimer);
          state.wasPlayingBeforeModal = false;
        }
        return true;
      }

      if (sessionPlansModal && !sessionPlansModal.classList.contains("hidden")) {
        sessionPlansModal.classList.add("hidden");
        return true;
      }

      if (
        globalSettingsModal &&
        !globalSettingsModal.classList.contains("hidden")
      ) {
        callIfFn(input.closeGlobalSettingsModal);
        return true;
      }

      return true;
    }

    if (isAnyModalOpen) return true;

    if (key === hk.FLIP_H) {
      e.preventDefault();
      callIfFn(input.toggleFlipHorizontal);
      return true;
    }

    if (key === " " && !e.shiftKey) {
      e.preventDefault();
      callIfFn(input.togglePlayPause);
      return true;
    }

    if (e.shiftKey && key === hk.GRID_MODAL) {
      e.preventDefault();
      callIfFn(input.showGridConfig);
      return true;
    }

    if (e.shiftKey && key === hk.SILHOUETTE_MODAL) {
      e.preventDefault();
      callIfFn(input.showSilhouetteConfig);
      return true;
    }

    switch (key) {
      case "Escape": {
        e.preventDefault();
        const gridPopup = doc.getElementById("grid-config-popup");
        const silhouettePopup = doc.getElementById("silhouette-config-popup");
        const imageInfoOverlay = doc.getElementById("image-info-overlay");

        if (gridPopup) {
          gridPopup.remove();
          if (input.wasPlayingBeforeModal && !state.isPlaying) {
            callIfFn(input.togglePlayPause);
          }
        } else if (silhouettePopup) {
          silhouettePopup.remove();
          if (input.wasPlayingBeforeModal && !state.isPlaying) {
            callIfFn(input.togglePlayPause);
          }
        } else if (!imageInfoOverlay) {
          callIfFn(input.showReview);
        }
        break;
      }
      case "Delete":
        e.preventDefault();
        callIfFn(input.deleteImage);
        break;
      case "ArrowUp":
        e.preventDefault();
        if (e.shiftKey) {
          if (state.silhouetteEnabled) {
            state.silhouetteBrightness = Math.min(
              state.silhouetteBrightness + 0.1,
              6,
            );
            callIfFn(input.applyImageFilters);
            const brightnessSlider = doc.getElementById("brightness-slider");
            const brightnessValue = doc.getElementById("brightness-value");
            if (brightnessSlider) {
              brightnessSlider.value = state.silhouetteBrightness;
              callIfFn(input.updateSliderGradient, brightnessSlider);
            }
            if (brightnessValue) {
              brightnessValue.textContent = state.silhouetteBrightness.toFixed(2);
            }
          }
        } else if (state.isBlurEnabled) {
          state.blurAmount = Math.min(state.blurAmount + 2.5, 100);
          callIfFn(input.updateBlurAmount);
          callIfFn(input.applyImageFilters);
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (e.shiftKey) {
          if (state.silhouetteEnabled) {
            state.silhouetteBrightness = Math.max(
              state.silhouetteBrightness - 0.1,
              0,
            );
            callIfFn(input.applyImageFilters);
            const brightnessSlider = doc.getElementById("brightness-slider");
            const brightnessValue = doc.getElementById("brightness-value");
            if (brightnessSlider) {
              brightnessSlider.value = state.silhouetteBrightness;
              callIfFn(input.updateSliderGradient, brightnessSlider);
            }
            if (brightnessValue) {
              brightnessValue.textContent = state.silhouetteBrightness.toFixed(2);
            }
          }
        } else if (state.isBlurEnabled) {
          state.blurAmount = Math.max(state.blurAmount - 2.5, 0);
          callIfFn(input.updateBlurAmount);
          callIfFn(input.applyImageFilters);
        }
        break;
      case "ArrowLeft":
        e.preventDefault();
        callIfFn(input.previousImage);
        break;
      case "ArrowRight":
        e.preventDefault();
        callIfFn(input.nextImage);
        break;
      default:
        break;
    }

    if (
      keyLow === String(hk.GRAYSCALE || "").toLowerCase() ||
      (e.ctrlKey && e.altKey && keyLow === "g")
    ) {
      callIfFn(input.toggleGrayscale);
    } else if (keyLow === String(hk.BLUR || "").toLowerCase()) {
      if (!state.isProgressiveBlur && blurBtn) {
        blurBtn.click();
      }
    } else if (keyLow === String(hk.ANNOTATE || "").toLowerCase()) {
      e.preventDefault();
      callIfFn(input.openDrawingMode);
    } else if (keyLow === String(hk.MUTE || "").toLowerCase()) {
      callIfFn(input.toggleSound);
    } else if (keyLow === String(hk.GRID || "").toLowerCase()) {
      state.gridEnabled = !state.gridEnabled;
      callIfFn(input.updateGridOverlay);
    } else if (keyLow === String(hk.SILHOUETTE || "").toLowerCase()) {
      state.silhouetteEnabled = !state.silhouetteEnabled;
      callIfFn(input.applyImageFilters);
    } else if (keyLow === String(hk.SIDEBAR || "").toLowerCase()) {
      callIfFn(input.toggleSidebar);
    } else if (keyLow === String(hk.INFO || "").toLowerCase()) {
      callIfFn(input.toggleImageInfo);
    } else if (keyLow === String(hk.TAGS || "").toLowerCase()) {
      e.preventDefault();
      if (!callIfFn(input.isTagsFeatureAvailable)) return true;
      if (typeof input.openTagsModal === "function") {
        const zoomOverlay = doc.getElementById("zoom-overlay");
        const zoomImage = win ? win.zoomOverlayCurrentImage || null : null;
        if (zoomOverlay && zoomImage) {
          input.openTagsModal(null, zoomImage);
        } else if (
          zoomOverlay &&
          win &&
          win.currentZoomIndex !== undefined &&
          win.currentZoomIndex !== null
        ) {
          input.openTagsModal(win.currentZoomIndex);
        } else {
          input.openTagsModal();
        }
      }
    }

    if (state.isVideoFile) {
      if (key === hk.VIDEO_SLOWER) {
        e.preventDefault();
        callIfFn(input.changeVideoSpeed, -1);
        return true;
      }
      if (key === hk.VIDEO_FASTER) {
        e.preventDefault();
        callIfFn(input.changeVideoSpeed, 1);
        return true;
      }
      if (key === hk.VIDEO_PREV_FRAME) {
        e.preventDefault();
        callIfFn(input.stepFrame, -1, e.repeat);
        return true;
      }
      if (key === hk.VIDEO_NEXT_FRAME) {
        e.preventDefault();
        callIfFn(input.stepFrame, 1, e.repeat);
        return true;
      }
      if (keyLow === String(hk.VIDEO_LOOP || "").toLowerCase()) {
        e.preventDefault();
        callIfFn(input.toggleVideoLoop);
        return true;
      }
      if (e.shiftKey && key === " ") {
        e.preventDefault();
        callIfFn(input.toggleVideoPlayPause);
        return true;
      }
      if (e.shiftKey && key === hk.VIDEO_CONFIG) {
        e.preventDefault();
        callIfFn(input.showVideoConfig);
        return true;
      }
    }

    return true;
  }

  function createMainKeyboardShortcutsUtils() {
    return {
      handleMainKeyboardShortcuts,
    };
  }

  sharedRoot.createMainKeyboardShortcutsUtils = createMainKeyboardShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/settings-shortcuts-utils.js ===== */
(function initPoseChronoSharedSettingsShortcutsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || !!target.isContentEditable;
  }

  function isPlainSpacePress(event) {
    const isSpace =
      event?.key === " " || event?.key === "Spacebar" || event?.code === "Space";
    if (!isSpace) return false;
    return !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey;
  }

  function handleSettingsScreenKeyboardShortcuts(input = {}) {
    const event = input.event;
    const settingsScreen = input.settingsScreen;
    const startBtn = input.startBtn;
    const getTopOpenModal =
      typeof input.getTopOpenModal === "function" ? input.getTopOpenModal : null;
    const onStart = typeof input.onStart === "function" ? input.onStart : null;

    if (!event || !settingsScreen || settingsScreen.classList.contains("hidden")) {
      return false;
    }

    if (!isPlainSpacePress(event) || isTypingTarget(event.target)) {
      return false;
    }

    if (getTopOpenModal && getTopOpenModal()) return false;
    if (!startBtn || startBtn.disabled) return false;

    event.preventDefault();
    if (onStart) {
      onStart();
    } else if (typeof startBtn.click === "function") {
      startBtn.click();
    }
    return true;
  }

  function createSettingsShortcutsUtils() {
    return {
      handleSettingsScreenKeyboardShortcuts,
    };
  }

  sharedRoot.createSettingsShortcutsUtils = createSettingsShortcutsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-time-format-utils.js ===== */
(function initPoseChronoSharedSessionTimeFormatUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSafeSeconds(value) {
    return Math.max(0, Math.floor(Number(value) || 0));
  }

  function formatCompactDuration(seconds) {
    const safe = toSafeSeconds(seconds);
    if (safe <= 0) return "0s";

    const h = Math.floor(safe / 3600);
    const m = Math.floor((safe % 3600) / 60);
    const s = safe % 60;

    const parts = [];
    if (h > 0) parts.push(`${h}h`);
    if (m > 0) parts.push(`${m}m`);
    if (s > 0 || parts.length === 0) parts.push(`${s}s`);
    return parts.join(" ");
  }

  function formatClockDuration(seconds) {
    const safe = toSafeSeconds(seconds);
    const h = Math.floor(safe / 3600);
    const m = Math.floor((safe % 3600) / 60);
    const s = safe % 60;

    if (h > 0) {
      return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function createSessionTimeFormatUtils() {
    return {
      toSafeSeconds,
      formatCompactDuration,
      formatClockDuration,
    };
  }

  sharedRoot.createSessionTimeFormatUtils = createSessionTimeFormatUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-duration-buttons-utils.js ===== */
(function initPoseChronoSharedSessionDurationButtonsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toDurationSeconds(value, fallback = 0) {
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
  }

  function getButtonDuration(button, fallback = 0) {
    if (!button || !button.dataset) return fallback;
    return toDurationSeconds(button.dataset.duration, fallback);
  }

  function setActiveDurationButtons(buttons, duration) {
    if (!buttons || typeof buttons.forEach !== "function") return;
    buttons.forEach((btn) => {
      if (!btn?.classList) return;
      btn.classList.toggle("active", getButtonDuration(btn) === duration);
    });
  }

  function clearActiveDurationButtons(buttons) {
    if (!buttons || typeof buttons.forEach !== "function") return;
    buttons.forEach((btn) => {
      if (!btn?.classList) return;
      btn.classList.remove("active");
    });
  }

  function createSessionDurationButtonsUtils() {
    return {
      toDurationSeconds,
      getButtonDuration,
      setActiveDurationButtons,
      clearActiveDurationButtons,
    };
  }

  sharedRoot.createSessionDurationButtonsUtils = createSessionDurationButtonsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/session-time-input-utils.js ===== */
(function initPoseChronoSharedSessionTimeInputUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
  }

  function clampInt(value, min, max, fallback = 0) {
    const num = toInt(value, fallback);
    const lower = Number.isFinite(Number(min)) ? Number(min) : 0;
    const upper = Number.isFinite(Number(max)) ? Number(max) : lower;
    const safeMin = Math.min(lower, upper);
    const safeMax = Math.max(lower, upper);
    return Math.min(safeMax, Math.max(safeMin, num));
  }

  function readInputBound(input, attrName, fallback = 0) {
    if (!input || typeof input.getAttribute !== "function") return fallback;
    if (!input.hasAttribute(attrName)) return fallback;
    return toInt(input.getAttribute(attrName), fallback);
  }

  function hmsToSeconds(hours, minutes, seconds) {
    const h = toInt(hours, 0);
    const m = toInt(minutes, 0);
    const s = toInt(seconds, 0);
    return h * 3600 + m * 60 + s;
  }

  function msToSeconds(minutes, seconds) {
    const m = toInt(minutes, 0);
    const s = toInt(seconds, 0);
    return m * 60 + s;
  }

  function secondsToHms(totalSeconds) {
    const safe = Math.max(0, toInt(totalSeconds, 0));
    return {
      hours: Math.floor(safe / 3600),
      minutes: Math.floor((safe % 3600) / 60),
      seconds: safe % 60,
      totalSeconds: safe,
    };
  }

  function readHmsInputs(hoursInput, minutesInput, secondsInput) {
    const hours = toInt(hoursInput?.value, 0);
    const minutes = toInt(minutesInput?.value, 0);
    const seconds = toInt(secondsInput?.value, 0);
    return {
      hours,
      minutes,
      seconds,
      totalSeconds: hmsToSeconds(hours, minutes, seconds),
    };
  }

  function readMinutesSecondsInputs(minutesInput, secondsInput) {
    const minutes = toInt(minutesInput?.value, 0);
    const seconds = toInt(secondsInput?.value, 0);
    return {
      minutes,
      seconds,
      totalSeconds: msToSeconds(minutes, seconds),
    };
  }

  function createSessionTimeInputUtils() {
    return {
      toInt,
      clampInt,
      readInputBound,
      hmsToSeconds,
      msToSeconds,
      secondsToHms,
      readHmsInputs,
      readMinutesSecondsInputs,
    };
  }

  sharedRoot.createSessionTimeInputUtils = createSessionTimeInputUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/hotkeys-utils.js ===== */
(function initPoseChronoSharedHotkeysUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSchemaVersion(value, fallback = 1) {
    const num = Number(value);
    return Number.isFinite(num) ? Math.max(1, Math.round(num)) : fallback;
  }

  function toSet(input) {
    if (input instanceof Set) return new Set(input);
    if (Array.isArray(input)) return new Set(input);
    return new Set();
  }

  function createHotkeysUtils(options = {}) {
    const schemaVersion = toSchemaVersion(options.schemaVersion, 1);
    const defaultBindings =
      options.defaultBindings && typeof options.defaultBindings === "object"
        ? options.defaultBindings
        : {};
    const nonCustomizableKeys = toSet(options.nonCustomizableKeys);

    function normalizeHotkeysPayload(raw) {
      const sourceBindings =
        raw &&
        typeof raw === "object" &&
        raw.bindings &&
        typeof raw.bindings === "object"
          ? raw.bindings
          : raw && typeof raw === "object"
            ? raw
            : {};

      let repaired = false;
      const bindings = {};

      Object.keys(defaultBindings).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(sourceBindings, key)) return;

        const rawValue = sourceBindings[key];
        if (typeof rawValue !== "string") {
          repaired = true;
          return;
        }
        const value = rawValue.trim();
        if (value.length === 0) {
          repaired = true;
          return;
        }
        if (value.length > 48) {
          repaired = true;
          bindings[key] = value.slice(0, 48);
          return;
        }
        bindings[key] = value;
      });

      const payload = {
        schemaVersion,
        bindings,
      };

      if (
        !raw ||
        typeof raw !== "object" ||
        raw.schemaVersion !== schemaVersion ||
        !raw.bindings
      ) {
        repaired = true;
      }

      return { payload, bindings, repaired };
    }

    function collectCustomBindings(currentBindings) {
      const source =
        currentBindings && typeof currentBindings === "object"
          ? currentBindings
          : {};
      const out = {};

      Object.keys(defaultBindings).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(source, key)) return;
        if (source[key] === defaultBindings[key]) return;
        out[key] = source[key];
      });

      return out;
    }

    function countCustomBindings(currentBindings) {
      return Object.keys(collectCustomBindings(currentBindings)).length;
    }

    function normalizeForConflictCompare(value) {
      if (!value) return "";
      const text = String(value);
      if (text.includes("+")) return text;
      return text.toLowerCase();
    }

    function findHotkeyConflict(
      currentBindings,
      hotkeyName,
      newValue,
      options = {},
    ) {
      if (!newValue) return null;
      const source =
        currentBindings && typeof currentBindings === "object"
          ? currentBindings
          : {};
      const drawingPrefix = String(options.drawingPrefix || "DRAWING_");
      const isDrawingKey = String(hotkeyName || "").startsWith(drawingPrefix);
      const normalizedNew = normalizeForConflictCompare(newValue);

      for (const [key, value] of Object.entries(source)) {
        if (key === hotkeyName) continue;
        if (!value) continue;
        const normalizedExisting = normalizeForConflictCompare(value);
        if (normalizedExisting !== normalizedNew) continue;
        const isOtherDrawing = key.startsWith(drawingPrefix);
        if (isDrawingKey === isOtherDrawing) {
          return key;
        }
      }
      return null;
    }

    function formatHotkeyDisplay(hotkeyName, value, optionsArg = {}) {
      if (!value) return "";
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const implicitModifiers =
        options.implicitModifiers && typeof options.implicitModifiers === "object"
          ? options.implicitModifiers
          : {};
      const raw = String(value);

      if (raw.includes("+")) {
        return raw.split("+").join(" + ");
      }

      const parts = [];
      const implicitMod = implicitModifiers[hotkeyName];
      if (implicitMod) {
        parts.push(String(implicitMod));
      }

      if (
        !implicitMod &&
        raw.length === 1 &&
        raw >= "A" &&
        raw <= "Z"
      ) {
        parts.push("Shift");
      }

      parts.push(raw.length === 1 ? raw.toUpperCase() : raw);
      return parts.join(" + ");
    }

    function resetBindingsToDefaults(targetBindings) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      Object.keys(defaultBindings).forEach((key) => {
        targetBindings[key] = defaultBindings[key];
      });
      return targetBindings;
    }

    function enforceNonCustomizableBindings(targetBindings) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      nonCustomizableKeys.forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(defaultBindings, key)) return;
        targetBindings[key] = defaultBindings[key];
      });
      return targetBindings;
    }

    function applyCustomBindings(targetBindings, customBindings, optionsArg = {}) {
      if (!targetBindings || typeof targetBindings !== "object") return targetBindings;
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const resetFirst = !!options.resetToDefaults;
      const enforceAfter =
        options.enforceNonCustomizable === undefined
          ? true
          : !!options.enforceNonCustomizable;
      const requireTargetKey =
        options.requireTargetKey === undefined ? true : !!options.requireTargetKey;
      const source =
        customBindings && typeof customBindings === "object" ? customBindings : {};

      if (resetFirst) {
        resetBindingsToDefaults(targetBindings);
      }

      Object.keys(source).forEach((key) => {
        if (nonCustomizableKeys.has(key)) return;
        if (!Object.prototype.hasOwnProperty.call(defaultBindings, key)) return;
        if (
          requireTargetKey &&
          !Object.prototype.hasOwnProperty.call(targetBindings, key)
        ) {
          return;
        }
        targetBindings[key] = source[key];
      });

      if (enforceAfter) {
        enforceNonCustomizableBindings(targetBindings);
      }
      return targetBindings;
    }

    return {
      normalizeHotkeysPayload,
      collectCustomBindings,
      countCustomBindings,
      normalizeForConflictCompare,
      findHotkeyConflict,
      formatHotkeyDisplay,
      resetBindingsToDefaults,
      enforceNonCustomizableBindings,
      applyCustomBindings,
    };
  }

  sharedRoot.createHotkeysUtils = createHotkeysUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/storage-diagnostics-utils.js ===== */
(function initPoseChronoSharedStorageDiagnosticsUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function safeCall(fn, fallback) {
    try {
      if (typeof fn === "function") return fn();
    } catch (_) {}
    return fallback;
  }

  function extractTimelineStatsFromData(data) {
    const source =
      data &&
      typeof data === "object" &&
      data.data &&
      typeof data.data === "object"
        ? data.data
        : data;
    const daysObj =
      source && typeof source === "object" && source.days ? source.days : {};
    const daysEntries =
      daysObj && typeof daysObj === "object" ? Object.values(daysObj) : [];
    const days = daysEntries.length;
    const sessions = daysEntries.reduce(
      (sum, day) =>
        sum + (Array.isArray(day && day.sessions) ? day.sessions.length : 0),
      0,
    );
    return { days, sessions };
  }

  async function collectStorageDiagnostics(input = {}) {
    const diagnostics = {
      timelineDays: 0,
      timelineSessions: 0,
      plansCount: 0,
      customHotkeysCount: 0,
    };

    const hotkeysCount =
      typeof input.customHotkeysCount === "number"
        ? input.customHotkeysCount
        : safeCall(input.getCustomHotkeysCount, 0);
    diagnostics.customHotkeysCount = Math.max(
      0,
      Number.isFinite(hotkeysCount) ? Math.round(hotkeysCount) : 0,
    );

    try {
      let timelineSource = undefined;
      if (typeof input.getTimelineData === "function") {
        timelineSource = await input.getTimelineData();
      }
      if (
        timelineSource === undefined &&
        typeof input.loadTimelinePayload === "function"
      ) {
        timelineSource = await input.loadTimelinePayload();
      }
      if (timelineSource !== undefined) {
        const timelineStats = extractTimelineStatsFromData(timelineSource);
        diagnostics.timelineDays = timelineStats.days;
        diagnostics.timelineSessions = timelineStats.sessions;
      }
    } catch (_) {}

    try {
      let plansPayload = undefined;
      if (typeof input.loadPlansPayload === "function") {
        plansPayload = await input.loadPlansPayload();
      }
      if (
        plansPayload === undefined &&
        typeof input.loadLegacyPlansPayload === "function"
      ) {
        plansPayload = await input.loadLegacyPlansPayload();
      }

      if (plansPayload !== undefined && plansPayload !== null) {
        if (typeof input.normalizeSessionPlansPayload === "function") {
          const normalized = input.normalizeSessionPlansPayload(plansPayload);
          const count = normalized && normalized.plans && normalized.plans.length;
          diagnostics.plansCount = Math.max(
            0,
            Number.isFinite(count) ? Math.round(count) : 0,
          );
        } else if (Array.isArray(plansPayload)) {
          diagnostics.plansCount = plansPayload.length;
        } else if (plansPayload && Array.isArray(plansPayload.plans)) {
          diagnostics.plansCount = plansPayload.plans.length;
        }
      }
    } catch (_) {}

    return diagnostics;
  }

  function createStorageDiagnosticsUtils() {
    return {
      extractTimelineStatsFromData,
      collectStorageDiagnostics,
    };
  }

  sharedRoot.createStorageDiagnosticsUtils = createStorageDiagnosticsUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-sanitizer-utils.js ===== */
(function initPoseChronoSharedTimelineSanitizerUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toInt(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? Math.round(num) : fallback;
  }

  function clamp(value, min, max, fallback = min) {
    const num = toInt(value, fallback);
    return Math.max(min, Math.min(max, num));
  }

  function createTimelineSanitizerUtils(options = {}) {
    const schemaVersion = Math.max(1, toInt(options.schemaVersion, 1));
    const minPoses = Math.max(0, toInt(options.minPoses, 1));
    const minTimeSeconds = Math.max(0, toInt(options.minTimeSeconds, 0));
    const maxTimePerSession = Math.max(
      minTimeSeconds,
      toInt(options.maxTimePerSession, 86400),
    );
    const nowIso =
      typeof options.nowIso === "function"
        ? options.nowIso
        : () => new Date().toISOString();

    function getDefaultData() {
      return {
        days: {},
        stats: {
          totalPoses: 0,
          totalTime: 0,
          currentStreak: 0,
          bestStreak: 0,
          lastSessionDate: null,
        },
      };
    }

    function sanitizeSessionImageEntry(image) {
      if (typeof image === "string") {
        const value = image.trim();
        if (!value) return null;
        return value.slice(0, 4096);
      }

      if (!image || typeof image !== "object") return null;

      const out = {};

      if (
        image.id !== undefined &&
        image.id !== null &&
        (typeof image.id === "string" || typeof image.id === "number")
      ) {
        out.id = image.id;
      }

      const copyString = (key, maxLen = 4096) => {
        if (typeof image[key] !== "string") return;
        const value = image[key].trim();
        if (!value) return;
        out[key] = value.slice(0, maxLen);
      };

      copyString("filePath");
      copyString("path");
      copyString("file");
      copyString("thumbnailURL");
      copyString("thumbnail");
      copyString("url");
      copyString("name", 256);
      copyString("ext", 32);

      if (Object.keys(out).length === 0) return null;
      return out;
    }

    function sanitizeSessionEntry(session) {
      if (!session || typeof session !== "object") return null;
      const poses = Math.max(0, toInt(session.poses, 0));
      const time = clamp(session.time, 0, maxTimePerSession, 0);
      if (poses < minPoses || time < minTimeSeconds) {
        return null;
      }
      const hour = clamp(session.hour, 0, 23, 0);
      const minute = clamp(session.minute, 0, 59, 0);
      const timestamp =
        typeof session.timestamp === "string" &&
        !Number.isNaN(Date.parse(session.timestamp))
          ? session.timestamp
          : nowIso();
      const mode =
        typeof session.mode === "string" ? session.mode.slice(0, 32) : "classique";
      const memoryType =
        session.memoryType === "flash" || session.memoryType === "progressive"
          ? session.memoryType
          : null;
      const customQueue = Array.isArray(session.customQueue) ? session.customQueue : null;
      const images = Array.isArray(session.images)
        ? session.images
            .map((img) => sanitizeSessionImageEntry(img))
            .filter(Boolean)
            .slice(0, 1000)
        : [];

      return {
        timestamp,
        hour,
        minute,
        poses,
        time,
        mode,
        memoryType,
        customQueue,
        images,
      };
    }

    function validateSessionValues(poses, time) {
      const validPoses = Math.max(0, toInt(poses, 0));
      const validTime = clamp(time, 0, maxTimePerSession, 0);
      const isValid = validPoses >= minPoses && validTime >= minTimeSeconds;
      return { poses: validPoses, time: validTime, isValid };
    }

    function sanitizeData(candidate) {
      const base = getDefaultData();
      const raw = candidate && typeof candidate === "object" ? candidate : {};
      let repaired = false;

      const rawDays = raw.days && typeof raw.days === "object" ? raw.days : {};
      if (!raw.days || typeof raw.days !== "object") repaired = true;

      for (const [dateKey, dayValue] of Object.entries(rawDays)) {
        if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
          repaired = true;
          continue;
        }
        const day = dayValue && typeof dayValue === "object" ? dayValue : {};
        if (!dayValue || typeof dayValue !== "object") repaired = true;

        const sessionsRaw = Array.isArray(day.sessions) ? day.sessions : [];
        if (!Array.isArray(day.sessions)) repaired = true;
        const sessions = sessionsRaw
          .map((s) => sanitizeSessionEntry(s))
          .filter(Boolean)
          .slice(-50);
        if (sessions.length !== sessionsRaw.length) repaired = true;

        const posesFromSessions = sessions.reduce((sum, s) => sum + (s.poses || 0), 0);
        const timeFromSessions = sessions.reduce((sum, s) => sum + (s.time || 0), 0);
        const posesRaw = Math.max(0, toInt(day.poses, 0));
        const timeRaw = Math.max(0, toInt(day.time, 0));
        const poses = sessions.length > 0 ? posesFromSessions : posesRaw;
        const time = sessions.length > 0 ? timeFromSessions : timeRaw;

        if (poses !== posesRaw || time !== timeRaw) repaired = true;

        base.days[dateKey] = { poses, time, sessions };
      }

      base.stats = {
        totalPoses: Math.max(0, toInt(raw.stats?.totalPoses, 0)),
        totalTime: Math.max(0, toInt(raw.stats?.totalTime, 0)),
        currentStreak: Math.max(0, toInt(raw.stats?.currentStreak, 0)),
        bestStreak: Math.max(0, toInt(raw.stats?.bestStreak, 0)),
        lastSessionDate:
          typeof raw.stats?.lastSessionDate === "string" &&
          /^\d{4}-\d{2}-\d{2}$/.test(raw.stats.lastSessionDate)
            ? raw.stats.lastSessionDate
            : null,
      };

      const computedPoses = Object.values(base.days).reduce(
        (sum, day) => sum + (day.poses || 0),
        0,
      );
      const computedTime = Object.values(base.days).reduce(
        (sum, day) => sum + (day.time || 0),
        0,
      );

      if (base.stats.totalPoses !== computedPoses || base.stats.totalTime !== computedTime) {
        repaired = true;
        base.stats.totalPoses = computedPoses;
        base.stats.totalTime = computedTime;
      }

      return { data: base, repaired };
    }

    function normalizePayload(rawPayload) {
      if (!rawPayload || typeof rawPayload !== "object") {
        const sanitized = sanitizeData(null);
        return {
          payload: {
            schemaVersion,
            data: sanitized.data,
          },
          data: sanitized.data,
          repaired: true,
        };
      }

      const sourceData =
        rawPayload.schemaVersion === schemaVersion && rawPayload.data
          ? rawPayload.data
          : rawPayload;
      const sanitized = sanitizeData(sourceData);
      const payload = {
        schemaVersion,
        data: sanitized.data,
      };

      const repaired =
        sanitized.repaired ||
        rawPayload.schemaVersion !== schemaVersion ||
        !rawPayload.data;

      return { payload, data: sanitized.data, repaired };
    }

    function mergeDayEntries(existingDay, incomingDay) {
      const base = existingDay && typeof existingDay === "object" ? existingDay : {};
      const next = incomingDay && typeof incomingDay === "object" ? incomingDay : {};

      const existingSessions = Array.isArray(base.sessions) ? base.sessions : [];
      const incomingSessions = Array.isArray(next.sessions) ? next.sessions : [];
      const mergedSessions = [];
      const seen = new Set();

      [...existingSessions, ...incomingSessions].forEach((session) => {
        if (!session || typeof session !== "object") return;
        const signature = [
          session.timestamp || "",
          session.hour ?? "",
          session.minute ?? "",
          session.poses ?? "",
          session.time ?? "",
          session.mode || "",
          session.memoryType || "",
          Array.isArray(session.images) ? session.images.length : 0,
        ].join("|");
        if (seen.has(signature)) return;
        seen.add(signature);
        mergedSessions.push(session);
      });

      mergedSessions.sort((a, b) => {
        const at = Date.parse(a?.timestamp || "") || 0;
        const bt = Date.parse(b?.timestamp || "") || 0;
        return at - bt;
      });

      const limitedSessions = mergedSessions.slice(-50);
      const posesFromSessions = limitedSessions.reduce(
        (sum, s) => sum + (Number(s?.poses) || 0),
        0,
      );
      const timeFromSessions = limitedSessions.reduce(
        (sum, s) => sum + (Number(s?.time) || 0),
        0,
      );

      return {
        poses:
          limitedSessions.length > 0
            ? posesFromSessions
            : Math.max(Number(base.poses) || 0, Number(next.poses) || 0),
        time:
          limitedSessions.length > 0
            ? timeFromSessions
            : Math.max(Number(base.time) || 0, Number(next.time) || 0),
        sessions: limitedSessions,
      };
    }

    function mergeTimelineDatas(datasets) {
      const merged = getDefaultData();
      const sources = Array.isArray(datasets) ? datasets : [];
      sources.forEach((data) => {
        if (!data || typeof data !== "object" || !data.days) return;
        Object.entries(data.days).forEach(([dateKey, day]) => {
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) return;
          if (!merged.days[dateKey]) {
            merged.days[dateKey] = mergeDayEntries(null, day);
            return;
          }
          merged.days[dateKey] = mergeDayEntries(merged.days[dateKey], day);
        });
      });
      return merged;
    }

    function listLocalCandidateKeys(storage, optionsArg = {}) {
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const baseKeys = Array.isArray(options.baseKeys) ? options.baseKeys : [];
      const backupPrefixes = Array.isArray(options.backupPrefixes)
        ? options.backupPrefixes
        : [];
      const includeBackupsIfPrimaryMissing =
        options.includeBackupsIfPrimaryMissing !== false;
      const maxBackupsPerPrefix = Math.max(
        0,
        toInt(options.maxBackupsPerPrefix, 2),
      );
      const keys = new Set(
        baseKeys
          .map((k) => String(k || "").trim())
          .filter(Boolean),
      );

      try {
        if (
          !storage ||
          typeof storage.length !== "number" ||
          typeof storage.key !== "function"
        ) {
          return Array.from(keys);
        }
        const hasPrimaryData = baseKeys.some((baseKey) => {
          const safeKey = String(baseKey || "").trim();
          if (!safeKey || typeof storage.getItem !== "function") return false;
          try {
            return storage.getItem(safeKey) != null;
          } catch (_) {
            return false;
          }
        });
        const shouldIncludeBackups =
          backupPrefixes.length > 0 &&
          (includeBackupsIfPrimaryMissing ? !hasPrimaryData : false);
        const backupBuckets = new Map();

        for (let i = 0; i < storage.length; i++) {
          const key = storage.key(i);
          if (!key) continue;
          if (!shouldIncludeBackups) continue;
          const backupPrefix = backupPrefixes.find((prefix) =>
            String(key).startsWith(prefix),
          );
          if (!backupPrefix) continue;
          if (!backupBuckets.has(backupPrefix)) {
            backupBuckets.set(backupPrefix, []);
          }
          backupBuckets.get(backupPrefix).push(key);
        }

        backupBuckets.forEach((bucketKeys) => {
          const sorted = bucketKeys.slice().sort().reverse();
          const kept =
            maxBackupsPerPrefix > 0
              ? sorted.slice(0, maxBackupsPerPrefix)
              : sorted;
          kept.forEach((backupKey) => keys.add(backupKey));
        });
      } catch (_) {}
      return Array.from(keys);
    }

    function isBackupTimelineKey(storageKey, backupPrefixes = []) {
      const key = String(storageKey || "");
      return backupPrefixes.some((prefix) => key.startsWith(String(prefix)));
    }

    function loadFromLocalStorageKey(
      storage,
      storageKey,
      normalizePayload,
      optionsArg = {},
    ) {
      const options =
        optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const onRepaired =
        typeof options.onRepaired === "function" ? options.onRepaired : null;
      const backupPrefixes = Array.isArray(options.backupPrefixes)
        ? options.backupPrefixes
        : [];
      const reportBackupRepairs = options.reportBackupRepairs === true;
      try {
        if (!storage || typeof storage.getItem !== "function") return null;
        const stored = storage.getItem(storageKey);
        if (!stored) return null;
        const parsed = JSON.parse(stored);
        if (typeof normalizePayload === "function") {
          const normalized = normalizePayload(parsed);
          if (normalized?.repaired && onRepaired) {
            const isBackup = isBackupTimelineKey(storageKey, backupPrefixes);
            if (!isBackup || reportBackupRepairs) {
              try {
                onRepaired(storageKey);
              } catch (_) {}
            }
          }
          return normalized && normalized.data ? normalized.data : null;
        }
        return parsed;
      } catch (_) {}
      return null;
    }

    function writeTimelineBackup(storage, payload, optionsArg = {}) {
      const options = optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      const prefix = String(options.prefix || "posechrono-timeline-backup:");
      const keep = Math.max(1, toInt(options.keep, 3));
      try {
        if (
          !storage ||
          typeof storage.setItem !== "function" ||
          typeof storage.removeItem !== "function" ||
          typeof storage.key !== "function"
        ) {
          return;
        }
        const key = `${prefix}${Date.now()}`;
        storage.setItem(key, JSON.stringify(payload));

        const backupKeys = [];
        for (let i = 0; i < storage.length; i++) {
          const existingKey = storage.key(i);
          if (existingKey && String(existingKey).startsWith(prefix)) {
            backupKeys.push(existingKey);
          }
        }
        backupKeys.sort();
        while (backupKeys.length > keep) {
          const oldest = backupKeys.shift();
          if (oldest) storage.removeItem(oldest);
        }
      } catch (_) {}
    }

    function loadLocalCandidates(
      storage,
      candidateKeys,
      normalizePayload,
      optionsArg = {},
    ) {
      const out = [];
      const keys = Array.isArray(candidateKeys) ? candidateKeys : [];
      const options =
        optionsArg && typeof optionsArg === "object" ? optionsArg : {};
      keys.forEach((key) => {
        const data = loadFromLocalStorageKey(
          storage,
          key,
          normalizePayload,
          options,
        );
        if (!data) return;
        out.push(data);
      });
      return out;
    }

    function resolveLocalTimelineData(candidates, mergeTimelineDatas, getDefaultDataFn) {
      const list = Array.isArray(candidates) ? candidates : [];
      if (list.length === 0) {
        if (typeof getDefaultDataFn === "function") return getDefaultDataFn();
        return getDefaultData();
      }
      if (typeof mergeTimelineDatas === "function") {
        return mergeTimelineDatas(list);
      }
      return list[0] || getDefaultData();
    }

    function cloneData(data) {
      try {
        if (typeof structuredClone === "function") {
          return structuredClone(data);
        }
      } catch (_) {}
      return JSON.parse(JSON.stringify(data));
    }

    return {
      getDefaultData,
      sanitizeSessionImageEntry,
      sanitizeSessionEntry,
      validateSessionValues,
      sanitizeData,
      normalizePayload,
      mergeDayEntries,
      mergeTimelineDatas,
      listLocalCandidateKeys,
      writeTimelineBackup,
      loadFromLocalStorageKey,
      loadLocalCandidates,
      resolveLocalTimelineData,
      cloneData,
    };
  }

  sharedRoot.createTimelineSanitizerUtils = createTimelineSanitizerUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-date-utils.js ===== */
(function initPoseChronoSharedTimelineDateUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createTimelineDateUtils() {
    function toKey(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function getToday() {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return today;
    }

    function isSameDay(d1, d2) {
      return d1.toDateString() === d2.toDateString();
    }

    function isFuture(date, today) {
      return date > today;
    }

    function getMondayBefore(date) {
      const result = new Date(date);
      const dayOfWeek = result.getDay();
      const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
      result.setDate(result.getDate() + diff);
      result.setHours(0, 0, 0, 0);
      return result;
    }

    function getYearStartDate(year) {
      const jan1 = new Date(year, 0, 1);
      return getMondayBefore(jan1);
    }

    function diffInDays(d1, d2) {
      return Math.floor((d1 - d2) / (1000 * 60 * 60 * 24));
    }

    return {
      toKey,
      getToday,
      isSameDay,
      isFuture,
      getMondayBefore,
      getYearStartDate,
      diffInDays,
    };
  }

  sharedRoot.createTimelineDateUtils = createTimelineDateUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-media-utils.js ===== */
(function initPoseChronoSharedTimelineMediaUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toFileUrl(path) {
    if (typeof path !== "string") return "";
    const raw = path.trim();
    if (!raw) return "";
    if (/^(https?:|file:|data:|blob:)/i.test(raw)) return raw;

    const normalized = raw.replace(/\\/g, "/");
    if (/^[a-zA-Z]:\//.test(normalized)) {
      return `file:///${normalized}`;
    }
    if (normalized.startsWith("//")) {
      return `file:${normalized}`;
    }
    if (normalized.startsWith("/")) {
      return `file://${normalized}`;
    }
    return normalized;
  }

  function resolveTimelineImageSrc(image) {
    if (typeof image === "string") {
      return toFileUrl(image);
    }
    if (!image || typeof image !== "object") return "";

    const direct = [image.thumbnailURL, image.thumbnail, image.url].find(
      (v) => typeof v === "string" && v.trim().length > 0,
    );
    if (direct) return toFileUrl(direct);

    const fromPath = [image.filePath, image.path, image.file].find(
      (v) => typeof v === "string" && v.trim().length > 0,
    );
    return toFileUrl(fromPath || "");
  }

  function createTimelineMediaUtils() {
    return {
      toFileUrl,
      resolveTimelineImageSrc,
    };
  }

  sharedRoot.createTimelineMediaUtils = createTimelineMediaUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-display-utils.js ===== */
(function initPoseChronoSharedTimelineDisplayUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createTimelineDisplayUtils(deps = {}) {
    const t = typeof deps.t === "function" ? deps.t : null;
    const formatTime =
      typeof deps.formatTime === "function" ? deps.formatTime : (seconds) => String(seconds || 0);

    function translate(key, options, fallback) {
      if (t) {
        return t(key, options || {}, fallback || "");
      }
      return fallback || "";
    }

    function getDayLabels() {
      const result = translate("timeline.dayLabels", { returnObjects: true }, null);
      if (Array.isArray(result)) return result;
      return ["L", "M", "M", "J", "V", "S", "D"];
    }

    function getMonthLabels() {
      const result = translate("timeline.monthLabels", { returnObjects: true }, null);
      if (Array.isArray(result)) return result;
      return [
        "janv.",
        "fvr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "aot",
        "sept.",
        "oct.",
        "nov.",
        "dc.",
      ];
    }

    function getModeLabel(mode, memoryType) {
      const labels = {
        classique: translate("modes.classic.title", {}, "Classique"),
        custom: translate("modes.custom.title", {}, "Personnalis"),
        relax: translate("modes.relax.title", {}, "Tranquille"),
        memory: translate("modes.memory.title", {}, "Mmoire"),
      };

      let label = labels[mode] || mode;
      if (mode === "memory" && memoryType) {
        const memoryTypeLabels = {
          flash: translate("modes.memory.flash", {}, "Flash"),
          progressive: translate("modes.memory.progressive", {}, "Progressif"),
        };
        const typeLabel = memoryTypeLabels[memoryType] || memoryType;
        label += ` (${typeLabel})`;
      }
      return label;
    }

    function formatCustomStructure(customQueue) {
      if (!customQueue || customQueue.length === 0) return "";

      const title = `<div class="custom-structure-title">${translate("timeline.sessionPlan", {}, "Plan de la session")}</div>`;

      const steps = customQueue.map((step) => {
        const timeStr = formatTime(step.duration);
        if (step.type === "pause") {
          return `<div class="custom-step pause">${translate("timeline.pauseStep", {}, "Pause")} ${timeStr}</div>`;
        }
        const poseWord =
          step.count > 1
            ? translate("timeline.poses", {}, "poses")
            : translate("timeline.pose", {}, "pose");
        return `<div class="custom-step pose">${step.count} ${poseWord} ${translate("timeline.of", {}, "de")} ${timeStr}</div>`;
      });

      return title + steps.join("");
    }

    return {
      getDayLabels,
      getMonthLabels,
      getModeLabel,
      formatCustomStructure,
    };
  }

  sharedRoot.createTimelineDisplayUtils = createTimelineDisplayUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-feedback-utils.js ===== */
(function initPoseChronoSharedTimelineFeedbackUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function createTimelineFeedbackUtils(deps = {}) {
    const doc =
      deps.document ||
      (typeof document !== "undefined" ? document : null);
    const raf =
      typeof deps.requestAnimationFrame === "function"
        ? deps.requestAnimationFrame
        : typeof requestAnimationFrame === "function"
          ? requestAnimationFrame
          : (cb) => cb();
    const scheduleTimeout =
      typeof deps.setTimeout === "function" ? deps.setTimeout : setTimeout;
    const cancelTimeout =
      typeof deps.clearTimeout === "function" ? deps.clearTimeout : clearTimeout;

    async function openConfirmDialog(options = {}) {
      const {
        title = "",
        message = "",
        confirmText = "OK",
        cancelText = "Cancel",
        checkboxLabel = "",
      } = options;

      if (typeof deps.showPoseChronoConfirmDialog === "function") {
        return deps.showPoseChronoConfirmDialog({
          title,
          message,
          confirmText,
          cancelText,
          checkboxLabel,
        });
      }

      if (typeof deps.showMessageBox === "function") {
        try {
          const result = await deps.showMessageBox({
            type: "warning",
            title,
            message,
            buttons: [cancelText, confirmText],
            defaultId: 0,
            cancelId: 0,
            ...(checkboxLabel ? { checkboxLabel } : {}),
          });

          return {
            confirmed: result.response === 1,
            checkboxChecked: !!result.checkboxChecked,
          };
        } catch (error) {
          if (typeof deps.logError === "function") {
            deps.logError(error);
          }
        }
      }

      return { confirmed: false, checkboxChecked: false };
    }

    function showToast(type, message, duration = 2500) {
      if (typeof deps.showPoseChronoToast === "function") {
        deps.showPoseChronoToast({ type, message, duration });
        return;
      }

      if (typeof deps.notify === "function") {
        deps.notify({
          title: message,
          body: "",
          mute: false,
          duration,
        });
      }
    }

    function scheduleUndoAction(options = {}) {
      if (typeof deps.schedulePoseChronoUndoAction === "function") {
        deps.schedulePoseChronoUndoAction(options);
        return true;
      }

      const {
        timeoutMs = 10000,
        onUndo,
        message = "Deleted. Undo available for 10 seconds.",
        undoLabel = "Undo",
      } = options;
      if (typeof onUndo !== "function" || !doc || !doc.body) return false;

      let container = doc.getElementById("posechrono-toast-container");
      if (!container) {
        container = doc.createElement("div");
        container.id = "posechrono-toast-container";
        container.className = "pc-toast-container";
        doc.body.appendChild(container);
      }

      const toast = doc.createElement("div");
      toast.className = "pc-toast pc-toast-info";

      const msg = doc.createElement("span");
      msg.className = "pc-toast-message";
      msg.textContent = message;
      toast.appendChild(msg);

      const btn = doc.createElement("button");
      btn.type = "button";
      btn.className = "pc-toast-action";
      btn.textContent = undoLabel;
      let timer = null;
      btn.addEventListener("click", () => {
        if (timer !== null) cancelTimeout(timer);
        try {
          onUndo();
        } catch (_) {}
        toast.classList.remove("visible");
        scheduleTimeout(() => toast.remove(), 180);
      });
      toast.appendChild(btn);

      container.appendChild(toast);
      raf(() => toast.classList.add("visible"));

      timer = scheduleTimeout(() => {
        toast.classList.remove("visible");
        scheduleTimeout(() => toast.remove(), 180);
      }, timeoutMs);

      return true;
    }

    return {
      openConfirmDialog,
      showToast,
      scheduleUndoAction,
    };
  }

  sharedRoot.createTimelineFeedbackUtils = createTimelineFeedbackUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

/* ===== packages/shared/timeline-format-utils.js ===== */
(function initPoseChronoSharedTimelineFormatUtils(globalScope) {
  "use strict";

  const globalObj = globalScope || (typeof window !== "undefined" ? window : {});
  const sharedRoot = globalObj.PoseChronoShared || {};

  function toSafeSeconds(value) {
    return Math.max(0, Math.floor(Number(value) || 0));
  }

  function createTimelineFormatUtils(options = {}) {
    const getLocale =
      typeof options.getLocale === "function" ? options.getLocale : () => "en-US";
    const minuteLabel =
      typeof options.minuteLabel === "string" && options.minuteLabel
        ? options.minuteLabel
        : "min";

    function formatNumber(num) {
      try {
        return Number(num || 0).toLocaleString(getLocale());
      } catch (_) {
        return String(Number(num || 0));
      }
    }

    function formatTime(seconds) {
      const safe = toSafeSeconds(seconds);
      if (safe <= 0) return "0s";

      const hours = Math.floor(safe / 3600);
      const minutes = Math.floor((safe % 3600) / 60);
      const secs = safe % 60;
      const parts = [];

      if (hours > 0) parts.push(`${hours}h`);
      if (minutes > 0) parts.push(`${minutes}${minuteLabel}`);
      if (secs > 0 && hours === 0) parts.push(`${secs}s`);

      if (parts.length === 0) return "0s";
      return parts.join(" ");
    }

    function formatDate(date, optionsArg) {
      const options =
        optionsArg || { weekday: "long", day: "numeric", month: "long" };
      try {
        return date.toLocaleDateString(getLocale(), options);
      } catch (_) {
        return String(date);
      }
    }

    return {
      toSafeSeconds,
      formatNumber,
      formatTime,
      formatDate,
    };
  }

  sharedRoot.createTimelineFormatUtils = createTimelineFormatUtils;
  globalObj.PoseChronoShared = sharedRoot;
})(typeof window !== "undefined" ? window : globalThis);

